## 第二章 变量与基本类型

### 变量名称

#### 变量（C++Primer 5中又叫标识符）命名规则

- 变量名称只能使用字母字符、数字和下划线。
- 变量名称的第一个字符不能是数字。
- 变量名称区分字母字符大小写。
- 不能使用C++关键字用作变量名称。
- C++对于变量名称的长度没有限制，名称中所有的字符都有意义，但有些平台会有长度限制。
- 以两个下划线或下划线加大写字母开头的名称被保留给实现（编译器以及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符。（意思就是：用户自定义的变量名称中不能用两个下划线开头或者下划线+大写字母开头。此外，定义在函数体外的变量名称不能以下划线开头。）

#### 良好的命名规范（这不是硬性要求，但保持好的命名规范也是一个良好的编程习惯）

- 变量名要能体现实际含义。
- 变量名一般用小写字母。
- 用户自定义的类名一般以大写字母开头。
- 如果变量名由多个单词组成，则单词间应由明显的区分，例如，student_loan或者studentLoan而不是studentloan。

### 整型

#### 整型short、int、long、long long

- short至少16位
- int至少与short一样长
- long至少32位，且至少与int一样长
- long long至少64位，且至少与long一样长
- 头文件climits（老式实现为limits.h）中包含了关于整型限制的信息。
- sizeof运算符用来求当前系统中变量类型所占的字节数。sizeof可对类型名或变量名使用。对类型名使用sizeof时应将类型名放在括号中sizeof(int)；但对变量名使用sizeof时，括号时可选的sizeof a或sizeof(a)。



#### 整型字面值

- 整型字面值（常量）是显示的书写的常量，例如123或233.
- 以0开头的是八进制数；以0x或0X开头的是16进制；普通的就是十进制。
- 在C++中要想打印出16进制或8进制则可以使用控制度dec、hex和oct来控制cout以十进制、十六进制和八进制格式显示整数。默认的是十进制格式。例子：`cout << hex;` `cout << oct;`

#### char类型：字符和小整数

- char类型是另一种整型。
- C++对字符用单引号，对字符串用双引号。
- cout的一项特性—cout.put()函数：显示一个字符。

#### 类型所能表示的值的范围决定了转换的过程

- 把一个非布尔类型的算术值赋给布尔类型时，若初始值为0则结果为false，否则结果为true。
- 把一个布尔类值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。
- 把一个浮点数赋给整型类型时，结果值将只保留浮点数小数点之前的部分（不是简单的四舍五入）。
- 把一个整数值赋给浮点类型时，小数部分记为0.。如果该整数所占的空间超过了浮点数的容量，精度可能有损失。
- 当赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数，例如，8比特的unsigned char 可以表示0-255间的值，当给它赋值为256时，该char所得的结果为0。
- 当赋给带符号类型一个超出它表示范围的值时，结果是未定义的。

### 初始化

- C语言中的初始化是使用等号=。
- C++中的初始化使用花括号{}这种方式在C++11中得到全面应用，又叫列表初始化，例如， `int a{10};`或 `int a = {10};`，即这里用不用等号都可以。若花括号中不包含任何东西，则变量就会被初始化为 0。
- 也可以使用小括号()来进行初始化，例如：`int a(10);` 。

#### 默认初始化：

- 如果内置类型的变量未被显示初始化，它的值由定义的位置决定。定义任何函数体之外的变量会被默认初始化为0。
- 一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。

#### 变量声明和定义的关系

- 变量和声明的相同点是都规定了变量的类型和名字，

- 不同点是定义还申请存储空间，也可能会为变量赋一个初始值。

- 如果想声明一个变量而非定义它，就需要在变量名前添加关键字`extern`。

  ```c++
  extern int i; //声明i而非定义i
  int j;        //声明并定义j
  ```

### 复合类型

#### 引用

- 通过将声明符写成&d的形式来定义引用类型，这里的d是变量名

  ```c++
  int a = 1024;
  int &d = a;
  ```

- 一般在初始化变量时，初始值会被拷贝到新建的对象中。而在定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。

- 一旦初始化完成，引用将和它的初始值对象一直绑定在一起。

- 因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

- 引用即别名：引用不是对象，它只是为一个已经存在的对象起了另外一个名字。

- 除了常量引用和另一种情况（之后提到）外，其他所用引用的类型必须都要喝与之绑定的对象严格匹配。

- 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。即“int类型的非const（常量）左值引用不能绑定到int类型的临时值上”。

- const的引用：

  - 对常量的引用不能用来修改它所绑定的对象。

  - 非常量引用不能与常量对象绑定。报错提醒“Binding value of type 'const int' to reference to type 'int' drops 'const' qualifier”（将'const int'类型的值绑定到'int'类型的引用会删除'const'限定符）。假设普通引用可以与常量对象绑定，那么从这个普通引用的角度来说可以改变与之绑定的对象的值；但从与之绑定的对象来说，该对象是一个常量，是无法再修改值的。由此可见前后矛盾，因此不能用普通引用与常量对象进行绑定。

  - 例外情况：在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。

  - 允许一个常量引用绑定非常量的对象、字面值，甚至是一个表达式：

    ```c++
    int i = 42; 	 		
    const int &r1 = i;			// 允许将const int& 绑定到一个普通的int对象上
    const int &r2 = 42;			// 正确：r2是一个常量引用
    const int &r3 = r1 * 2;		// 正确：r3是一个常量引用
    int &r4 = r1 * 2;			// 错误：r4是一个普通的非常量引用
    ```

    

#### 指针

#### 理解复合类型的声明



### const限定符

- 因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。
- 默认状态下，const对象仅在文件内有效。
- 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。

#### 顶层const

- 指针本身是一个对象，它又可以指向另一个对象。因此，指针本身是不是常量以及指针所指的对象是不是常量就是两个相互独立的问题。

- 顶层const表示指针本身是个常量。

- 底层const表示指针所指的对象是一个常量。

  - ```c++
    int i = 0;
    int *const p1 = &i; 	// 不能改变p1的值，这是一个顶层const
    const int ci = 42; 		// 不能改变ci的值，这是一个顶层const
    const int *p2 = &ci; 	// 允许改变p2的值，这是一个底层const
    const int *const p3 = p2; // 靠右的const是顶层，靠左的const是底层 
    const int &r = ci;  //用于声明引用的const都是底层const
    ```

#### constexpr和常量表达式

- 一个对象或表达式是不是常量表达式由它的数据类型和初始值共同决定。

- C++11中规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。

- 声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：

  ```c++
  constexpr int mf = 20;  // 20是常量表达式
  constexpr int limit = mf + 1; //mf+1是常量表达式
  constexpr int sz = get_sz(); //只有当get_sz()是一个constexpr函数时，这个语句才是一条正确的声明
  ```

- `constexpr int *q = nullptr;`表示q是一个指向整数的常量指针，而`const int *p = nullptr;`表示p是一个指向整型常量的指针。

### 处理类型

#### 类型别名

- 有两种方法可以定义类型别名：
  - typedef：`typedef double wages;`wages是double的同义词
  - using：`using SI = Sales_item;`SI是Sales_item的同义词

#### auto类型说明符

- C++11新标准引入auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。
- auto让编译器通过初始值来推算变量的类型。
- 因此，auto定义的变量必须有初始值。
- auto一般会忽略掉顶层const，同时底层const则会保留下来。

#### decltype类型指示符

- 作用是选择并返回操作数的数据类型。编译器分析表达式并得到它的类型，却不实际计算表达式的值。

  ```c++
  decltype(f()) sum = x; //sum的类型就是函数f的返回类型
  ```

  