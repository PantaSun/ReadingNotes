## 第三章 字符串、向量和数组

### 3.1 命名空间using的声明

- 操作符 :: 的意思是：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。
- std::cin 的意思是使用命名空间 std 中的名字 cin 。
- 上面这种方法比较麻烦，每次要使用 cin 的时候都要使用 std:: ，因此可以使用 using 声明
- 格式：`using namespace::name;`，例如：`using std::cin;`。一旦这样声明了 cin，则之后再使用cin 就不需要每次都加专门的`std::`前缀。
- 每个using声明引入命名空间的一个成员。
- 头文件不应包含 using 声明，因为头文件的内容会被拷贝到所有引用这个头文件的其他文件中，这样可能会对其他文件内容产生冲突。

### 3.2 标准库类型 string

- 范围 for 循环

  ```c++
  std::string s = "hello world!!!";
  for(auto &c: s)
    c = toupper(c);
  std::cout << s << std::endl;
  ```

  ​

### 3.3 标准库类型 vector

- vector 表示对象的集合，其中所有对象的类型相同。
- 引用不是对象，所以不存在包含引用的vector。

#### 3.3.1 定义和初始化 vector 对象

- 列表初始化 

  ``` c++
  vector<string> v1{"a", "an", "the"};
  ```

- 创建指定数量的元素

  ```c++
  vector<int> ivec(10, -1);  // 10 个 int 类型的元素，每个都被初始化为 -1
  vector<string> svec(10, "hi"); // 10 个 string 类型的元素，每个都被初始化为 "hi"
  ```

- 值初始化

  ```c++
  vector<int> ivec(10); // 10 个元素，每个都初始化为 0
  vector<string> svec(10) // 10 个元素，每个都被初始化为空 string 对象
  ```


- 一般来说用圆括号()，可以说提供的值是用来构造vector对象的，而花括号{}是用来列表初始化vector对象的，但也有特例：如果使用了花括号的形式，但括号里提供的值又不能用来列表初始化，那就要考虑是用这样的值来构造vector对象了。

  ```c++
  // 如果列表初始化一个含有string对象的vector对象，应该提供能赋值给string对象的初值。
  vector<string> v1{10}; //v1 有10个默认初始化的值
  vector<string> v2{10, "hi"}; // v2 有10个值为”hi“的元素
  vector<string> v3(10, "hi"); // 这才是常规的构造vector的表达
  ```

  ​

#### 3.3.2 向 vector 对象中添加元素

- 用 vector 的成员函数 push_back 向一个事先创建好的 vector 对象中添加元素，添加到 vector 的尾端。

  ```c++
  vector<int> v;
  for(int i = 0; i <= 100; i++)
  	v.push_back(i);
  ```

- 不能使用下标形式添加元素，vector 对象（以及 string 对象）的下标运算可用于访问已存在的元素，而不能用于添加元素。

- 再次强调，只能对确知已存在的元素执行下标操作！确保下标合法的一种有效的手段是尽可能的使用范围 for 循环语句。

- 但是，如果某个下标对应的对象值已经存在，则可以用下标形式来修改其值，因为修改值而不是新添加一个对象到 vector 中，若想新添加一个元素到 vector 中，就需要使用push_back。

  ```c++
  vector<int> v2(10,0);
  v2[5] = 100;
  std::cout<< v2[5] << std::endl;
  ```



### 3.4 迭代器介绍

所有标准库容器都可以使用迭代器， 但其中只有少数几种才同时支持下标操作。严格来说，string 对象不属于容器类型，但 string 支持很多与容器类型类似的操作。

#### 3.4.1 使用迭代器

- 有迭代器的类型拥有返回迭代器的成员。比如，这些类型都有名为 begin 和 end 的成员

- - begin ：返回指向第一个元素的迭代器

  - end ：返回指向容器尾元素的下一个位置的迭代器，该迭代器常被成为“尾后迭代器”。

  - 若容器为空的话，begin 和 end 返回的是同一个迭代器。

  - ```c++
    vector<string> v(10, "hi");
    auto a = v.begin();
    auto b = v.end();
    ```

- 迭代器运算符：

  - *iter : 返回迭代器 iter 所指元素的引用
  - iter->mem ：解引用 iter 并获取该元素名为mem的成员，等价于 (*iter).mem
  - ++iter ：令 iter 指示容器的下一个元素
  - --iter ：令 iter 指示容器的上一个元素
  - iter1 == iter2 ：判断两个迭代器是否相等，如果两个迭代器指示的是同一个元素或它们是同一个容器的尾后迭代器，则相等；反之，不相等。 

- 将迭代器从一个元素移动到另一个元素。要注意的是：end 返回的迭代器并不实际指向某个元素，因此不能对其进行递增或解引用。

- 迭代器类型：用 iterator 和 const_iterator 来表达迭代器的类型，其中const_iterator 和常量指针差不多，能读取但不能修改它所指的元素值；而 iterator 既能读又能写。如果对象只需要读操作无须写操作的话最好使用常量类型。

- C++11新标准：引入了两个新的函数：cbegin 和 cend，和原来两个函数的区别如下：也就是说无论vector 对象本身是否是常量，这两个新函数的返回值都是 const_iterator。

  ```c++
  const vector<int> v1;
  vector<int> v2;
  auto it1 = v1.begin(); 	// it1 的类型是 vector<int>::iterator
  auto it2 = v1.cbegin();	// it2 的类型是 vector<int>::const_iterator
  auto it3 = v2.begin();  // it3 的类型是 vector<int>::const_iterator
  ```

- 结合解引用和成员访问操作

  ```
  (*it).empty() //解引用it，然后调用结果对象的 empty 成员
  *it.empty()   //错误用法，先调用 it 的 empty 成员，但 it 是个迭代器，没有 empty 成员
  (*it).empty() 有个简化用法 ：it->empty()
  ```

- 但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素

### 3.5 数组

- 数组是存放类型相同的对象的容器，但数组大小固定不变，不能随意向数组中添加元素。

#### 3.5.1 定义和初始化内置数组

- 数组的声明形式为：类型 a[d]，a 是数组的名字，d 是数组的维度，维度说明了数组中元素的个数，所以必须大于0。维度在编译时应该是已知的，也就是说维度必须是一个常量表达式。

  ```c++
  // 书中说这种方式是不允许的，书中认为 cnt 不是一个常量表达式，
  // 但是我执行下边这种方式时，编译器并未报错。
  // 但我觉得书中的“要用常量表达式来定义数组”确实会严谨一些
  unsigned cnt = 42;
  string bad[cnt];
  // 严谨的做法
  constexpr unsigned sz = 42;
  string good[sz];
  ```

- 定义数组时要指明数组的类型，不允许使用 auto 关键字由初始值列表来推断类型。

- 与 vector 一样，数组的元素必须为对象，所以不能存放引用。

- 数组在定义时可以忽略维度，编译器会根据初始值的数量计算并推测出维度。若只是不带初始值时忽略维度值，就会报错（毕竟编译器不会凭空计算并推测维度值）。

  ```c++
  int a[] = {0, 1, 2}; // 维度为3的数组
  int b[];             // 若没有初始值列表就会报错
  ```

  ​