## 第三章 字符串、向量和数组

### 3.1 命名空间using的声明

- 操作符 :: 的意思是：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。
- std::cin 的意思是使用命名空间 std 中的名字 cin 。
- 上面这种方法比较麻烦，每次要使用 cin 的时候都要使用 std:: ，因此可以使用 using 声明
- 格式：`using namespace::name;`，例如：`using std::cin;`。一旦这样声明了 cin，则之后再使用cin 就不需要每次都加专门的`std::`前缀。
- 每个using声明引入命名空间的一个成员。
- 头文件不应包含 using 声明，因为头文件的内容会被拷贝到所有引用这个头文件的其他文件中，这样可能会对其他文件内容产生冲突。

### 3.2 标准库类型 string

- 范围 for 循环

  ```c++
  std::string s = "hello world!!!";
  for(auto &c: s)
    c = toupper(c);
  std::cout << s << std::endl;
  ```

  ​

### 3.3 标准库类型 vector

- vector 表示对象的集合，其中所有对象的类型相同。
- 引用不是对象，所以不存在包含引用的vector。

#### 3.3.1 定义和初始化 vector 对象

- 列表初始化 

  ``` c++
  vector<string> v1{"a", "an", "the"};
  ```

- 创建指定数量的元素

  ```c++
  vector<int> ivec(10, -1);  // 10 个 int 类型的元素，每个都被初始化为 -1
  vector<string> svec(10, "hi"); // 10 个 string 类型的元素，每个都被初始化为 "hi"
  ```

- 值初始化

  ```c++
  vector<int> ivec(10); // 10 个元素，每个都初始化为 0
  vector<string> svec(10) // 10 个元素，每个都被初始化为空 string 对象
  ```


- 一般来说用圆括号()，可以说提供的值是用来构造vector对象的，而花括号{}是用来列表初始化vector对象的，但也有特例：如果使用了花括号的形式，但括号里提供的值又不能用来列表初始化，那就要考虑是用这样的值来构造vector对象了。

  ```c++
  // 如果列表初始化一个含有string对象的vector对象，应该提供能赋值给string对象的初值。
  vector<string> v1{10}; //v1 有10个默认初始化的值
  vector<string> v2{10, "hi"}; // v2 有10个值为”hi“的元素
  vector<string> v3(10, "hi"); // 这才是常规的构造vector的表达
  ```

  ​

#### 3.3.2 向 vector 对象中添加元素

- 用 vector 的成员函数 push_back 向一个事先创建好的 vector 对象中添加元素，添加到 vector 的尾端。

  ```c++
  vector<int> v;
  for(int i = 0; i <= 100; i++)
  	v.push_back(i);
  ```

- 不能使用下标形式添加元素，vector 对象（以及 string 对象）的下标运算可用于访问已存在的元素，而不能用于添加元素。

- 再次强调，只能对确知已存在的元素执行下标操作！确保下标合法的一种有效的手段是尽可能的使用范围 for 循环语句。

- 但是，如果某个下标对应的对象值已经存在，则可以用下标形式来修改其值，因为修改值而不是新添加一个对象到 vector 中，若想新添加一个元素到 vector 中，就需要使用push_back。

  ```c++
  vector<int> v2(10,0);
  v2[5] = 100;
  std::cout<< v2[5] << std::endl;
  ```



### 3.4 迭代器介绍

所有标准库容器都可以使用迭代器， 但其中只有少数几种才同时支持下标操作。严格来说，string 对象不属于容器类型，但 string 支持很多与容器类型类似的操作。

#### 3.4.1 使用迭代器

- 有迭代器的类型拥有返回迭代器的成员。比如，这些类型都有名为 begin 和 end 的成员

- - begin ：返回指向第一个元素的迭代器

  - end ：返回指向容器尾元素的下一个位置的迭代器，该迭代器常被成为“尾后迭代器”。

  - 若容器为空的话，begin 和 end 返回的是同一个迭代器。

  - ```c++
    vector<string> v(10, "hi");
    auto a = v.begin();
    auto b = v.end();
    ```

- 迭代器运算符：

  - *iter : 返回迭代器 iter 所指元素的引用
  - iter->mem ：解引用 iter 并获取该元素名为mem的成员，等价于 (*iter).mem
  - ++iter ：令 iter 指示容器的下一个元素
  - --iter ：令 iter 指示容器的上一个元素
  - iter1 == iter2 ：判断两个迭代器是否相等，如果两个迭代器指示的是同一个元素或它们是同一个容器的尾后迭代器，则相等；反之，不相等。 

- 将迭代器从一个元素移动到另一个元素。要注意的是：end 返回的迭代器并不实际指向某个元素，因此不能对其进行递增或解引用。

- 迭代器类型：用 iterator 和 const_iterator 来表达迭代器的类型:

  ```c++
  // it 能读写vector<int>的元素
  vector<int>::iterator it;
  // it2 能读写string对象中的字符
  string::iterator it2;

  // it3 只能读元素，不能写元素
  vector<int>::const_iterator it3;
  // it4 只能读字符，不能写字符
  string::const_iterator it4;
  ```

  其中const_iterator 和常量指针差不多，能读取但不能修改它所指的元素值；而 iterator 既能读又能写。如果对象只需要读操作无须写操作的话最好使用常量类型。

  ```c++
  const vector<int> cv;
  auto it5 = cv.begin(); // 这里it5的类型是vector<int>::const_iterator
  ```

  ​

- C++11新标准：引入了两个新的函数：cbegin 和 cend，和原来两个函数的区别如下：也就是说无论vector 对象本身是否是常量，这两个新函数的返回值都是 const_iterator。

  ```c++
  vector<int> v2;
  auto it1 = v2.begin(); 	// it1 的类型是 vector<int>::iterator
  auto it2 = v2.cbegin();	// it2 的类型是 vector<int>::const_iterator
  ```

- 结合解引用和成员访问操作

  ```
  (*it).empty() //解引用it，然后调用结果对象的 empty 成员
  *it.empty()   //错误用法，先调用 it 的 empty 成员，但 it 是个迭代器，没有 empty 成员
  (*it).empty() 有个简化用法 ：it->empty()
  ```

- 但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素

### 3.5 数组

- 数组是存放类型相同的对象的容器，但数组大小固定不变，不能随意向数组中添加元素。

#### 3.5.1 定义和初始化内置数组

- 数组的声明形式为：类型 a[d]，a 是数组的名字，d 是数组的维度，维度说明了数组中元素的个数，所以必须大于0。维度在编译时应该是已知的，也就是说维度必须是一个常量表达式。

  ```c++
  // 书中说这种方式是不允许的，书中认为 cnt 不是一个常量表达式，
  // 但是我执行下边这种方式时，编译器并未报错。
  // 但我觉得书中的“要用常量表达式来定义数组”确实会严谨一些
  unsigned cnt = 42;
  string bad[cnt];
  // 严谨的做法
  constexpr unsigned sz = 42;
  string good[sz];
  ```

- 定义数组时要指明数组的类型，不允许使用 auto 关键字由初始值列表来推断类型。

- 与 vector 一样，数组的元素必须为对象，所以不能存放引用。

- 数组在定义时可以忽略维度，编译器会根据初始值的数量计算并推测出维度。若只是不带初始值时忽略维度值，就会报错（毕竟编译器不会凭空计算并推测维度值）。

  ```c++
  int a[] = {0, 1, 2}; // 维度为3的数组
  int b[];             // 若没有初始值列表就会报错
  ```

- 字符数组还可以用字符串字面值来初始化，不过要注意的是字符串字面值结尾处还有一个空字符，这个空字符也会像其他字符一样被拷贝到字符数组中。` char a[6]="daniel";`这种初始化是错误的因为字符数组大小必须至少为7，前6个放字面值，另一个存放结尾处的空字符。

- 不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。

- 复杂数组的声明

  - `int *ptrs[10];`  ptrs 是含有 10 个整型指针的数组。默认情况下，类型修饰符从右向左依次绑定，对于 ptrs 来说，首先定义一个大小为 10 的数组，然后里面存放的是指向 int 型的指针。

  - `int &refs[10] = /* ? */;  `  错误！不存在引用的数组

  - `int (*parray)[10] = &arr;`  parray 指向一个含有 10 个整数的数组。对于 parray 从右向左理解就不合理了，需要从内向外阅读，先看圆括号部分：*parray 说明 parray 是个指针，再看右边：说明 parray 指向大小为 10 的数组，最后看左边：知道数组中的元素为 int 型。

  - `int (&arrref)[10] = arr;`  arrref 引用一个含有 10  个整数的数组。arrref 也可以用由内向外来理解，首先知道 arrref 是一个引用，然后知道 arrref 引用的对象是一个大小为 10 的数组，最后知道数组的类型是 int 型。

  - `int *(&array)[10] = ptrs;`  array 是一个数组的引用，该数组含有 10 个指针。

#### 3.5.2 访问数组元素

- 数组的下标通常定义为 size_t 类型。
- 在使用数组时，应避免下标越界。

#### 3.5.3 指针和数组

- 在大多数表达式中，使用数组来了类型的对象其实就是使用一个指向该数组首元素的指针。

- 指针也是迭代器

- 在很多用到数组名字的地方，编译器会自动将其替换为一个指向数组首元素的指针:

  ```c++
  string nums[] = {"aasd", "onr", "asd"};
  string *p2 = nums; // 等价于 string *p2; p2 = &nums[0];
  ```

- 标准库函数 begin 和 end ：

  - C++11 新引入了两个名为 begin 和 end 的函数，这两个函数与容器中的两个成员函数功能类似，但数组不是类类型，所以这两个新函数不是成员，因此在使用时应将数组作为它们的参数。

    ```c++
    int a[] = {0, 2, 4, 6, 8};
    int *beg = begin(a);
    int *end = end(a);
    ```

#### 3.5.4  C风格字符串

- C标准库 String 函数

  - strlen(p)：返回 p 的长度

  - strcmp(p1, p2)：比较 p1 和 p2 的相等性

  - strcat(p1, p2)：将 p2 附加到 p1 之后，返回 p1

  - strcpy(p1, p2)：将 p2 拷贝给 p1 （将 p1 完全覆盖），返回 p1

  - 上述函数必须传入以空字符作为结束的数组

    ```c++
    // 错误示例
    char ca[] = {'c', '+', '+'};
    cout << strlen(ca) << endl;
    ```

- 虽然不能用数组初始化数组，也不能用vector初始化数组，但可以使用数组初始化vector：

  ```c++
  int int_arr[] = {0, 1, 2, 3, 4, 5, 6};
  // ivec 中会有7个元素，分别是 int_arr 中对用元素的副本
  vector<int> ivec(begin(int_arr), end(int_arr));
  // ivec 有三个元素 int_arr[1]、 int_arr[2]、 int_arr[3]
  vector<int> subvec(int_arr+1, int_arr+4);

  ```

### 3.6 多维数组

- 严格来说，C++语言中没有多维数组，有的只是数组的数组。

- 当一个数组的元素仍是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另一个维度标示其元素（也是数组）的大小。

- 多维数组的初始化

  ```c++
  int ia[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11}
  };
  // 效果和上一个初始化方式一样
  int ia1[3][4] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
  // 显示的初始化每行首元素
  int ia2[3][4] = {{0}, {4}, {8}};
  // 显示的初始化第一行元素，其他元素执行默认值初始化
  int ia3[3][4] = {0, 1, 2, 3};
  ```

- 使用范围for语句来遍历二维数组如下：第二个 for 循环中的引用（&col）是用来更新数组中的值，如果不用引用，则无法更改值；第一个 for 循环中的引用（&row）是必须的，这是为了避免数组被自动转换成指针。

  ```c++
  size_t cnt = 0;
  for(auto &row : ia){
    for (auto &col : row){   
      col = cnt;
      cnt++;
    }
  }
  ```

  若像下边这样执行代码，就会报错：因为在执行第一层 for 循环时，遍历 ia 的所有元素，而这些元素都是大小为4的数组，并且 row 不是引用，编译器初始化 row 时会自动将这些数组形式的元素转换成指向该数组内首元素的指针。这样得到的 row 其实是 *int 型，显然内层 for 循环就无法执行了。

  ```c++
  for(auto row : ia){
    for (auto col : row){
  	/*code*/    
    }
  }
  ```

- 因此要使用范围 for 语句处理多维数组，除了最内层 for 循环外，其他所有循环的控制变量都应该是引用类型。