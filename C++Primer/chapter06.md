## 第六章 函数

### 6.1 函数基础

- 名字的作用域是程序文本的一部分，名字在其中可见。
- 对象的生命周期是程序执行过程中该对象存在的一段时间。

### 6.2 参数传递

- **传值参数：**函数对形参所做的所有操作都不会影响实参。

- **指针形参：**当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。

- **传引用参数：**对于引用的操作实际上是作用在引用所引的对象上。

- **使用引用形参可以返回额外的值：**因为一个函数只能返回一个值，如果想返回多个值可以在函数的形参中加一个引用，在函数中修改引用的值，这样在函数执行完之后，引用所引的值也会被改变，这样就得到了想要的额外值。

- **`const`：**`int * const p = &i; ` `const`是顶层的不能给`p`赋值，但可以通过`p`改变对象的内容:`*p = 0;`；`const int *p = &i;`，这里的`p`不能改变`i` 。

  ```c++
  int i =18;
  // 正常运行
  // 打印的结果是：1
  int * const pp = &i;
  *pp = 1;
  cout << i << endl;

  // 会报错:*p 是只读的，不能写。
  // panta@panta-PC:~/Desktop$ g++ test.cpp 
  // test.cpp: In function ‘int main()’:
  // test.cpp:19:7: error: assignment of read-only location ‘* p’
  // *p = 0;
  //      ^
  const int *p = &i;
  *p = 0;
  cout << i << endl;}
  ```

  ​

- **数组形参：**当为函数传递一个数组时，实际上传递的是指向数组首元素的指针。可以把数组形参写成类似数组的形式：

  ```c++
  // 三种等价的写法
  void pr(const int*);
  void pr(const int[]);
  void pr(const int[10]);
  ```

- **管理指针形参有三种常用的技术：**

  1. 使用标记指定数组的长度，就是判断指针是否是一个空指针，不是空指针再判断是否是指向空字符。一般用于C风格字符串存储的字符数组。
  2. 使用标准库规范，即将指向数组首元素和尾后元素的指针传到函数中。
  3. 显示的传递一个表示数组大小的形参。

### 6.3 返回类型和return语句

- **值是如何被返回的：**返回的值用于初始化调用点的一个临时量，该临时量是函数调用的结果。

- **不要返回局部对象的引用或指针：**因为函数完成后，局部对象所占的存储空间也随之被释放，函数终止意味着局部变量的引用将指向不再有效的内存区域；同样指向局部对象的指针也将指向一个不存在的对象。

#### 6.3.3 返回数组指针：

-  返回数组指针的函数形式如下: `Type (*function(parameter_list))[dimension]`，例如` int (*func(int i))[10];`
  - `func(int i)`：表示调用`func`函数时需要一个`int`类型的实参。
  - `(*func(int i))`：意味着可以对函数调用的结果解引用。
  - `(*func(int i))[10]`：解引用将得到一个大小为`10`的数组。
  - `int (*func(int i))[10]` ：表示数组中的元素是`int`类型的。


- **使用尾置返回类型：**在C++11新标准中有一种简化上述`func`声明的方法，即尾置返回类型。格式如下：`auto func(int i)->int(*)[10];`。将函数的返回类型放在了形参列表之后就可以清楚的看到函数返回的是一个指针，并且该指针指向了含有`10`个整数的数组。任何函数的定义都可以使用尾置返回。

### 6.4 函数重载

- 如果同一作用域内的几个函数的名字相同但形参列表不同，就称之为重载（overload）。

- 当调用函数时，编译器会根据形参的类型来推断想要的是哪个函数。

- `main`函数不能重载。

- 如果只是返回类型不同，而其他要素都相同，这种声明是错误的。

- **重载和`const`形参：**

  - 一个拥有顶层`const`的形参无法和另一个没有顶层`const`的形参区分开来：

  ```c++
  // 下边的两个声明是重复分
  // 编译报错：
  /*
  test.cpp: In function ‘int loo(int)’:
  test.cpp:29:5: error: redefinition of ‘int loo(int)’
   int loo(const int i){
       ^~~
  */
  int loo(int);
  int loo(const int);
  int main(){
  	int i =18;
  	const int j = 20;
  	
  	int a = loo(i);
  	int b = loo(j);
  	
  	return 0;
  }
  int loo(int i){
  	return i;
  }
  int loo(const int i){
  	return i;
  }
  ```

  - 但是如果形参是某种类型的引用或指针，则通过区分指向的对象是常量还是非常量对象可以实现函数重载：

  ```c++
  int foo(int &i);       // 函数作用于i的引用
  int foo(const int &i); // 新函数，作用于常量引用
  int main()
  {
  	int i =18;
  	const int &j = i;
  	int a = foo(i);
  	int b = foo(j);
  	
  	return 0;
  }
  int foo(int &i){
  	return i;
  }
  int foo(const int &i){
  	return i;
  }
  ```

#### 6.4.1 重载与作用域

- 如果在内层作用于声明名字，它将隐藏外层作用域中声明的同名实体。在不同作用域中无法重载函数名：

  ```c++
  string read();
  int main(){
    bool read = false; // 新作用域：相当于将外面的read()函数屏蔽了
    string a = read(); // 错误，read是一个布尔值，而非函数。
    return 0;
  }
  ```

### 6.5 特殊用途语言特性

#### 6.5.1 默认实参

- 一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。（所以默认实参一般放在参数列表末尾）
- **使用默认实参：** 要想使用默认实参，只要在调用函数的时候省略该实参就可以了。函数调用时实参按其位置解析，默认实参负责填补函数缺少的尾部实参。
- **默认实参声明：**在声明函数时，一般将其放在头文件中，并且一个函数只声明一次，但多次声明也是合法的。在给定的作用域中一个形参只能被赋予一次默认实参。可以通过多次声明给没有默认实参的形参赋值，但不能多次声明给已经有默认实参的形参再次赋予默认实参。
- 局部变量不能作为默认实参。在声明函数外的变量可以作为默认实参。

#### 6.5.2 内联函数和`constexpr`函数

- **内联函数可以避免函数调用的开销** 函数指定为内联函数通常就是将它在每个调用点上“内联地”展开。

- **格式：**在函数的返回类型前面加上关键字`inline`，就可以将该函数声明成内联函数了。

  ```c++
  inline const string &shorterString(const string &s1, const string &s2){
  	return s1.size() <= s2.size() ? s1 : s2;
  }
  int main()
  {
  	const string &s1 = "helloworld!!";
  	const string &s2 = "nihaoshijie!!";
  	std::cout << shorterString(s1, s2);
  	return 0;
  }

  ```

- **`constexpr`**函数：指能用于常量表达式的函数。定义`constexpr`函数要遵循几条约定：

  - 函数的返回类型及所有形参的类型都必须是字面值。
  - 函数体中必须有且有一条`return`语句。
  - `constexpr`函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行，例如空语句、类型别名和`using`语句。

- 内联函数和`constexpr`函数通常定义在头文件中。

### 6.7 函数指针

- 函数指针指向的是函数而非对象。

- 函数的类型由它的返回类型和形参类型共同决定，与函数名无关。

- 要想声明一个指向函数的指针，只需要用函数指针替换函数名即可。

  ```c++
  bool lengthCompare(const string &, const string &);
  // pf是一个指向函数的指针，该函数的参数是两个const string 的引用，返回值是bool类型
  bool (*pf)(const string &, const string &);
  ```

- **使用函数指针**

  - 当把函数名作为一个值使用时，该函数自动地转换成指针：

  ```c++
  pf = lengthCompare;  // pf指向名为 lengthCompare 的函数
  pf = &lengthCompare; // 等价的赋值语句：取地址符是可选的
  ```

  - 还可以直接使用指向函数的指针调用函数，可以不用提前解引用：

  ```c++
  // 三种等价方式
  bool b1 = pf("asd", "sdfsdf");
  bool b2 = (*pf)("asd", "sdfsdf");
  bool b3 = lengthCompare("asd", "sdfsdf");
  ```

  - 在指向不同函数类型的指针之间不存在转换。
  - 但可以给函数指针赋一个空指针或值为`0`的整型常量表达式。

- **重载函数的指针：**编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的一个精确匹配。

- **函数指针形参：**

  - 形参可以是函数指针。可以把函数直接当做实参使用，它会自动转换成指针。

- `auto`和`decltype`可以简化函数指针。