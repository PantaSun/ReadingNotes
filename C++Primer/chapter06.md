## 第六章 函数

### 6.1 函数基础

- 名字的作用域是程序文本的一部分，名字在其中可见。
- 对象的生命周期是程序执行过程中该对象存在的一段时间。

### 6.2 参数传递

- **传值参数：**函数对形参所做的所有操作都不会影响实参。

- **指针形参：**当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。

- **传引用参数：**对于引用的操作实际上是作用在引用所引的对象上。

- **使用引用形参可以返回额外的值：**因为一个函数只能返回一个值，如果想返回多个值可以在函数的形参中加一个引用，在函数中修改引用的值，这样在函数执行完之后，引用所引的值也会被改变，这样就得到了想要的额外值。

- **`const`：**`int * const p = &i; ` `const`是顶层的不能给`p`赋值，但可以通过`p`改变对象的内容:`*p = 0;`；`const int *p = &i;`，这里的`p`不能改变`i` 。

  ```c++
  int i =18;
  // 正常运行
  // 打印的结果是：1
  int * const pp = &i;
  *pp = 1;
  cout << i << endl;

  // 会报错:*p 是只读的，不能写。
  // panta@panta-PC:~/Desktop$ g++ test.cpp 
  // test.cpp: In function ‘int main()’:
  // test.cpp:19:7: error: assignment of read-only location ‘* p’
  // *p = 0;
  //      ^
  const int *p = &i;
  *p = 0;
  cout << i << endl;}
  ```

  ​

- **数组形参：**当为函数传递一个数组时，实际上传递的是指向数组首元素的指针。可以把数组形参写成类似数组的形式：

  ```c++
  // 三种等价的写法
  void pr(const int*);
  void pr(const int[]);
  void pr(const int[10]);
  ```

- **管理指针形参有三种常用的技术：**

  1. 使用标记指定数组的长度，就是判断指针是否是一个空指针，不是空指针再判断是否是指向空字符。一般用于C风格字符串存储的字符数组。
  2. 使用标准库规范，即将指向数组首元素和尾后元素的指针传到函数中。
  3. 显示的传递一个表示数组大小的形参。

### 6.3 返回类型和return语句

- **值是如何被返回的：**返回的值用于初始化调用点的一个临时量，该临时量是函数调用的结果。

- **不要返回局部对象的引用或指针：**因为函数完成后，局部对象所占的存储空间也随之被释放，函数终止意味着局部变量的引用将指向不再有效的内存区域；同样指向局部对象的指针也将指向一个不存在的对象。

#### 6.3.3 返回数组指针：

-  返回数组指针的函数形式如下: `Type (*function(parameter_list))[dimension]`，例如` int (*func(int i))[10];`
  - `func(int i)`：表示调用`func`函数时需要一个`int`类型的实参。
  - `(*func(int i))`：意味着可以对函数调用的结果解引用。
  - `(*func(int i))[10]`：解引用将得到一个大小为`10`的数组。
  - `int (*func(int i))[10]` ：表示数组中的元素是`int`类型的。


- **使用尾置返回类型：**在C++11新标准中有一种简化上述`func`声明的方法，即尾置返回类型。格式如下：`auto func(int i)->int(*)[10];`。将函数的返回类型放在了形参列表之后就可以清楚的看到函数返回的是一个指针，并且该指针指向了含有`10`个整数的数组。任何函数的定义都可以使用尾置返回。

### 6.4 函数重载

- 如果同一作用域内的几个函数的名字相同但形参列表不同，就称之为重载（overload）。

- 当调用函数时，编译器会根据形参的类型来推断想要的是哪个函数。

- `main`函数不能重载。

- 如果只是返回类型不同，而其他要素都相同，这种声明是错误的。

- **重载和`const`形参：**

  - 一个拥有顶层`const`的形参无法和另一个没有顶层`const`的形参区分开来：

  ```c++
  // 下边的两个声明是重复分
  // 编译报错：
  /*
  test.cpp: In function ‘int loo(int)’:
  test.cpp:29:5: error: redefinition of ‘int loo(int)’
   int loo(const int i){
       ^~~
  */
  int loo(int);
  int loo(const int);
  int main(){
  	int i =18;
  	const int j = 20
  	
  	int a = loo(i);
  	int b = loo(j);
  	
  	return 0;
  }
  int loo(int i){
  	return i;
  }
  int loo(const int i){
  	return i;
  }
  ```

  - 但是如果形参是某种类型的引用或指针，则通过区分指向的对象是常量还是非常量对象可以实现函数重载。