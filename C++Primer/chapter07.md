## 第七章 类

- 类的基本思想**数据抽象**和**封装**
  - 数据抽象：是一种依赖于接口和实现分离的编程技术。
  - 封装：实现了类的接口和实现的分离。
- 类想要实现数据抽象和封装，首先要定义一个抽象数据类型。

### 7.1 定义抽象数据类型

- 抽象数据类型：可以通过接口使用这个对象，但不能直接访问该对象的数据成员。一个普通的结构体不是一个抽象数据类型，因为它允许类的用户直接访问它的数据成员，并且要求有用户来编写操作。要想把一个普通的结构体变为抽象数据类型，就 需要定义一些操作以供类的用户使用，一旦定义了操作，就可以封装结构体的数据成员了。

#### 7.1.2 定义改进的Salas_data类

- 成员函数的定义必须在类的内部，它的定义则既可以在在类的内部，也可以在类的外部。

  ```c++
  struct Sales_data{
    // 关于Sales_data对象的操作
    std::string isbn() const { return bookNo; }	// 定义在类内
    Sales_data &combins(const Sales_data); 		// 定义在类外
    double avg_price() const;                 	// 定义在类外
    // 数据成员
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
  };
  ```

- 引入`this`：当调用成员函数时，实际上实在替某个对象调用它。

  ```c++
  Sales_data total;
  total.isbn();
  ```

  - 这里当`isbn`返回`bookNo`时，实际上它隐式的返回`total.bookNo`。
  - 成员函数通过`this`这个额外的隐式参数来访问调用它的对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化`this`。
  - `this`的类型在默认情况是指向类类型非常量版本的常量指针。

- `const`：

  - 在`isbn`函数参数列表后面的`const`关键字的作用是修改隐式`this`指针的类型。
  - 由上述代码可知`isbn`是一个常量成员，因此该函数中的隐式`this`是指向常量的指针，所以常量成员函数不能修改调用它的对象的内容。也就是`isbn`可以读取调用它的对象的数据成员，但不能写入新值。
  - `isbn`函数表达的意思如下：但这只是伪码，因为不能显示的定义自己的`this`指针。

  ```c++
  std::string Sales_data::isbn(const Sales_data *const){return this->isbn;}
  ```

  - 常量对象，以及常量对象的引用或指针都只能调用常量成员函数。不能在一个常量对象上调用普通的成员函数。

- 类作用域和成员函数

  - 类本身就是一个作用域。
  - 当在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。

#### 7.1.3 定义类相关的非成员函数

- 有些接口函数的操作从概念上来说属于类的接口的组成部分，但他们实际上不属于类本身。一般来说这些属于接口部分的非成员函数的声明要和类放在同一个头文件内。

#### 7.1.4 构造函数

