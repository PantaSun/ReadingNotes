## 第十四章：操作重载与类型转换

- 当操作符被用于；类类型的对象时，C++语言允许我们为其指定新的含义。

### 基本概念

- 除了重载的函数调用运算符operator() 之外，其他重载运算符不能含有默认参数。
- 当一个重载运算符是类成员函数时，它的第一个运算对象（左侧）绑定到隐式的this指针上，因此成员运算符函数的显示参数比运算对象的数量少一个。
- 重载运算要么是类的成员，要么至少含有一个类类型的参数
- 不能为int等内置类型重定义运算符。
- 只能重载已有的运算符，不能创造运算符。
- 一个重载运算符的计算优先级和结合律与对应内置的运算符保持一致。
- 重载运算符可以像普通运算符那样使用（如：类A + 类B）也可以像普通函数那样使用（如：operator+(类A, 类B)；）。
- 一般情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符，因为上述运算符的重载版本无法保留求值顺序和/或短路求值属性（逗号和取地址除外，这两种运算符已经定义了用于类类型对象时的特殊含义）。

#### 关于是否定义为成员函数

- 赋值=、下标[]、调用()和成员访问箭头->运算符必须是成员
- 复合赋值运算符（如 += ，-=这种就是复合运算符）一般来说是成员，但并非必须。
- 改变对象状态的运算符或与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常是成员
- 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算等，通常应该是普通的非成员函数。



### 输入和输出运算符

#### 重载输出运算符<<

一般情况下，输出运算符的重载有两个参数：

- 参数一是非常量ostream对象的引用：非常量是因为向流写入数据会改变其状态；引用是因为无法直接复制一个ostream对象。
- 参数二是要打印的常量对象：常量的原因是打印不改变对象的内容。

而且operator<<一般要返回它的ostream形参。

例子：

```c++
ostream &operator<<(ostream &os, const A &item){
    os << A.getData1() << " " << A.getData2();
    return os;
}
```

##### 输出运算符尽量减少格式化操作

- 通常输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。

##### 输入输出运算符必须是非成员函数

若写成成员函数，则左边的运算对象就是自定义的那个类了，但是左边的对象也必须是istream或ostream的成员。然而这两个类属于标准库，并且无法给标准库中的类添加成员函数。

#### 重载输入运算符 >>

参数：

- 参数一是要读取的流的引用
- 参数二是非常量要读入到的对象的引用

输入运算符必须要处理输入可能失败的情况，而输出运算符不需要。

当读取操作发生错误时，输入运算符应该负责从错误中恢复。

### 算术和关系运算符 + - * / && ||

定义为非成员函数以便于左右运算对象可以进行转换。又因为这些运算符一般不改变运算对象的状态，所以形参都是常量的引用。

如果类同时定义了算术运算符和复合赋值运算符，则应该用复合赋值运算符来定义算术运算符。

如果存在唯一一种逻辑可靠的<定义，则应该考虑为这个类定义<运算符。如果类同时还包含==，则当且仅当<的定义和==的结果一致时才定义<运算符。

### 赋值运算符 =

不论形参的类型是什么，赋值运算符都必须定义为成员函数。

和拷贝复制以及移动赋值运算符一样，其他重载的赋值运算符也必须先释放当前内存空间，再创一片新空间。

### 下标运算符 [ ]

- 下标运算符必须是成员函数

- 下标运算符最好同时定义常量和非常量版本，当作用与一个常量对象时，下标运算符返回常量引用以确保不会给返回的对象赋值。

### 递增和递减运算符 ++  --

- 定义递增和递减运算符的类应同时定义前置和后置版本的。这些运算符通常应该定义为类的成员。
- 为了与内置版本一致，前置运算符应该返回递增或递减后对象的引用；而后置运算符应返回对象的原值（递增或递减之前的值），且返回的形式是一个值而非引用。
- 为了区分前置和后置版本的递增或递减运算符，后置版本的运算符重载需要接收一个int型参数作为区分，这个int参数不被使用。

### 成员访问运算符 ->

箭头运算符必须是成员函数，解引用运算符通常也是成员函数，但非必须。

关于箭头运算符重载可以改变从哪个对象中获取成员，但不能改变获取成员这一事实，它永远不能丢掉访问成员这个最基本的含义。

对于形如point->mem的表达式来说：

- 当point是指针，则表达式等价于（*point）.mem
- 当point是定义了operator->的类的一个对象，则使用point.operator->()的结果来获取mem
- 除上述两种情况的point外，这种表达式都会报错，即point必须是一个指向类对象的指针或一个重载了operator->的类的对象。

### 函数调用运算符（）

如果类重载了函数调用运算符，则可以像使用函数一样使用该类的对象。

函数调用运算符必须是成员函数。

一个类可以定义多个不同版本的调用运算符，相互之间的区在于参数数量或参数类型上。

如果类定义了调用运算符，则该类的对象称为函数对象，lambda是函数对象

#### 可调用对象与function

C++语言中有几种可调用对象：

- 函数
- 函数指针
- lambda表达式
- bind创建的对象
- 重载了调用运算符的类

不同类型的可调用对象可能共享同一种调用形式

#### 标准库function类型

function是一个模板，当创建一个function类型时需要提供额外信息。这里假设额外信息时指function类型能够表示的对象的调用形式

不能将重载函数的名字（指存在二义性的函数名）直接存入function类型的对象中

### 重载、类型转换与运算符

#### 类型转换运算符

是类的一种特殊成员函数，它负责将一个类类型的值转换为其它类型。`operatot typ() const;` type表示某种类型。类型转换运算符可以面向任意类型，除了void，只要该类型能作为函数的返回类型，所以不允许转换成数组或则函数类型，但允许转换成指针（包括函数指针和数组指针）或引用类型。



#### 显示的类型转换运算符

` explicit operator type（）const；` 通过explicit关键字进行声明，编译器就不会隐式的进行类型转换了。

当表达式被用作条件时，编译器会将显示的类型转换自动应用于它，即显示的类型转换会被隐式的执行，条件是指：

- if、while及do语句的条件部分
- for语句中的条件表达式
- 逻辑与或非运算对象
- 条件运算符（? : ）中的条件部分

##### 要避免有二义性的类型转换：通常不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标试算术类型的转换。

避免让重载函数的参数可以使用构造函数或强制类型转换来改变实参的类型。

表达式中运算符的候选函数集既包括成员函数也包括非成员函数。

如果对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。

