## 第十五章：面向对象程序设计

三个基本概念：数据抽象、继承和动态绑定

### 继承

在C++中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。

对于基类希望派生类各自定义适合自身的版本的函数，基类会使用关键字virtual声明为虚函数。

派生类必须使用类派生列表表明是从哪个（哪些）类型继承来的。

类派生列表是由冒号开始，后面紧跟着以逗号分隔的基类列表。每个基类前还有访问修饰符

派生类必须在其内部对所有重新定义的虚函数进行声明。

#### 动态绑定

可以使用同一段代码分别处理基类和派生类的对象。

动态绑定又称为运行时绑定

通过对象来调用函数就是普通的静待绑定。

动态绑定的三个条件：

- 函数调用者是一个对象的指针或引用
- 该指针向上转型，就是针指声明时是指向基类的，但在定义时可以使用派生类
- 调用的是虚函数
- 总结：在C++中，当使用基类的引用或指针调用一个虚函数时将发生动态绑定

### 基类与派生类

#### 定义基类

基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作。

##### 成员函数与继承

基类的成员函数分为两类：

- 基类希望派生类进行覆盖的函数，通常定义为虚函数。这类函数在运行时选择版本（基类版还是派生类版）。
- 基类希望派生类直接继承不要改变的函数。这类函数的解析发生在编译时，而非运行时。

基类通过在成员函数声明语句之前加关键字virtual使该函数执行动态绑定。virtual只能对类内成员函数使用，不能对类外函数使用。

任何构造函数之外的非静态函数都可以是虚函数。

##### 访问控制与继承

访问控制符：

- public：派生类可以访问，类外其他用户也可以访问
- private：只有自己类内可访问
- protected：派生类可以访问，其他用户禁止访问

#### 定义派生类

类派生列表中的访问说明符是控制从基类继承来的成员是否对派生类的用户可见。

##### 派生类构造函数

尽管在派生类对象中含有从基类继承来的成员，但派生类不能直接初始化这些成员，必须使用基类的构造函数初始化它们。

先初始化基类然后按照声明的顺序依次初始化派生类成员。

##### 静态成员

若基类中定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。静态成员遵循访问控制。

若某个类要被作为基类，则该类必须要已经定义。

关键字final可以防止被继承。

#### 类型转换与继承

可以将基类的指针或引用绑定到派生类对象上。 这里的深层含义是：当使用基类的引用或指针时，实际上不清楚引用或指针所绑定的对象的真是类型，可能是基类也可能是派生类。

不存在从基类向派生类的隐式类型转换。

当使用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，派生类自己的成员部分会被忽略。

### 虚函数

##### 派生类中的虚函数

当在派生类中覆盖某个虚函数时，可以再一次使用virtual关键字指出该函数的性质，但这不是必须的，因为一旦某个函数被声明成虚函数，则在其所有派生类中它都是虚函数。

派生类经常覆盖（但不总是）它继承的虚函数。若派生类没有覆盖其继承的基类中某个虚函数，则该虚函数的行为和其他非虚函数一样会被派生类直接继承到派生类中，即派生类会直接继承其在基类中的版本。

派生类的函数如果覆盖了从基类继承来的虚函数，则它的参数类型与被覆盖的基类函数完全一致。而返回类型也必须与基类函数匹配，只有在返回类型是类本身的指针或引用时这条规则无效。

C++11中使用override关键字修饰派生类中想要覆盖基类虚函数的函数，这个关键字可以让编译器对覆盖函数进行检查，看参数列表等是否一致。override放在函数参数列表括号以及尾置返回类型的后面。

不使用override也可以覆盖基类虚函数，只不过编译器不负责帮你检查是否覆盖成功。因为若派生类中覆盖函数的参数列表与基类虚函数参数列表不一致，则编译器是不会报错的，它只是把这两个函数看出独立的两个函数，这在语法上没有错误，但逻辑上显然是错误的（除非真的需要这种情况）。

非虚函数不能使用override。

还可以把函数指定为final，则之后任何尝试覆盖该函数的操作都会报错。