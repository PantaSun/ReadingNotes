## 第十五章：面向对象程序设计

三个基本概念：数据抽象、继承和动态绑定

### 继承

在C++中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。

对于基类希望派生类各自定义适合自身的版本的函数，基类会使用关键字virtual声明为虚函数。

派生类必须使用类派生列表表明是从哪个（哪些）类型继承来的。

类派生列表是由冒号开始，后面紧跟着以逗号分隔的基类列表。每个基类前还有访问修饰符

派生类必须在其内部对所有重新定义的虚函数进行声明。

#### 两个重要概念

- 静态类型：在编译时就已经确定了，它是变量声明时的类型或表达式生成的类型
- 动态类型：是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才能确定。

#### 动态绑定

可以使用同一段代码分别处理基类和派生类的对象。

动态绑定又称为运行时绑定

通过对象来调用函数就是普通的静待绑定。

动态绑定的三个条件：

- 函数调用者是一个对象的指针或引用
- 该指针向上转型，就是针指声明时是指向基类的，但在定义时可以使用派生类
- 调用的是虚函数
- 总结：在C++中，当使用基类的引用或指针调用一个虚函数时将发生动态绑定

### 基类与派生类

#### 定义基类

基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作。

##### 成员函数与继承

基类的成员函数分为两类：

- 基类希望派生类进行覆盖的函数，通常定义为虚函数。这类函数在运行时选择版本（基类版还是派生类版）。
- 基类希望派生类直接继承不要改变的函数。这类函数的解析发生在编译时，而非运行时。

基类通过在成员函数声明语句之前加关键字virtual使该函数执行动态绑定。virtual只能对类内成员函数使用，不能对类外函数使用。

任何构造函数之外的非静态函数都可以是虚函数。

##### 访问控制与继承

访问控制符：

- public：派生类可以访问，类外其他用户也可以访问
- private：只有自己类内可访问
- protected：派生类可以访问，其他用户禁止访问

#### 定义派生类

类派生列表中的访问说明符是控制从基类继承来的成员是否对派生类的用户可见。

##### 派生类构造函数

尽管在派生类对象中含有从基类继承来的成员，但派生类不能直接初始化这些成员，必须使用基类的构造函数初始化它们。

先初始化基类然后按照声明的顺序依次初始化派生类成员。

##### 静态成员

若基类中定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。静态成员遵循访问控制。

若某个类要被作为基类，则该类必须要已经定义。

关键字final可以防止被继承。

#### 类型转换与继承

可以将基类的指针或引用绑定到派生类对象上。 这里的深层含义是：当使用基类的引用或指针时，实际上不清楚引用或指针所绑定的对象的真是类型，可能是基类也可能是派生类。

不存在从基类向派生类的隐式类型转换。

当使用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，派生类自己的成员部分会被忽略。

### 虚函数

##### 派生类中的虚函数

当在派生类中覆盖某个虚函数时，可以再一次使用virtual关键字指出该函数的性质，但这不是必须的，因为一旦某个函数被声明成虚函数，则在其所有派生类中它都是虚函数。

派生类经常覆盖（但不总是）它继承的虚函数。若派生类没有覆盖其继承的基类中某个虚函数，则该虚函数的行为和其他非虚函数一样会被派生类直接继承到派生类中，即派生类会直接继承其在基类中的版本。

派生类的函数如果覆盖了从基类继承来的虚函数，则它的参数类型与被覆盖的基类函数完全一致。而返回类型也必须与基类函数匹配，只有在返回类型是类本身的指针或引用时这条规则无效。

C++11中使用override关键字修饰派生类中想要覆盖基类虚函数的函数，这个关键字可以让编译器对覆盖函数进行检查，看参数列表等是否一致。override放在函数参数列表括号以及尾置返回类型的后面。

不使用override也可以覆盖基类虚函数，只不过编译器不负责帮你检查是否覆盖成功。因为若派生类中覆盖函数的参数列表与基类虚函数参数列表不一致，则编译器是不会报错的，它只是把这两个函数看出独立的两个函数，这在语法上没有错误，但逻辑上显然是错误的（除非真的需要这种情况）。

非虚函数不能使用override。

还可以把函数指定为final，则之后任何尝试覆盖该函数的操作都会报错。

##### 虚函数默认实参

虚函数默认实参由本次调用的静态类型决定，所以一个指向基类的指针或引用即使在实际运行中使用的时派生类版本的函数，其默认实参也是基类中定义的默认实参。

##### 回避虚函数

可以强迫执行虚函数的某个版本，假设A是基类，B是A的派生类，A和B中虚函数C

```c++
class A{
  public:
    virtual void C(){...}
};
class B: public A{
  public:
    virtual void C() override {...}
};
B b;
A *a = &b;
a->A::C(); // 强行使用A中定义的虚函数版本
```

### 抽象基类

##### 纯虚函数

有时候基类中的虚函数没有实际意义只有在派生类中覆盖后才有具体意义，这种虚函数在基类中可以不定义。

格式是在函数体的位置写 `=0`，这种写法只能出现在类内部的虚函数声明出。

含有纯虚函数的类是抽象基类，不能（直接）创建抽象基类的对象。如果派生类继承抽象基类后不对纯虚函数进行定义，那么这个派生类仍是它自己派生类的抽象基类，因此也不能创建对象。

派生类构造函数之初始化它的直接基类

### 访问控制与继承

##### 受保护的成员：用protected关键字声明的

- 受保护的成员对于类的用户来说是不可访问的
- 对于派生类的成员和友元来说是可访问的。
- 派生类的成员或友元只能通过派生类对象来访问基类受保护的成员（其实是派生类中继承的）。派生类对于一个基类对象中的受保护成员没有任何访问特权。这里的意思是由于派生类的友元或成员可以访问自己类中的任意成员，而这个任意成员包括两部分，一部分是继承自基类的，一部分是自己内部声明的。所以派生类的成员或友元可以访问派生类中从基类中继承来的成员部分，但是无权直接访问基类对象中受保护部分。
- 这里受保护的意思其实就是允许派生类继承或友元调用，而不允许该类对象直接调用。而派生类中的所谓可以访问，其实是访问派生类中继承自基类的成员，但只要继承过来了，这部分成员本身就属于派生类了，只不过初始化方式要按照基类里规定的方式来，既然属于派生类了，那派生类中其它成员肯定就有权访问了。而派生类的用户是可能有访问权，这里可能的原因是还要看派生访问说明符。

##### 公有、私有和受保护继承

某个派生类对于继承来的成员的访问权受两个因素影响：

- 一是基类中该成员的访问说明符，就是上述部分说明的
- 二是派生类的派生列表中的访问说明符，
- 补充：
  - 派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关
  - 派生访问说明符的目的是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限。

##### 理解

首先，访问权的来源有两个：

- 一是派生类的内部成员（派生类自己声明的那部分）：派生类的内部成员对于继承自基类的成员的访问权只受基类中成员的访问说明符影响。
- 二是派生类用户（就是由派生类建立的对象或派生类的派生类）：这部分用户受派生访问符的影响，也就是说这个派生访问符会改变基类成员在派生类中的访问说明符，比如说基类中某个成员A是public的，但是派生类在继承时派生访问说明符是private，那么派生类中的继承自基类的成员A现在就是private的了，也就是说只有派生类内部成员（及友元）才有权访问，而其他用户无权访问了。
- 访问权限是由优先级的 从低到高 public、protected、private，也就说
  - 派生访问说明符是public时，不会改变派生类中继承自基类的成员原有的访问权限，
  - 派生访问说明符是protected时，派生类中继承自基类的成员原有的public访问权限会变成protected，
  - 派生访问说明符是private时，派生类中继承自基类的成员原有的访问权限都变为private，

##### 友元关系不能继承，每个类负责控制各自成员的访问权限

使用using声明可以改变派生类继承的某个名字的访问级别

例子：

```c++
class Base{
  public:
    std::size_t size()const {return n;}
  protected:
    std::size_t n;
};

class Derived: private Base{  // 这里是private继承
  public:
    using Base::size();
  protected:
    using Base::n;
};
```

上述代码中Derived使用了private继承，所以size和n在默认情况下是Derived的私有成员。但是当使用using声明语句，这两个成员的可访问性发生了改变：Derived的用户可以使用size成员，Derived的派生类将能使用n。

派生类只能为那些他可以访问的名字提供using声明。

##### 默认的继承保护机制

- 使用class关键字定义的派生类是私有继承的
- 使用struct关键字定义的派生类是公有继承的



### 继承中的作用域

派生类作用域嵌套在弃基类的作用域之内。如果一个名字在派生类中无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。

派生类的成员将隐藏同名的基类成员。

可以使用作用域运算符`::`来使用隐藏的成员

除了覆盖继承来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。

##### 名字查找优先于类型检查

定义在内层作用域的函数不会重载定义在外层作用域的函数，因此定义在派生类中的函数不会重载其基类中的同名成员函数。派生类中的成员函数是在其作用域内隐藏掉了基类成员，即使派生类成员的形参与基类成员的形参列表不一致，基类成员也仍然会被隐藏掉。

这也是为什么基类与派生类中虚函数必须有相同的参数列表，因为如果参数列表不同，就无法通过基类的应用或指针调用派生类的虚函数了。

隐藏和覆盖是两个概念，在不同作用域中定义虚函数时用的是覆盖，在不同作用域中进行函数重载时用的是隐藏。

---

### 构造函数与拷贝控制

#### 虚析构函数

在基类中将析构函数定义成虚函数可以确保在delete时调用正确的析构函数版本。

如果基类的析构函数不是虚函数，则delete一个指向派生类的基类指针将产生未定义的行为。

#### 派生类的拷贝控制成员

当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。

默认情况下，基类默认构造函数初始化派生类对象的基类部分。若想拷贝或移动基类部分，则必须在派生类的构造函数初始值列表中显示的使用基类的拷贝或移动构造函数。

派生类的赋值运算符也必须显示的为其基类部分赋值。

##### 在构造函数和析构函数中调用虚函数

如果构造函数和析构函数调用了某个虚函数，则应该执行与构造函数或析构函数所属类型相对应的虚函数版本。

#### 继承的构造函数

C++11中派生类能够重用其直接基类定义的构造函数。

类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成他们。

派生类继承基类构造函数的方式是提供了一条注明基类名的using声明语句。

使用using语句后，基类中的每个构造函数，编译器都会生成一个与之对应的形参列表完全相同的派生类构造函数

形式如下：`derived(parms):base(args){}`derived是派生类名，base是基类名，parms是构造函数的形参列表，args是将派生类构造函数的形参传递给基类构造函数。

构造函数的using声明不会改变构造函数的访问级别。

继承的构造函数不会继承默认实参。

大多数情况派生类会继承所有构造函数（当然前提要使用using进行声明），有两种情况除外：

- 一是派生类自己的构造函数的参数列表和基类某个构造函数参数列表相同，即派生类中的构造函数将替换继承来的构造函数。
- 二是默认、拷贝和移动构造函数不会被继承。

继承的构造函数不会被作为用户定义的构造函数来使用，假设一个类中只含有继承来的构造函数，那么它将拥有一个合成的默认构造函数。

### 容器与继承

容器中不允许存放不同类型的元素，所以不能把具有继承关系的不同类型的对象直接放到容器中。

如果一个容器存放基类类型，当把一个派生类放入该容器中，虽然在语法上不会报错，但此时容器中的派生类对象已经不再是派生类对象了，因为在存放时，只是将派生类中的基类部分存进容器而已，这在逻辑上不是我们最初想要的。

