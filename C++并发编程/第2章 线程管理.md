## 基础

每个程序至少有一个线程，那就是执行main函数的线程。

#### 注意避免“最令人头疼的语法解析”

如果给std::thread 构造函数传递一个临时变量而非命名变量，C++编译器会将其解析为函数声明，而不是类型对象的定义：

```c++
std::thread my_thread(func());
```

上述语句不是一个对象的定义，而是声明了一个函数。这个函数是带有一个参数（函数指针指向没有参数并返回func对象的函数），返回一个std::thread对象的函数。也就是说并没有启动一个线程。

有两种方法可以避免这种问题：

- ```c++
  std::thread my_thread((func())); // 多组括号
  ```

- ```c++
  std::thread my_thread{func()}; // 新统一的初始化语法
  ```

#### 启动线程

在使用std::thread创建对象时，该线程就启动了

#### 等待线程

通过让线程对象调用join()函数，可以确保局部变量在线程完成后，才被销毁。

一个线程只能调用一次join()函数，当调用过join()函数的对象再调用joinable()函数时会返回false

如果线程在启动后，join前抛出异常，那么这次join调用就会被跳过。所以可以使用try-catch 语句或者将线程对象封装到一个类中（使用“资源获取即初始化方式”RAII），在该类的析构函数中调用join，这样就能保证无论如何都会调用join。

#### 后台运行线程

使用detach() 可以让线程在后台运行，即不能与主线程之间直接交互。C++运行库会保证在后台线程退出后，回收相关资源。

分离线程通常称为守护线程

对象调用detach后就无法再调用join了，因为该对象已经与实际执行的线程无关了。



## 向线程函数传递参数

向std::thread的构造函数传递函数以及函数的参数方法就是`std::thread my_thread(func_name, arg1, aeg2, arg3, ...);`

有一个要**注意**的是，该构造函数会将要使用的函数的参数拷贝到独立的线程内存中，即使被使用函数的参数是引用的形式。要想使用引用的形式需要用`std::ref`将参数转换成引用的形式。

