## 共享数据带来的问题

#### 不变量

在这里是指某种对于特殊结构体的描述。这种描述在进行修改数据时保持不变。例如一个双向链表的结点有一个指向前一个结点的指针还有一个指向后一个结点的指针，当对某个结点A进行删除时，则结点A的前结点的指向A的指针和A的后继结点的指向A的指针都要更新。但无法做到同时更新，所以在其中一边完成更新时，这个部变量就遭到破坏，此时不变量处于中间状态，直到另一边也更新完成了，不变量就又恢复稳定。

#### 条件竞争

并发中存在条件竞争：多个线程同时处理同一份数据

恶性竞争：并发中对数据的条件竞争通常表示为恶性条件竞争。通常发生于对多于一个数据块进行修改时。

#### 避免恶性条件竞争

1. 最简单的方法是采用某种保护机制，确保自己有进行修改的线程才能看到不变量的中间状态。因此其他线程只能看到未修改或者已经修改的数据。
2. 采用无锁编程。就是对数据结构和不变量的设计进行修改，修改后的结构必须能完成一系列不可分割的变化，我的理解就是这中不变量不存在中间状态，每次修改都是一步到位。
3. 使用事务的方式处理竞争，即使用事务的方式去处理数据结构的更新。将所需要的数据和处理都存在事务日志中，然后将之前的操作合为一步，再进行提交。
4. 最基本的方式就是使用C++标准库提供的互斥量

## 使用互斥量保护共享数据

将所有访问共享数据的代码都标记为互斥。这时任何一个线程在执行这些代码时，其他任何线程试图访问共享数据就要等待那一段代码执行结束。

互斥量也存在缺点，如可能会造成死锁或者对数据保护的太多。

#### C++中使用互斥量

C++中通过实例化`std::mutex`创建互斥量，通过调用成员函数`lock()`进行上锁，`unlock()`进行解锁。

C++标准库为互斥量提供了一个 RAII 语法的模板类`std::lock_guard`，其在构造函数时会提供已锁的互斥量，在其析构函数会进行解锁。

#### 注意：

不要将受保护的数据的指针或引用传递到互斥锁作用域之外，无论时函数返回值还是存储在外不可见内存，亦或是以函数参数的形式传递到用户提供的函数中。

