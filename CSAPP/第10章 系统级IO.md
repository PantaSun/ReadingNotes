## Unix I/O

在Unix体系下，所有的I/O设备，例如网络、磁盘和终端都被模型化为文件。相应的所有的输入和输出都被当做对文件的读和写来操作。因此所有的输入和输出都有一套同一且一致的执行方式：

- 打开文件：应用程序通过内核打开响应的文件，内核会返回一个小的非负整数，叫做描述符。应用程序后续所有对此文件的操作都可以用这个描述符标识。内核负责记住描述符对应的文件的所有信息。
- Linux shell创建的每个进程开始时都会有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。
- 当前文件位置：对于每一个打开的文件，内核都会记录该文件的当前文件位置k，初始时该值为0。可以通过seek函数来显示的设置k的值。
- 读写文件：读文件就是从文件复制n（n>0）个字节到内存。当文件当前位置k大于等于文件大小时再执行读操作会触发一个end-of-file（EOF）条件，应用程序可以检测到这个条件。文件末尾并没有明确的EOF符号。
- 关闭文件：对文件完成操作后可以通知内核关闭该文件。内核收到通知后会释放记录该文件信息的数据结构，并将这个文件描述符恢复到可用的描述符池中。还有就是一个进程无论因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。

## 文件

每个Linux文件都有一个类型，这个类型可以表明该文件在系统中角色：

- 普通文件：可以包含任意数据。应用程序通常将普通文件分为二进制文件和文本文件这两种。
  - 文本文件只含有ASCII或Unicode字符
  - 二进制文件是所有其他的文件
  - 对于内核来说这两种文件没有区别
- 目录：目录文件中包含一组链接，每个链接都将一个文件名映射到一个文件。每个目录中至少有两个条目：“.”是该目录自身的链接，“..”是到该目录的父目录的链接。
- 套接字：用来与另一个进程进行网络通信的文件



## 打开文件

使用open函数，函数原型：

```c
int open(char *filename, int flags, mode_t mode);
```

该函数会返回一个文件描述符。返回的文件描述符总是进程中没有打开的最小描述符。

参数：

- filename 是一个已存在的文件名

- flags 指明了如何打开该文件

  - O_RDONLY：只读
  - O_WRONLY：只写
  - O_RDWR：可读可写
  - flags参数也可以是一个或更多位掩码的或，为写提供一些额外指示：
    - O_CREAT：如果文件不存在就创建一个空文件
    - O_TRUNC：如果文件已经存在就把它置空
    - O_APPEND：每次写操作前，设置文件当前位置在文件的末尾
  - mode参数指定了新文件的访问权限

  ## 读和写文件

  应用程序可以通过调用read和write函数来执行输入和输出。

  read函数返回-1表示出错，返回0表示EOF。返回其他正整数表示实际传送的字节数量。

  ## RI/O包健壮的读写

  一个I/O包，可以健壮的读写，可以自动处理不足值情况。所谓不足值就是read和write传送的字节数比应用程序要求的要少。

  就是带缓冲的读写函数，减少调用read的次数。

## 读取文件元数组

通过stat和fstat函数检索关于文件的信息。

stat函数以一个文件名作为输入，并会根据文件信息填写一个stat结构体。fstat作用是类似的，只不过是以文件描述符作为输入而不是文件名。

## 读取目录内容

使用opendir函数来打开目录流，以一个目录路径名为参数，返回指向目录流的指针。流是对条目有序列表的抽象。

使用readdir 函数来读取目录内容，输入和输出都是指向流中下一个目录项的指针，若没有更多目录项则返回NULL每个目录项都是一个结构体。

## I/O重定向

Linux shell提供了I/O重定向操作符，允许用户将文件和标准输入输出联系起来。例如：`ls > foo.txt`，shell加载和执行ls程序，并将标准输出重定向到磁盘文件foo.txt。

重定向的一种方式是使用dup2函数：`int dup2(int oldfd, int newfd);`就是复制描述符表表项oldfd倒描述符表表现newfd，覆盖newfd以前的内容。若newfd已经打开了，dup2会在复制oldfd之前关闭newfd。

举例说明：`dup2(4,1);`假设描述符1对应文件A（假设A是一个终端），描述符4对应于文件B（假设是一个磁盘文件）。这两个文件的引用计数都等于1.在执行完`dup2(4,1);`之后，4和1这两个文件描述符都指向文件B，此时文件A已经被关闭。文件B的引用计数加一。

## 标准I/O

C语言定义了一组高级输入输出函数，称为标准I/O库。

标准IO将一个打开的文件模型化为一个流，对于程序员来说就是一个指向FILE类型结构的指针。

每个ANSI C程序开始时都会打开三个流stdin、stdout和stderr，分别对应标准输出、标准输入和标准错误。

标准I/O其实也是在Linux I/O基础上加了缓冲区，和RIO类似，就是使开销较高的Linux I/O系统调用的次数尽可能少。

## 几种I/O使用原则

- 只要有可能就是用标准I/O
- 不要使用scanf或rio_readlineb（RIO中的一个读取行的函数）来读取二进制文件。因为这些函数是专门设计来读取文本文件的。
- 对网络套接字的I/O使用RIO。因为将标准I/O应用于网络的输入和输出时，会出现一些问题。

### 标准I/O的一些使用限制

- 跟在输出函数之后的输入函数：如果中间没有fflush、fseek、fsetpos或rewind的调用，一个输入函不能跟随在一个输出函数之后。fflush函数是用来清空与流相关的缓冲区。后三个函数使用Unix I/Olseek函数来重置当前的文件位置。
- 跟在输入函数之后的输出函数：如果中间没有插入对fseek、fsetpos或rewind的调用，一个输出函数异能跟随在一个输入函数之后，除非该输入函数遇到了一个文件结束。

又因为对套接字使用lseek是非法的。对于第一个限制套接字可以使用刷新缓冲区。但是对于第二个限制，只能对同一个打开的套接字描述符打开两个流，一个流用来读，一个流用来写。但关闭时又需要在两个流上都是用fclose，对于顺序程序还好，对于并发程序中关闭一个已经关闭了的描述符将会出错。因此对于网络I/O，最好使用RIO而不是标准I/O。