## 并发编程

现代操作系统提供了三种构造并发程序的方法：

1. 进程：由内核调度和和维护，每个逻辑流都是一个进程。每个进程间有独立的虚拟地址空间。进程之间通信必须使用某种显式的进程间通信机制。
2. I/O多路复用：在一个进程中调用逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式的从一个状态转换到另一个状态。因为是在同一个进程中，所以所有流共享地址空间。
3. 线程：运行在同一个单一进程上下文中的逻辑流。由内核调度的。可以看成上述两种方法的结合体：像进程一样由内核调度，而像I/O多路复用一样共享同一虚拟地址空间。





## 多线程程序中的共享变量

### 线程内存模型

对等线程中，每个线程都有自己独立的线程上下文，这包括：

- 线程ID
- 栈
- 栈指针
- 程序计数器
- 条件码
- 通用寄存器的值



在同一进程的多个对等线程中，寄存器不能共享，但虚拟内存总是共享的。

各自独立的线程栈是保存在虚拟地址空间的栈中的。虽说各自线程栈被各自线程独立访问，但是如果一个线程A知道了另一个对等线程B的栈地址，那么线程A就可以访问线程B的栈。比如说一个线程可以通过一个全局指针间接访问主线程栈的内容，这个全局指针就指向主线程的栈。

### 将变量映射到内存

多线程程序中各类变量到虚拟内存的映射：

- 全局变量：定义在函数之外的变量。放在虚拟内存的读写区域，且每个全局变量只包含一个实例
- 本地非静态变量：定义在函数内部且没有static属性。每个线程的本地非静态变量都放在各自线程的栈中。
- 本地静态变量：定义在函数中且有static属性。和全局变量一样，也是在虚拟内存的读写区域只包含一个实例。



### 共享变量

所谓共享就是一个变量的一个实例被一个以上的线程引用。

本地非静态变量也能被共享，一般是通过其地址来共享它。



## 用信号量同步线程

前提：在编译时，一条高级语言语句可能会对应多条机器语言（指令）。

两个对等线程在一个单处理器上并发运行时，机器指令以某种顺序一个接一个的完成。一般而言，无法确定操作系统是否将两个线程的机器指令按照一个正确的顺序执行。所谓正确就是先一个线程的一句高级语言所对应的多条机器指令后再执行另一个线程的一句高级语言对应的多条机器指令。大部分情况下是两个线程的机器语言会混在一起交叉执行。

若在执行指令操作一个全局变量时就涉及到寄存器操作，但又因为不同线程不共享寄存器，当一个线程A将全局变量从内存取到线程A的某个寄存器中进行操作后，还没来得及重新写回内存，就可能执行另一线程B的指令，这个指令可能是B中寄存器的值写到全局变量所在的内存上，等到操作系统又执行A的寄存器写回内存操作时这就将B的写回值给覆盖了，就相当于B的前一次对全局变量的操作完全白做了。

说白了就是在高级语言中的一条（全局）变量自增语句代码其实就只用一句话，编译成机器语言后就成了若干条机器指令。而在并行执行时，单核CPU不能保证这个若干条指令是紧挨着执行的，这若干条指令之间可能还会执行别的线程中的指令。而正是这些别的线程的指令可能就会使本线程这若干条语句的工作实效。

当然虽然两个线程的指令交叉顺序不能确定，但是同一个线程下的指令还都是相对按序执行的，只不过中间会插入几个别的线程的指令。

### 信号量

信号量s是具有非负整数值得全局变量。

只能通过两种方式来处理信号量，分别是P和V：

- P(s)：如果s是非零的，那么将s减一，并且立即返回。如果s为零，那么就挂起这个线程，直到s变为非零，而一个V操作会重启这个线程。重启后P将s减一，并将控制返回给调用者
- V(s)：V操作将s加一。如果有任何线程阻塞在P操作等待s变为非零，那么V操作会重启这些线程中的一个，然后该线程将s减一，完成它的P操作。

V没有定义等待线程被重启的顺序，V必须只重启一个正在等待的线程。所以不能预测V将要重启哪个线程。

**信号量不变性**：就是一个正确初始化的信号量是不会变为负值的。

信号量使用前必须先进行初始化。

#### Posix标准中定义的操作信号量函数

```c
#include<semaphore.h>
int sem_init(sem_t *sem, 0, unsigned int value); // 初始化信号量
int sem_wait(sem_t *s);  // 相当于P操作
int sem_post(sem_t *s);  // 相当于V操作
```

### 使用信号量来实现互斥

具体使用就是将每一个共享变量（或一组相关的共享变量）与一个信号量s（初始化为1）联系起来，然后使用P(s)和V(s)将对共享变量的操作临界区包围起来。这种方式因为s总是值为0或1，所以叫二元信号量。

二元信号量也称为互斥锁。P相当于加锁，V相当于解锁。对一个互斥锁加了锁但没有解锁的线程就称为占用了这个互斥锁。



### 利用信号量来调度共享资源

信号量还可以用作对共享资源的调用。一个线程用信号量来通知另一个线程，程序状态中的某个条件已经为真了。

#### 生产者-消费者问题

在这个问题中（这是一个设计模式）生产者和消费者共享一个含有n个槽的有限缓冲区。

生产者反复的生成新的项目插入到缓冲区中。

消费者不断地从缓冲区中取出一个项目并使用（消费）它。

当然不是说一定是一个生产者和一个消费者一一对应，也可以是多个生产者或多个消费者。

插入新项目和取出项目都需要更新共享缓冲区，这就需要将缓冲区的访问设成互斥的。

而且又因为缓冲区的容量是有限的，所以还要调度对缓冲区的访问。当缓冲区慢时，生产者挂起，直到缓冲区有空位置才产生新的项目并插入。当缓冲区为空时，消费者挂起，直到缓冲区中有项目为止。

#### 一个简单的生产者-消费者程序设计

```c
/*
* 这里sbuf_t是一个有限缓冲区，存放n个项目，每个项目是一个整数，放在数组buf中。
*/

typedef struct
{
    int *buf;   	// 存放项目的整数数组
    int n;     		// 项目个数
    int front;		// 第一项
    int rear;		// 最后一项
    sem_t mutex;	 // 提供互斥的缓冲区访问
    sem_t slots;	 // 记录空槽位
    sem_t items;     // 可用项目数
} sbuf_t;

// 初始化缓冲区
void subf_init(subf_t *sp, int n)
{
    sp->n = n;						   // 缓冲区能存放项目的最大个数
    sp->buf = Calloc(n, sizeof(int));	 // 为buf分配空间
    sp->front = sp->rear = 0;			// 因为一开始缓冲区中无项目，所以这两项均设为0
    Sem_init(sp->mutex, 0, 1);			// 互斥锁
    Sem_init(sp->slots, 0, n);			// 缓冲区初始含有n个空位
    Sem_init(sp->items, 0, 0);			// 缓冲区初始含有0个可用项目
}

// 清空缓冲区
void sbuf_deinit(sbuf_t *sp)
{
    Free(sp->buf); // 只有buf是手动开辟的空间，所以需要手动释放该空间
}

// 向缓冲区插入新项目
void subf_insert(sbuf_t *sp, int item)
{
    // 检查是否存在空位
    P(&sp->slots);
    // 给共享资源区上锁
    P(&sp->mutex);
    // 向共享资源区插入新项目
    sp->buf[(++sp->rear)%(sp->n)] = item;
    // 解锁资源区
    V(&sp->mutex);
    // 可用项目加一
    V(&sp->items);
}

//从缓冲区取项目
int subf_remove(subf_t * sp)
{
    int item;
    // 检查是否存在项目
    P(&sp->items);
    // 给共享资源区上锁
    P(&sp->mutex);
    // 从共享资源区取出项目
    item = sp->buf[(++sp->front)%(sp->n)];
    // 解锁资源区
    V(&sp->mutex);
    // 可用空位加一
    V(&sp->slots);
    return item;
    
}
```



#### 读者-写者问题

对于一个磁盘上的数据或主存中一个数据结构，有的线程只读数据，有的线程只写线程。这里只读线程称为读者，只写线程称为写着。

写者在写时必须要独占对象，而读者却可以和其他若干个读者共享对象。

该问题根据读者和写者的优先级可以有若干个变种：

- 读者优先：要求不让读者等待，除非已经将对象的使用对象的权限已经赋给了一个写者。不会因为有一个写者在等待而等待。也就是说如果已经有一个写在等待（即还未获得使用对象的权限），这时来了一个读者，会让读写先处理。写者只有在没有读者的情况下才会工作。
- 写者优先：一旦一个写者准备好要进行写操作，它就会尽快完成它的写操作。在一个写者后到达的读者必须等待，即使写者也在等待。

## 使用线程提高并行性

顺序程序只有一条逻辑流

并发程序有多条并发流。

并行程序是一个运行在多个处理器上的并发程序。因此并行程序是并发程序的真子集。

对于一个简单的计算0到n的和的程序，当采用多线程计算时，线程数越多反而越慢。这是因为同步操作P和V代价太大，已经大过了内存更细操作。因此：**同步开销大，要尽可能避免。如果无可避免，必须要用尽可能多的有用计算弥补这个开销。**

## 并发的其它问题

### 线程安全

线程安全的函数：当被多个并发线程反复调用时，会一直产生正确结果的函数。

四个线程不安全函数类：

1. 不保护共享变量的函数：
2. 保护跨越多个调用的状态的函数：
3. 返回指向静态变量的指针的函数：
4. 调用线程不安全函数的函数：

