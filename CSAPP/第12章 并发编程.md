## 并发编程

现代操作系统提供了三种构造并发程序的方法：

1. 进程：由内核调度和和维护，每个逻辑流都是一个进程。每个进程间有独立的虚拟地址空间。进程之间通信必须使用某种显式的进程间通信机制。
2. I/O多路复用：在一个进程中调用逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式的从一个状态转换到另一个状态。因为是在同一个进程中，所以所有流共享地址空间。
3. 线程：运行在同一个单一进程上下文中的逻辑流。由内核调度的。可以看成上述两种方法的结合体：像进程一样由内核调度，而像I/O多路复用一样共享同一虚拟地址空间。





## 多线程程序中的共享变量

### 线程内存模型

对等线程中，每个线程都有自己独立的线程上下文，这包括：

- 线程ID
- 栈
- 栈指针
- 程序计数器
- 条件码
- 通用寄存器的值



在同一进程的多个对等线程中，寄存器不能共享，但虚拟内存总是共享的。

各自独立的线程栈是保存在虚拟地址空间的栈中的。虽说各自线程栈被各自线程独立访问，但是如果一个线程A知道了另一个对等线程B的栈地址，那么线程A就可以访问线程B的栈。比如说一个线程可以通过一个全局指针间接访问主线程栈的内容，这个全局指针就指向主线程的栈。

### 将变量映射到内存

多线程程序中各类变量到虚拟内存的映射：

- 全局变量：定义在函数之外的变量。放在虚拟内存的读写区域，且每个全局变量只包含一个实例
- 本地非静态变量：定义在函数内部且没有static属性。每个线程的本地非静态变量都放在各自线程的栈中。
- 本地静态变量：定义在函数中且有static属性。和全局变量一样，也是在虚拟内存的读写区域只包含一个实例。



### 共享变量

所谓共享就是一个变量的一个实例被一个以上的线程引用。

本地非静态变量也能被共享，一般是通过其地址来共享它。



## 用信号量同步线程

前提：在编译时，一条高级语言语句可能会对应多条机器语言（指令）。

两个对等线程在一个单处理器上并发运行时，机器指令以某种顺序一个接一个的完成。一般而言，无法确定操作系统是否将两个线程的机器指令按照一个正确的顺序执行。所谓正确就是先一个线程的一句高级语言所对应的多条机器指令后再执行另一个线程的一句高级语言对应的多条机器指令。大部分情况下是两个线程的机器语言会混在一起交叉执行。

若在执行指令操作一个全局变量时就涉及到寄存器操作，但又因为不同线程不共享寄存器，当一个线程A将全局变量从内存取到线程A的某个寄存器中进行操作后，还没来得及重新写回内存，就可能执行另一线程B的指令，这个指令可能是B中寄存器的值写到全局变量所在的内存上，等到操作系统又执行A的寄存器写回内存操作时这就将B的写回值给覆盖了，就相当于B的前一次对全局变量的操作完全白做了。

说白了就是在高级语言中的一条（全局）变量自增语句代码其实就只用一句话，编译成机器语言后就成了若干条机器指令。而在并行执行时，单核CPU不能保证这个若干条指令是紧挨着执行的，这若干条指令之间可能还会执行别的线程中的指令。而正是这些别的线程的指令可能就会使本线程这若干条语句的工作实效。

当然虽然两个线程的指令交叉顺序不能确定，但是同一个线程下的指令还都是相对按序执行的，只不过中间会插入几个别的线程的指令。