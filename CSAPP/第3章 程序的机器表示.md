## 程序的机器级表示

> 本章先快速浏览C语言、汇编语言、汇编代码以及机器代码之间的关系。然后介绍x86-64的细节，从数据的表示和处理以及控制的实现开始。讲解程序是如何为何一个运行栈来支持过程间数据和控制的传递。会考虑在机器级如何实现数组、结构和联合。最后讨论内存访问越界以及GBD的一些技巧。

#### 前言

高级语言编写的程序可以在很多不同的机器上运行；而汇编代码则只能在与之密切相关的特定的机器上运行。

---

### 程序代码

```c
linux> gcc -Og -o p p1.c p2.c
```

- gcc：GCC C编译器
- -Og：编译选项，是告诉编译器使用会生成原始C代码整体结构的机器代码的优化等级。
- -o：命令行指示符，指定输出的可执行代码文件的名称



#### 该行代码运行流程

- C预处理器扩展源代码：插入#include 命令指定的文件；替换#define定义的宏
- 编译产生p1.c和p2.c这两个源文件的汇编代码，分别为p1.s和p2.s
- 汇编器将这两个汇编代码转化成二进制目标代码文件p1.o和p2.o，这个目标代码文件是机器代码的一种形式，包含了所有指令的二进制表示，但是还没填入全局值的地址
- 链接器将这两个目标代码文件以及实现库函数的代码合并，最终生成可执行文件p

####  机器代码对于高级语言隐藏的处理器状态

- 程序计数器（PC）：在x86-64中用%rip表示，给出下一条将要执行指令的内存地址
- 整数寄存器文件：包含16个命名的位置，分别存储64位的值。可以用来存储地址或整数数据，记录程序状态，保存临时数据。
- 条件码寄存器：保存最近执行的算术或逻辑指令的状态码。
- 一组向量寄存器：存放一个或多个整数或浮点数。

#### 代码示例

```c
linux>gcc -Og -S xxx.c
```

这行代码会使GCC运行编译器，产生一个汇编文件xxx.s。

- -S：使用该命令行选项，就能看到编译器产生的汇编代码。

```c
linux>gcc -Og -c xxx.c
```

这行会产生目标代码文件xxx.o，是二进制格式的所以无法查看。

- -c：使用该命令行选项，GCC会编译并汇编该代码。

#### 反汇编：查看机器代码文件

```c
linux>objdump -d xxx.o
```

机器代码和它的反汇编特性

- x86-64的指令长度从1到15个字节不等。
- 设计指令格式的方式是，从某个给定的位置开始，可以将字节唯一地解码成机器指令。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码，不需要访问源代码或汇编代码。
- 反汇编器使用的指令格式与GCC生成的会变代码会有稍微区别，例如省略了指令结尾的'q'。

---

### 数据格式

由于是从16位体系扩展为32位的，所以Intel用术语字word表示16位数据，双字32位，四字64位。

---

### 访问信息

一个x86-64的CPU包含一组16个存储64位（即8个字节）值的通用寄存器。他们在x86-64中都是以%r开头的。

当对这些寄存器进行操作时，对于生成小于8字节结果的指令，字节中剩下的字节变化规则：

- 生成1字节或2字节数字的指令会保持剩下的字节不变
- 生成4字节数字的指令会把高4位字节值为0.

#### 操作数指示符

大多数指令都会有一个或多个操作数，指明某个操作中使用的源数据值，以及放置结果的目的位置。

操作数可分为三类：

- 立即数：用来表示常数值，格式：符号“$”后跟一个标准C语言整数
- 寄存器：表示某个寄存器的内容，例如用ra表示任意寄存器，用引用R[ra]表示它的值
- 内存引用：通常称为有效地址，Mb[Addr]表示从地址Addr开始b个字节值的引用

##### 寻址模式

常用格式：Imm(rb, ri, s) 表示有效地址为：Imm + R[rb] + R[ri] * s

- Imm：表示立即数偏移量
- rb：一个基址寄存器
- ri：一个变址寄存器
- s：比例因子，只能取1、2、4或8



#### 数据传送

在x86-64中限制：传送指令的两个操作数不能都是指向内存的位置，因此将内存中某个位置的值复制到内存中另一个位置时，需要两条指令：先把源值加载到寄存器中，再把该寄存器的值写入到目的位置。

##### 一般情况使用MOVx：这里的x可以是b、w、l以及q

MOV（传送指令）指令一般由五种情况：

- 立即数	->    寄存器
- 寄存器    ->    寄存器
- 立即数    ->    内存
- 内存        ->   寄存器
- 寄存器    ->   内存

#####当把一个较小（位数小）的源值复制到一个较大（位数大）的目的时，有如下两种传送方式

- MOVZym：把目的中剩余的字节填充为0
- MOVSym：把目的中剩余的字节填充为符号位
- 这里的ym是指令后缀，分别表示源和目的的大小，例如bw，就是把做了扩展的字节传送到字；wl表示把做了扩展的字传送到双字，以此类推还有bl，bq，wq


##### 关于传送指令注意事项

- 64为机器中不能使用32为寄存器做间接寻址：`movb %0xF, (%ebx)`
- 指令后缀要与数据匹配：`movl %rax, (%rsp)` 这里%rax是四字，所以应该使用movq
- 要使用存在的寄存器：`movb %al, %sl`  这里%sl不存在这个寄存器
- 不能同时使用两个内存地址作为操作数：`movw (%rax), 4(%rsp)`
- 不能使用立即数作为目的：`movq %rax, $0x123`
- 在使用非扩展（movz或movs）传送指令时，源和目的操作数大小应一致：`movl %eax, %rdx`

##### 压入和弹出栈数据

在x86-64中栈放在内存中的某个区域，向下增长，因此栈顶元素是栈中元素地址最低的。

- pushq指令：把数据压入栈中

- popq指令：把栈顶数据出栈

- 这两个指令只有一个操作数​​

**将一个四字值压入栈中：pushq %rbp** 

相当于：

​	subq $8, %rsp

​	movq %rbp, (%rsp)

但pushq指令在机器代码中为1个字节，而那两条等效指令共需要8字节

**弹出一个四字：popq %rax**

相当于：

​	movq (%rsp), %rax

​	addq $8, %rsp

**无论如何%rsp指向的地址总是栈顶**

---

### 算术和逻辑操作

####加载有效地址（load effective address）

- leaq令实际上是movq指令的变形，但其目的操作数必须是一个寄存器。
- 形式上看是从内存读取数据到寄存器，但实际上根本没有引用内存
- 用法：假设%rax中的值为x，%rbx中的值为y，则`leaq 7(%rax, %rbx, 4), %rcx ` 表示将%rcx的值设为`7+x+4y`

#### 一元操作

只有一个操作数，既是源又是目的。可以是寄存器，也可以是内存位置。

#### 二元操作数

有两个操作数，其中第二个操作数既是源又是目的。第一个操作数是源，可以是立即数、寄存器或内存位置；第二个操作数是目的，可以是寄存器或内存位置。

#### 移位操作

- 先给出移位量，再给出要移位的数
- 移位量可以是立即数，或存放在单字节寄存器%cl中，这里比较特殊，只允许用这个特殊的寄存器作为操作数。
- 目的操作数可以是寄存器也可以是内存位置
- 左移指令：SAL、SHL效果一样
- 右移指令：SAR是算术移位（填上符号），SHR是逻辑移位（填上0）


#### 特殊算术操作

##### 128位乘法

imulq除了是一个“双操作数”：从两个64位操作数产生一个64位乘积。还可以进行“单操作数”乘法指令：

- 计算两个64位值的全128位乘积
- 一种是无符号乘法mulq
- 另一种是补码乘法imulq
- 这两种指令都要求一个参数必须在寄存器%rax中，而另一个作为指令的源操作数给出。
- 乘积的结果高64位放在寄存器%rdx中
- 低64位放在寄存器%rax中

##### 除法

- 128位除法：
  - 有符号除法指令idivl将%rdx（高64）和%rax（低64）中的128位数作为被除数
  - 除数由指令操作数给出
  - 结果商放在%rax中，余数放在%rdx中
- 64位除法
  - 值放在%rax中，%rdx全0（无符号运算）或者为%rax的符号位（有符号运算）
  - 指令cqto不需要操作数，隐含读出%rax的符号并将它复制到%rdx的所有位
  - 结果的存放位置同上

----

### 控制

#### 条件码

常用的有：

- CF：进位标志。最近的操作使最高位产生了进位
- ZF：零标志。最近的操作得出的结果为0
- SF：符号标志。最近的操作结果为负数
- OF：溢出标志。最近的操作导致一个补码溢出

leaq指令不改变任何条件码，因为它是用来进行地址计算的。

还有两类指令只改变条件码，而不改变其它任何寄存器：

- cmpx：x可以替换为b、w、l和q。cmp S1, S2 结果基于S2-S1
- testx：x可以替换为b、w、l和q。test S1, S2 结果基于S1&S2

#### 条件码的使用

一般不会直接读取条件码，而是使用以下三种方式：

- 根据条件码的某种组合，将一个字节设为1或0，这类指令称为setx指令，x是指代指令后缀。这些指令后缀与之前不同，之前是表示操作数大小的，而此指令后缀是表示比较条件的
- 条件跳转到程序的某个部分
- 可以有条件的传送数据

#### 跳转

- jmp：无条件跳转，既可以直接跳转，跳转目标是作为指令的一部分编码；也可以间接跳转，跳转目标是从寄存器或内存位置中读出，且格式为：jmp *%rax 

- 还有其他跳转指令，这些指令都是带条件的，即根据条件码的某种组合进行跳转或不跳（继续执行代码序列中下一条指令）。

- ```
  假设x放在%rax中，y放在%rdx中
  cmpq %rdx, %rax   
  jge .L2   
  ....
  .L2:
  .....
  ```

- jge是大于等于就跳转的的意思，因此当x>=y时，跳转到.L2，注意这里虽然cmpq语句先写y（放在%rdx）后写x（放在%rax），但其实比较x是否大于等于y，而不是y是否大于等于x。其本质是根据计算x-y结果后的条件码来判断的。

  ​

- 跳转指令的编码方式有两种：
  - 相对的：将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间做差作为编码
  - 绝对的：直接用4个字节给出目标指令作为编码


#### 条件分支的两种实现

##### 用条件控制来实现条件分支

就当条件满足时，程序沿着一条路径执行；当条件不满足时，程序就走另一条路径。这种机制虽然简单通用，但在现代处理器上，它可能会非常低效。

低效的原因：处理器通过使用流水线来获得高效，当遇到条件跳转时，处理器为了保证流水线中充满指令，会对跳转指令进行猜测，即假设会跳转到A于是处理器就在该跳转指令后充满A指令。但是如果猜测失败，那么该指令后面填充的待执行的A指令就会被丢弃，然后用从正确的位置开始的指令填充流水线。这样的错误会浪费15-30个时钟周期。

##### 用条件传送来实现条件分支

解决上一个实现所带来的问题的方法是使用数据的条件转移：计算一个条件的两种结果，然后根据条件是否满足从中挑选一个。当然这种方法不如上一种方法通用。

一个不适合该方法的例子：

```c++
long cread(long *xp){
    return (xp?*xp:0);
}
```

若使用条件传送来实现：

```汇编
假设 xp 放在寄存器%rdi中 
cread:
	movq (%rdi), %rax       v = *xp
	testq %rdi, %rdi        Test x
	movl $0 ,%edx           Set ve = 0
	cmove %rdx, %rax        If x==0, v= ve
	ret                     Return v
```

这里有一个问题就是在Test x之前，先把xp指向地址的内容复制到%rdx，可是如果xp是个空指针，那么这里就导致一个间接引用空指针的错误。所以应该用条件控制来实现，即先判断指针是否为空。

而且使用条件传送也不是总能提高效率，因为要计算两种情况，若有一种情况不是跳转目标但计算量却很大，这就相当于白算了。

---

###循环

汇编中没有直接实现循环的指令，而是通过测试和跳转指令组合起来实现循环。

####while循环

while循环有两种翻译方式

- jump to middle 跳转到中间：先执行一个无条件跳转，跳到测试位置开始循环
- guarded-do：先用条件分支，如果初始条件不成立就跳过循环，否则将代码变换为do-while循环

#### switch（开关）语句

switch是使用跳转表这种数据结构实现的，表项i是个代码段的地址，当switch索引值等于i时，程序就执行相应地址的代码段。

使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。





