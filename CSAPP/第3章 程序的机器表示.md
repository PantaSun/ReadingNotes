## 程序的机器级表示

> 本章先快速浏览C语言、汇编语言、汇编代码以及机器代码之间的关系。然后介绍x86-64的细节，从数据的表示和处理以及控制的实现开始。讲解程序是如何为何一个运行栈来支持过程间数据和控制的传递。会考虑在机器级如何实现数组、结构和联合。最后讨论内存访问越界以及GBD的一些技巧。

#### 前言

高级语言编写的程序可以在很多不同的机器上运行；而汇编代码则只能在与之密切相关的特定的机器上运行。

---

### 程序代码

```c
linux> gcc -Og -o p p1.c p2.c
```

- gcc：GCC C编译器
- -Og：编译选项，是告诉编译器使用会生成原始C代码整体结构的机器代码的优化等级。
- -o：命令行指示符，指定输出的可执行代码文件的名称



#### 该行代码运行流程

- C预处理器扩展源代码：插入#include 命令指定的文件；替换#define定义的宏
- 编译产生p1.c和p2.c这两个源文件的汇编代码，分别为p1.s和p2.s
- 汇编器将这两个汇编代码转化成二进制目标代码文件p1.o和p2.o，这个目标代码文件是机器代码的一种形式，包含了所有指令的二进制表示，但是还没填入全局值的地址
- 链接器将这两个目标代码文件以及实现库函数的代码合并，最终生成可执行文件p

####  机器代码对于高级语言隐藏的处理器状态

- 程序计数器（PC）：在x86-64中用%rip表示，给出下一条将要执行指令的内存地址
- 整数寄存器文件：包含16个命名的位置，分别存储64位的值。可以用来存储地址或整数数据，记录程序状态，保存临时数据。
- 条件码寄存器：保存最近执行的算术或逻辑指令的状态码。
- 一组向量寄存器：存放一个或多个整数或浮点数。

#### 代码示例

```c
linux>gcc -Og -S xxx.c
```

这行代码会使GCC运行编译器，产生一个汇编文件xxx.s。

- -S：使用该命令行选项，就能看到编译器产生的汇编代码。

```c
linux>gcc -Og -c xxx.c
```

这行会产生目标代码文件xxx.o，是二进制格式的所以无法查看。

- -c：使用该命令行选项，GCC会编译并汇编该代码。

#### 反汇编：查看机器代码文件

```c
linux>objdump -d xxx.o
```

机器代码和它的反汇编特性

- x86-64的指令长度从1到15个字节不等。
- 设计指令格式的方式是，从某个给定的位置开始，可以将字节唯一地解码成机器指令。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码，不需要访问源代码或汇编代码。
- 反汇编器使用的指令格式与GCC生成的会变代码会有稍微区别，例如省略了指令结尾的'q'。

---

### 数据格式

由于是从16位体系扩展为32位的，所以Intel用术语字word表示16位数据，双字32位，四字64位。

---

### 访问信息

一个x86-64的CPU包含一组16个存储64位（即8个字节）值的通用寄存器。他们在x86-64中都是以%r开头的。

当对这些寄存器进行操作时，对于生成小于8字节结果的指令，字节中剩下的字节变化规则：

- 生成1字节或2字节数字的指令会保持剩下的字节不变
- 生成4字节数字的指令会把高4位字节值为0.

#### 操作数指示符

大多数指令都会有一个或多个操作数，指明某个操作中使用的源数据值，以及放置结果的目的位置。

操作数可分为三类：

- 立即数：用来表示常数值，格式：符号“$”后跟一个标准C语言整数
- 寄存器：表示某个寄存器的内容，例如用ra表示任意寄存器，用引用R[ra]表示它的值
- 内存引用：通常称为有效地址，Mb[Addr]表示从地址Addr开始b个字节值的引用

##### 寻址模式

常用格式：Imm(rb, ri, s) 表示有效地址为：Imm + R[rb] + R[ri] * s

- Imm：表示立即数偏移量
- rb：一个基址寄存器
- ri：一个变址寄存器
- s：比例因子，只能取1、2、4或8



#### 数据传送

在x86-64中限制：传送指令的两个操作数不能都是指向内存的位置，因此将内存中某个位置的值复制到内存中另一个位置时，需要两条指令：先把源值加载到寄存器中，再把该寄存器的值写入到目的位置。

##### 一般情况使用MOVx：这里的x可以是b、w、l以及q

MOV（传送指令）指令一般由五种情况：

- 立即数	->    寄存器
- 寄存器    ->    寄存器
- 立即数    ->    内存
- 内存        ->   寄存器
- 寄存器    ->   内存

##### 当把一个较小（位数小）的源值复制到一个较大（位数大）的目的时，有如下两种传送方式

- MOVZym：把目的中剩余的字节填充为0
- MOVSym：把目的中剩余的字节填充为符号位
- 这里的ym是指令后缀，分别表示源和目的的大小，例如bw，就是把做了扩展的字节传送到字；wl表示把做了扩展的字传送到双字，以此类推还有bl，bq，wq


##### 关于传送指令注意事项

- 64为机器中不能使用32为寄存器做间接寻址：`movb %0xF, (%ebx)`
- 指令后缀要与数据匹配：`movl %rax, (%rsp)` 这里%rax是四字，所以应该使用movq
- 要使用存在的寄存器：`movb %al, %sl`  这里%sl不存在这个寄存器
- 不能同时使用两个内存地址作为操作数：`movw (%rax), 4(%rsp)`
- 不能使用立即数作为目的：`movq %rax, $0x123`
- 在使用非扩展（movz或movs）传送指令时，源和目的操作数大小应一致：`movl %eax, %rdx`

##### 压入和弹出栈数据

在x86-64中栈放在内存中的某个区域，向下（向低地址增长）增长，因此栈顶元素是栈中元素地址最低的。

- pushq指令：把数据压入栈中

- popq指令：把栈顶数据出栈

- 这两个指令只有一个操作数​​

**将一个四字值压入栈中：pushq %rbp** 

相当于：

​	subq $8, %rsp

​	movq %rbp, (%rsp)

但pushq指令在机器代码中为1个字节，而那两条等效指令共需要8字节

**弹出一个四字：popq %rax**

相当于：

​	movq (%rsp), %rax

​	addq $8, %rsp

**无论如何%rsp指向的地址总是栈顶**

---

### 算术和逻辑操作

#### 加载有效地址（load effective address）

- leaq令实际上是movq指令的变形，但其目的操作数必须是一个寄存器。

- 形式上看是从内存读取数据到寄存器，但实际上根本没有引用内存，即不把指定内存地址里存放的东西赋给目的操作数，而是只是把该内存地址赋给目的操作数。用轮子哥的话来说“lea不解引用”。

- 用法：假设%rax中的值为x，%rbx中的值为y，则`leaq 7(%rax, %rbx, 4), %rcx ` 表示将%rcx的值设为`7+x+4y`

- lea指令不会设置条件码

- 几个明白的解释“

  - lea是“load effective address”的缩写，简单的说，lea指令可以用来将一个内存地址直接赋给目的操作数，例如：
    lea eax,[ebx+8]就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的内存地址里的数据赋给eax。

    而mov指令则恰恰相反，例如：

    mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。

    作者：米激动琪罗

    链接：https://www.zhihu.com/question/40720890/answer/110774673

    来源：知乎

    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

  - 可以这样理解，lea是直接操作寄存器内部存储的值，对于一些寄存器，比如%esp，%ebp，对应栈顶指针，栈底指针，本身存储的就是一个地址，因此lea操作这类寄存器时，体现出了**加载有效地址**的作用。

    而某些寄存器如果内部存储的不是一个地址，是一个具体的数，如果此时需要对这个数做一些算术运算，比如加一减一，乘二乘四等，同样可以通过lea指令**实现这个效果，**此时lea仅仅体现的是算术运算的作用。

    具体的例子比如CSAPP第三章156页讲递归指令时，对入口参数n减一的操作就通过lea实现（leal -1（%ebx），%eax）。

    而mov的作用分情况讨论，对于操作数是寄存器本身值的，那么就是直接操作寄存器内部存储的值，比如 movl %esp，%ebp；如果操作数对应的是内存中的数据，那么就是操作寄存器中存储的地址对应的内存中的值，比如movl 8（%ebp），%ebx .对于CSAPP中使用的汇编，一般可以通过操作数是否有括号进行区分。

    作者：chem2cs

    链接：https://www.zhihu.com/question/40720890/answer/223062818

    来源：知乎

    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#### 一元操作

只有一个操作数，既是源又是目的。可以是寄存器，也可以是内存位置。

#### 二元操作数

有两个操作数，其中第二个操作数既是源又是目的。第一个操作数是源，可以是立即数、寄存器或内存位置；第二个操作数是目的，可以是寄存器或内存位置。

#### 移位操作

- 先给出移位量，再给出要移位的数
- 移位量可以是立即数，或存放在单字节寄存器%cl中，这里比较特殊，只允许用这个特殊的寄存器作为操作数。
- 目的操作数可以是寄存器也可以是内存位置
- 左移指令：SAL、SHL效果一样
- 右移指令：SAR是算术移位（填上符号），SHR是逻辑移位（填上0）


#### 特殊算术操作

##### 128位乘法

imulq除了是一个“双操作数”：从两个64位操作数产生一个64位乘积。还可以进行“单操作数”乘法指令：

- 计算两个64位值的全128位乘积
- 一种是无符号乘法mulq
- 另一种是补码乘法imulq
- 这两种指令都要求一个参数必须在寄存器%rax中，而另一个作为指令的源操作数给出。
- 乘积的结果高64位放在寄存器%rdx中
- 低64位放在寄存器%rax中

##### 除法

- 128位除法：
  - 有符号除法指令idivl将%rdx（高64）和%rax（低64）中的128位数作为被除数
  - 除数由指令操作数给出
  - 结果商放在%rax中，余数放在%rdx中
- 64位除法
  - 值放在%rax中，%rdx全0（无符号运算）或者为%rax的符号位（有符号运算）
  - 指令cqto不需要操作数，隐含读出%rax的符号并将它复制到%rdx的所有位
  - 结果的存放位置同上

----

### 控制

#### 条件码

常用的有：

- CF：进位标志。最近的操作使最高位产生了进位
- ZF：零标志。最近的操作得出的结果为0
- SF：符号标志。最近的操作结果为负数
- OF：溢出标志。最近的操作导致一个补码溢出

leaq指令不改变任何条件码，因为它是用来进行地址计算的。

还有两类指令只改变条件码，而不改变其它任何寄存器：

- cmpx：x可以替换为b、w、l和q。cmp S1, S2 结果基于S2-S1
- testx：x可以替换为b、w、l和q。test S1, S2 结果基于S1&S2

#### 条件码的使用

一般不会直接读取条件码，而是使用以下三种方式：

- 根据条件码的某种组合，将一个字节设为1或0，这类指令称为setx指令，x是指代指令后缀。这些指令后缀与之前不同，之前是表示操作数大小的，而此指令后缀是表示比较条件的
- 条件跳转到程序的某个部分
- 可以有条件的传送数据

#### 跳转

- jmp：无条件跳转，既可以直接跳转，跳转目标是作为指令的一部分编码；也可以间接跳转，跳转目标是从寄存器或内存位置中读出，且格式为：jmp *%rax 

- 还有其他跳转指令，这些指令都是带条件的，即根据条件码的某种组合进行跳转或不跳（继续执行代码序列中下一条指令）。

- ```
  假设x放在%rax中，y放在%rdx中
  cmpq %rdx, %rax   
  jge .L2   
  ....
  .L2:
  .....
  ```

- jge是大于等于就跳转的的意思，因此当x>=y时，跳转到.L2，注意这里虽然cmpq语句先写y（放在%rdx）后写x（放在%rax），但其实比较x是否大于等于y，而不是y是否大于等于x。其本质是根据计算x-y结果后的条件码来判断的。

  ​

- 跳转指令的编码方式有两种：
  - 相对的：将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间做差作为编码
  - 绝对的：直接用4个字节给出目标指令作为编码


#### 条件分支的两种实现

##### 用条件控制来实现条件分支

就当条件满足时，程序沿着一条路径执行；当条件不满足时，程序就走另一条路径。这种机制虽然简单通用，但在现代处理器上，它可能会非常低效。

低效的原因：处理器通过使用流水线来获得高效，当遇到条件跳转时，处理器为了保证流水线中充满指令，会对跳转指令进行猜测，即假设会跳转到A于是处理器就在该跳转指令后充满A指令。但是如果猜测失败，那么该指令后面填充的待执行的A指令就会被丢弃，然后用从正确的位置开始的指令填充流水线。这样的错误会浪费15-30个时钟周期。

##### 用条件传送来实现条件分支

解决上一个实现所带来的问题的方法是使用数据的条件转移：计算一个条件的两种结果，然后根据条件是否满足从中挑选一个。当然这种方法不如上一种方法通用。

一个不适合该方法的例子：

```c++
long cread(long *xp){
    return (xp?*xp:0);
}
```

若使用条件传送来实现：

```汇编
假设 xp 放在寄存器%rdi中 
cread:
	movq (%rdi), %rax       v = *xp
	testq %rdi, %rdi        Test x
	movl $0 ,%edx           Set ve = 0
	cmove %rdx, %rax        If x==0, v= ve
	ret                     Return v
```

这里有一个问题就是在Test x之前，先把xp指向地址的内容复制到%rdx，可是如果xp是个空指针，那么这里就导致一个间接引用空指针的错误。所以应该用条件控制来实现，即先判断指针是否为空。

而且使用条件传送也不是总能提高效率，因为要计算两种情况，若有一种情况不是跳转目标但计算量却很大，这就相当于白算了。

---

### 循环

汇编中没有直接实现循环的指令，而是通过测试和跳转指令组合起来实现循环。

#### while循环

while循环有两种翻译方式

- jump to middle 跳转到中间：先执行一个无条件跳转，跳到测试位置开始循环
- guarded-do：先用条件分支，如果初始条件不成立就跳过循环，否则将代码变换为do-while循环

#### switch（开关）语句

switch是使用跳转表这种数据结构实现的，表项i是个代码段的地址，当switch索引值等于i时，程序就执行相应地址的代码段。

使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。

----

### 过程

假设P调用Q，Q执行完毕后返回P，这一系列过程涉及到以下一个或多个机制:

- 传递控制：从函数P进入到函数Q时，程序计数器PC被设置为Q函数代码的起始地址，然后在返回时，再把程序计数器PC设置为P函数中调用Q函数指令后面的那条指令的地址。
- 传递数据：P必须能够给向Q提供一个或多个参数，Q必须能够向P返回一个值。
- 分配和释放存储空间：在Q中可能会为局部变量分配空间，而在Q返回之前，又必须要释放这些空间。

#### 运行时栈

C语言过程调用使用了栈数据结构的先进后出的内存管理原则。

当P调用Q时，先把返回地址入栈，这样当Q执行完毕返回时就知道要从P的哪个位置继续执行P了。

返回地址入栈后，Q函数的代码会扩展当前栈的边界，也就是根据Q函数中的指令把Q中需要用到的被保存的寄存器、局部变量以及参数构造区入栈，即分配内存。

当Q执行完毕后，把Q相关信息出栈，即释放内存。

在x86-64机器中，当需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分被称为栈帧。

在一个栈帧的空间中，可以保存寄存器的值，分配局部变量空间，以及为它所调用的过程设置参数。

#### 转移控制

所谓返回地址就是P中调用Q的指令的下一条指令的地址。在x86-64机器中使用call Q指令来实现调用Q。call指令会把返回地址入栈，同时将程序计数器PC设置为Q的起始地址。

相应的ret指令会从栈中弹出返回地址，并将程序计数器PC设置为返回地址。

#### 数据传送

在x86-64机器中大部分过程间的数据传送是通过寄存器实现的。

当P调用Q时，P的代码必须首先把参数（指Q的参数）复制到寄存器中。当Q返回P时，P中的代码通过访问寄存器%rax来获取Q的返回值。这里代码指汇编代码。

在x86-64机器中可以通过寄存器最多传递6个整型参数。而且这些寄存器的使用是有特殊顺序的。寄存器使用的名字也要根据传递数据的类型来决定。

依次顺序是：

- %rdi
- %rsi
- %rdx
- %rcx
- %r8
- %r9

这里在使用时根据数据大小进行相应变动比如64位数用%rdi，而16位数用%di，8位数用%dil，这种使用方式可以推广到这6个寄存器。

当一个函数的参数大于6个时，超出6个的部分就要通过栈来传递。假设P调用过程Q，有n个参数，n>6。那么P代码分配的栈帧必须能容纳从7到n号参数的存储空间，且7号参数在栈顶。

当把参数存储完毕后，程序就可以执行call指令来将控制转移到Q，这时就把返回地址入栈。当Q中要使用前6号参数时，代码就从相应的寄存器中获取参数值，而当使用7号参数时只需要用栈顶指针%rsp+8来得到，第8号参数是%rsp+16，以此类推。

#### 栈上的局部存储

有些时候，局部数据必须放在内存中：

- 寄存器不足够存放所有本地数据
- 对一个局部变量使用地址运算符“&”，因此必须能够为它产生一个地址。
- 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。

运行时栈提供了一种简单的、在需要时分配、函数完成时释放局部存储的机制。

#### 寄存器中的局部存储空间

寄存器组是唯一所有过程共享的资源。

x86-64机器采用了一组统一的使用惯例，来防止被调用者不会覆盖调用者稍后会使用的寄存器值：

- 寄存器%rbx、%rbp以及%r12~%r15被划分为**被调用者保存寄存器**：当P调用Q时，Q要保存这些寄存器的值，确保他们的值在Q返回P时与Q被调用时的值是一致的。所以Q中要么不使用这些寄存器，要么就在使用前把用到的寄存器的值压入栈中，并在返回前从栈中弹出旧值。
- 剩下的除了%rsp的所有其他寄存器，被分类为**调用者保存寄存器**：这就意味着任何函数都能修改它们。加入P要调用Q，又因为Q也可以随意修改这些寄存器的值，所以为了保证在Q调用后P使用这些寄存器的值不变，所以P在调用Q之前应保存好这些数据。

---

### 数组分配和访问

##### 基本原则

数组基本形式： T A[N]; 这里T表示数组中存放的数据类型，N是整型常数。这个声明会在内存中分配一个L\* N字节大小的区域，L是T类型数据的大小（以字节为单位）。设xA为指向数组开头的指针的值，则数组元素 i 被放在（xA + L\* i）的位置。

C允许对指针进行运算，计算出的值会根据该指针指向的数据类型的大小进行伸缩。设p是一个指向类型为T的数组的指针，p的值为xA，那么 p + i 的值为 xA + L\* i 。

数组引用A[ i ] 等同于 \* (A+i)

##### 二维数组

二维数组的在内存中的存放是按照“行优先”的顺序排列。

基本声明： T D\[ R ][ C \] ; 则 D\[ i ][ j \] 的地址为 &D\[ i ][ j \] = xD + L \* (C \* i + j)

### 异质的数据结构

C中有两种将不同类型的对象组合到一起创建数据类型的机制：

- 结构，用关键字struct来声明，将多个对象集合到一个单位中。
- 联合，用关键字union来声明，允许用几种不同的类型来引用一个对象。

#### 结构

结构中所有组成部分都放在内存中一段连续的区域内。

指向结构的指针就是结构第一个字节的地址。

要想产生一个指向结构体内部对象的指针，只需要将结构的地址加上该字段的偏移量。