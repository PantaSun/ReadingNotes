## 程序的机器级表示

> 本章先快速浏览C语言、汇编语言、汇编代码以及机器代码之间的关系。然后介绍x86-64的细节，从数据的表示和处理以及控制的实现开始。讲解程序是如何为何一个运行栈来支持过程间数据和控制的传递。会考虑在机器级如何实现数组、结构和联合。最后讨论内存访问越界以及GBD的一些技巧。

#### 前言

高级语言编写的程序可以在很多不同的机器上运行；而汇编代码则只能在与之密切相关的特定的机器上运行。

---

### 程序代码

```c
linux> gcc -Og -o p p1.c p2.c
```

- gcc：GCC C编译器
- -Og：编译选项，是告诉编译器使用会生成原始C代码整体结构的机器代码的优化等级。
- -o：命令行指示符，指定输出的可执行代码文件的名称



#### 该行代码运行流程

- C预处理器扩展源代码：插入#include 命令指定的文件；替换#define定义的宏
- 编译产生p1.c和p2.c这两个源文件的汇编代码，分别为p1.s和p2.s
- 汇编器将这两个汇编代码转化成二进制目标代码文件p1.o和p2.o，这个目标代码文件是机器代码的一种形式，包含了所有指令的二进制表示，但是还没填入全局值的地址
- 链接器将这两个目标代码文件以及实现库函数的代码合并，最终生成可执行文件p

####  机器代码对于高级语言隐藏的处理器状态

- 程序计数器（PC）：在x86-64中用%rip表示，给出下一条将要执行指令的内存地址
- 整数寄存器文件：包含16个命名的位置，分别存储64位的值。可以用来存储地址或整数数据，记录程序状态，保存临时数据。
- 条件码寄存器：保存最近执行的算术或逻辑指令的状态码。
- 一组向量寄存器：存放一个或多个整数或浮点数。

#### 代码示例

```c
linux>gcc -Og -S xxx.c
```

这行代码会使GCC运行编译器，产生一个汇编文件xxx.s。

- -S：使用该命令行选项，就能看到编译器产生的汇编代码。

```c
linux>gcc -Og -c xxx.c
```

这行会产生目标代码文件xxx.o，是二进制格式的所以无法查看。

- -c：使用该命令行选项，GCC会编译并汇编该代码。

#### 反汇编：查看机器代码文件

```c
linux>objdump -d xxx.o
```

机器代码和它的反汇编特性

- x86-64的指令长度从1到15个字节不等。
- 设计指令格式的方式是，从某个给定的位置开始，可以将字节唯一地解码成机器指令。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码，不需要访问源代码或汇编代码。
- 反汇编器使用的指令格式与GCC生成的会变代码会有稍微区别，例如省略了指令结尾的'q'。

---

### 数据格式

由于是从16位体系扩展为32位的，所以Intel用术语字word表示16位数据，双字32位，四字64位。

---

### 访问信息

一个x86-64的CPU包含一组16个存储64位（即8个字节）值的通用寄存器。他们在x86-64中都是以%r开头的。

当对这些寄存器进行操作时，对于生成小于8字节结果的指令，字节中剩下的字节变化规则：

- 生成1字节或2字节数字的指令会保持剩下的字节不变
- 生成4字节数字的指令会把高4位字节值为0.

#### 操作数指示符

大多数指令都会有一个或多个操作数，指明某个操作中使用的源数据值，以及放置结果的目的位置。

操作数可分为三类：

- 立即数：用来表示常数值，格式：符号“$”后跟一个标准C语言整数
- 寄存器：表示某个寄存器的内容，例如用ra表示任意寄存器，用引用R[ra]表示它的值
- 内存引用：通常称为有效地址，Mb[Addr]表示从地址Addr开始b个字节值的引用

##### 寻址模式

常用格式：Imm(rb, ti, s) 表示有效地址为：Imm + R[rb] + R[ri] * s

- Imm：表示立即数偏移量
- rb：一个基址寄存器
- ri：一个变址寄存器
- s：比例因子，只能取1、2、4或8



#### 数据传送

在x86-64中限制：传送指令的两个操作数不能都是指向内存的位置，因此将内存中某个位置的值复制到内存中另一个位置时，需要两条指令：先把源值加载到寄存器中，再把该寄存器的值写入到目的位置。

##### 一般情况使用MOVx：这里的x可以是b、w、l以及q

MOV（传送指令）指令一般由五种情况：

- 立即数	->    寄存器
- 寄存器    ->    寄存器
- 立即数    ->    内存
- 内存        ->   寄存器
- 寄存器    ->   内存

#####当把一个较小（位数小）的源值复制到一个较大（位数大）的目的时，有如下两种传送方式

- MOVZym：把目的中剩余的字节填充为0
- MOVSym：把目的中剩余的字节填充为符号位
- 这里的ym分别表示源和目的的大小，例如bw，就是把做了扩展的字节传送到字；wl表示把做了扩展的字传送到双字，以此类推还有bl，bq，wq


##### 关于传送指令注意事项

- 64为机器中不能使用32为寄存器做间接寻址：`movb %0xF, (%ebx)`
- 指令后缀要与数据匹配：`movl %rax, (%rsp)` 这里%rax是四字，所以应该使用movq
- 要使用存在的寄存器：`movb %al, %sl`  这里%sl不存在这个寄存器
- 不能同时使用两个内存地址作为操作数：`movw (%rax), 4(%rsp)`
- 不能使用立即数作为目的：`movq %rax, $0x123`
- 在使用非扩展（movz或movs）传送指令时，源和目的操作数大小应一致：`movl %eax, %rdx`

##### 压入和弹出栈数据

在x86-64中栈放在内存中的某个区域，向下增长，因此栈顶元素是栈中元素地址最低的。

- pushq指令：把数据压入栈中

- popq指令：把栈顶数据出栈

- 这两个指令只有一个操作数​​

**将一个四字值压入栈中：pushq %rbp** 

相当于：

​	subq $8, %rsp

​	movq %rbp, (%rsp)

但pushq指令在机器代码中为1个字节，而那两条等效指令共需要8字节

**弹出一个四字：popq %rax**

相当于：

​	movq (%rsp), %rax

​	addq $8, %rsp

**无论如何%rsp指向的地址总是栈顶**

---

### 算术和逻辑操作

####加载有效地址（load effective address）

- leaq令实际上是movq指令的变形，但其目的操作数必须是一个寄存器。
- 形式上看是从内存读取数据到寄存器，但实际上根本没有引用内存
- 用法：假设%rax中的值为x，%rbx中的值为y，则`leaq 7(%rax, %rbx, 4), %rcx ` 表示将%rcx的值设为`7+x+4y`

#### 一元操作

只有一个操作数，既是源又是目的。可以是寄存器，也可以是内存位置。

#### 二元操作数

有连个操作数，其中第二个操作数既是源又是目的。第一个操作数是源，可以是立即数、寄存器或内存位置；第二个操作数是目的，可以是寄存器或内存位置。

#### 移位操作

- 先给出移位量，再给出要移位的数
- 移位量可以是立即数，或存放在单字节寄存器%cl中，这里比较特殊，只允许用这个特殊的寄存器作为操作数。
- 目的操作数可以是寄存器也可以是内存位置
- 左移指令：SAL、SHL效果一样
- 右移指令：SAR是算术移位（填上符号），SHR是逻辑移位（填上0）

