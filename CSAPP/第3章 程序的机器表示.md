## 程序的机器级表示

> 本章先快速浏览C语言、汇编语言、汇编代码以及机器代码之间的关系。然后介绍x86-64的细节，从数据的表示和处理以及控制的实现开始。讲解程序是如何为何一个运行栈来支持过程间数据和控制的传递。会考虑在机器级如何实现数组、结构和联合。最后讨论内存访问越界以及GBD的一些技巧。

#### 前言

高级语言编写的程序可以在很多不同的机器上运行；而汇编代码则只能在与之密切相关的特定的机器上运行。

---

### 程序代码

```c
linux> gcc -Og -o p p1.c p2.c
```

- gcc：GCC C编译器
- -Og：编译选项，是告诉编译器使用会生成原始C代码整体结构的机器代码的优化等级。
- -o：命令行指示符，指定输出的可执行代码文件的名称



#### 该行代码运行流程

- C预处理器扩展源代码：插入#include 命令指定的文件；替换#define定义的宏
- 编译产生p1.c和p2.c这两个源文件的汇编代码，分别为p1.s和p2.s
- 汇编器将这两个汇编代码转化成二进制目标代码文件p1.o和p2.o，这个目标代码文件是机器代码的一种形式，包含了所有指令的二进制表示，但是还没填入全局值的地址
- 链接器将这两个目标代码文件以及实现库函数的代码合并，最终生成可执行文件p

####  机器代码对于高级语言隐藏的处理器状态

- 程序计数器（PC）：在x86-64中用%rip表示，给出下一条将要执行指令的内存地址
- 整数寄存器文件：包含16个命名的位置，分别存储64位的值。可以用来存储地址或整数数据，记录程序状态，保存临时数据。
- 条件码寄存器：保存最近执行的算术或逻辑指令的状态码。
- 一组向量寄存器：存放一个或多个整数或浮点数。

#### 代码示例

```c
linux>gcc -Og -S xxx.c
```

这行代码会使GCC运行编译器，产生一个汇编文件xxx.s。

- -S：使用该命令行选项，就能看到编译器产生的汇编代码。

```c
linux>gcc -Og -c xxx.c
```

这行会产生目标代码文件xxx.o，是二进制格式的所以无法查看。

- -c：使用该命令行选项，GCC会编译并汇编该代码。

#### 反汇编：查看机器代码文件

```c
linux>objdump -d xxx.o
```

机器代码和它的反汇编特性

- x86-64的指令长度从1到15个字节不等。
- 设计指令格式的方式是，从某个给定的位置开始，可以将字节唯一地解码成机器指令。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码，不需要访问源代码或汇编代码。
- 反汇编器使用的指令格式与GCC生成的会变代码会有稍微区别，例如省略了指令结尾的'q'。