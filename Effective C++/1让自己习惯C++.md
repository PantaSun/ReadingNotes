## 条款 01



P12

C++的四个主要的次语言

- C：C++的基础
- Object-Oriented C++：C with Classess所诉求的部分：类的继承、封装、多态等
- Template C++：C++的泛型编程部分
- STL：是个Template程序库



## 条款 02 尽量用const，enum，inline 替换 #define 

>  宁可以编译器替换预处理器

用#define有很多问题：

- #define定义的宏常量无法被编译器看到，出错时不易被追踪；而使用常量替换宏可以使编译器看到常量的定义
- 预处理只是将代码中的宏进行文本替换，这可能使一个代码中出现多份目标；而使用常量定义只有一份
- 无法用#define创建一个class专属常量，因为#define只是简单替换而不重视作用域。
- #define也无法提供任何封装性



P14

class专属常量

```c++
class GamePlayer{
  private:
    static const int NumTurns = 6; // 常量声明式
    int score[NumTurns];
    ...
};
```

上述代码中的class常量的作用域仅限于在class内，该语句是声明语句而非定义式。一般情况下，C++会要求对使用的任何东西要提供一个定义式，但class专属常量且又是static且为整数类型（ints，chars，bools）时就需要特殊处理。只要不取它们的地址，就可以在声明后使用它而无需定义。当要取地址或坚持要看定义式时就必须提供如下定义式：

```c++
const int GamePlayer::NumTurns;//位于实现文件而非头文件
```

注意这里定义式没有赋予数值，因为class常量已经在声明时获得初值，因此定义式不可以再设初值。

P15

有的编译器不允许static成员在声明式上获取初值，此时就需要static class常量定义式上设定初值

但有时候又需要在class内使用该static成员声明函数的大小，此时可以用“the enum hack”补偿做法

```c++
class GamePlayer{
  private:
    enum{ NumTurns = 6}; // "the enum hack" ，令NumTurns成为6的一个记号名称
    int score[NumTurns]; // 可以用来声明数组大小
    ...
};
```

一个枚举类型的数值可以权充ints被使用

enum hack的行为某些时候更像#define，例如取一个enum的地址是不合法的，#define也是如此

**对于形似函数的宏最好改用inline函数代替#define**



## 尽可能使用const

```c++
char greeting[] = "Hello";
char *p1 = greeting; 			// non-const pointer, con-const data
const char *p2 = greeting;		// non-const pointer, const data
char * const p3 = greeting;		// const pointer, non-const data
const char* const p4 = greeting;// const pointer, const data
```

一般来说const在星号左边，则被指物为常量；在星号右边则指针自身是常量；在两边则被指物和指针都是常量。

P18

STL迭代器作用就像一个T*指针。所以声明迭代器为const就像声明指针为const一样，即T * const，表明这个针指不能指向不同的东西，但它所指的东西的值可以改变。若希望指的东西不能变则需要使用const_iterator.



P19

将成员函数声明为const的原因是为了确保该成员函数可以被const对象调用。

两个成员函数只是常量性不同，可以被重载。

P21

##### 如果成员函数是const意味着什么：

- bitwise（physical ） constness：从物理角度，即从编译器角度，只要声明为const的成员函数不修改任何成员变量（static成员除外）即可，即该成员函数体内没有其它non-static成员的赋值操作（不修改对象内的任何一个bit）。但是这种约束也有一定的陷阱：

  ```c++
  class CTB{
    public:
    char & operator[](std::size_t position) const{return pText[poistion];}
    private:
    	char * pText;
  };
  
  const CTB ctb("Hello world!");
  char *pc = &ctb[0];
  *pc = 'J';
  ```

  这里对然对象ctb是const的，按理说不能修改该对象的成员值，但是下边的代码确实改变了该对象的成员值，并且这中写法也编译通过了。也就说bitwise只注重形式，只看表面，不管深层的东西，或者说不能做到逻辑上constness。

- logical constness：从逻辑角度出发，一个const成员函数可以修改他所处理对象内的某些bits，但只有在客户端侦测不出的情况下才可以这样。也就是只要逻辑上不能看出const成员函数修改了其它non-const成员，实际代码操作时可以在私下修改对象成员。但是这里又有新问题了，想要私下修改，编译器肯定是不会同意的，这怎么办？可以把想要修改的成员声明成mutable（可变的），mutable释放掉not-static成员变量的bitwise constness约束。

P23

##### 在const和non-const成员函数中避免重复

假设有两个兄弟函数一个是const一个non-const，但这两个函数内部构造基本一致，如下：

```c++
class TextBlock{
  public:
    ...
    const char& operator[](std::size_t position) const{
    	...
        ...
        ...
        return text[poistion];
    }
    char& operator[](std::size_t position) {
    	...
        ...
        ...
        return text[poistion];
    }
  private:
    std::string text;

};
```

