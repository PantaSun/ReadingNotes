









### 内核的职责

- 进程调度
- 内存管理
- 提供了文件系统
- 创建和终止进程
- 对设备的访问
- 联网
- 提供系统调用应用编程接口

### 从内核与进程的视角看整个系统

#### 对于进程来说

- 进程对自己运行期间内的许多事件都无法预期。
- 进程不知道自己合适暂停对CPU的占用，也不知道随之而来占用cpu的进程是哪一个；
- 进程也不知道自己何时重新占用CPU
- 进程不知道自己在ram中的位置
- 进程也不知道自己要访问的文件处于磁盘的什么位置，它只是知道文件的名称而已
- 进程彼此必能直接通信
- 进程也无法创建出新进程
- 进程无法终止自己
- 进程也不能与外设直接通信

#### 对于内核来说

- 内核对于系统的一切无所不知、无所不能
- 内核可以对进程进行控制
- 内核可以将文件名转化为磁盘的物理地址
- 所有进程间通信都需要内核提供的通信机制来完成
- 内核会响应进程发出的创建进程和终止进程的请求
- 内核与外设直接通信，并按需将数据与进程交互

#### 一些说辞

一般所说的某进程创建另一个进程、某进程将数据写入文件、某进程调用exit()终止某进程等，这些说法中的动作都是由内核在中间进行操作的。



### shell

是一种有特殊用途的程序，主要用于读取用户输入的命令，并执行相应的程序以响应该命令。也称为命令解释器。

bash：bourne again shell



### 进程

#### 进程的内存布局

逻辑上可以将一个进程划分为（也称为段）：

- 文本：程序的指令
- 数据：程序使用的静态数据
- 堆：程序可从该区域动态分配额外的内存
- 栈：随函数调用、返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间

#### 创建进程和执行程序

1. 创建进程使用fork()函数，调用fork函数的进程称为父进程，新创建的进程称为子进程。内核通过对父进程的复制来创建子进程。

   子进程从父进程处继承数据段、栈段以及堆段的副本后，可以修改这些内容，不影响父进程的原版内容。在内存中被标记为只读的程序文本段则为父子进程共享。

2. 子进程要么去执行与父进程共享代码段中的另一组不同函数，或者使用execve()函数去加载并执行 一个全新程序。

   execve函数会销毁现有的文本段、数据段、栈段以及堆段，并根据新代码，创建新段来代替它们。

#### init进程

系统引导时，内核会创建一个名为init的特殊进程，它是所有进程之父。系统的其他进程不是由init直接创建就是由其后代创建的。init的进程号固定为1，谁都不能杀死该进程，哪怕是超级用户。只有关闭系统才能杀死init进程。

#### 守护进程

具有特殊用途的进程，系统创建和处理此类进程的方式和其他进程相似，但这些进程还有一些独有的特征：

- 守护进程通常在系统引导时启动，直至系统关闭前会一直存在
- 守护进程在后台运行，且无控制终端供其读写数据。



### 内存映射

调用系统函数mmap的进程，会在其虚拟地址空间中创建一个新的内存映射。

**映射种类**：

- 文件映射：将文件部分区域映射入调用进程的虚拟内存。映射完成后，对文件映射内容的访问则转化为对相应内存区域的字节操作。
- 匿名映射：其映射页面的内容会被初始化为0.

某一进程所映射的内存可以与其他进程的映射共享，有两种共享方式：

- 两个进程都针对某一文件的相同部分加以映射
- 由fork创建的子进程继承于父进程的映射。

**映射改动**：共享映射是有一个标志，该标志决定某进程对映射内容修改对于其他进程是否可见：

- 标志设为私有时，修改对其他进程不可见，而且这些改动也不会落实到文件上
- 标志设为共享时，修改对其他进程可见，并会造成对文件的改动。