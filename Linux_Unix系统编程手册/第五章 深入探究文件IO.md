### 前言

本章主要在基本IO的基础上引入原子操作。

其次介绍文件描述符和已打开文件的内核数据结构。

最后介绍非阻塞IO。

### 原子操作和竞争条件

所有系统调用都是以原子操作方式执行的。原因是，内核保证了某系统调用中的所有步骤会作为独立操作而一次性加载以执行，期间不会因为其他进程或线程而中断。



#### 两种竞争条件

1. 以独占方式创建一个文件：在创建文件时，使用O_EXCL和O_CRET作为open函数的标志位，这时若要打开（创建）的文件已经存在，则open函数会返回一个错误。

   这种方式就保证了进程是打开文件的创建者。

   加上O_EXCL就可以将文件检索和文件 创建绑定为一个单一的原子操作。

2. 向文件尾部追加数据

   多个进程同时向同一个文件尾部添加数据时也会发生竞争。当多个进程都是先设置文件偏移量然后再添加数据时，如果一个进程的这两个步骤之间被执行相同代码的另一进程中断，那么这两个进程就获得到相同的偏移量，因此肯定有一个进程添加的数据会被另一个进程覆盖。

   要解决这个问题，就是在open函数时加入O_APPEND这个标志。

   O_APPEND可以保证每次写都是添加到此时文件的末尾。

### fcntl函数

```c
#include <fcntl.h>
// 成功的返回值取决于cmd，失败则返回-1
int fcntl(int fd, int cmd, ...);
```

#### cmd的值

1. F_GETFL：根据文件描述符获取打开文件时设置的状态标志
2. F_SETFL：修改打开文件的某些状态标志



### 文件描述符和打开文件之间的关系

文件描述符和打开文件并不是一一对应的，因为多个文件描述符可以指向同一个文件。

在内核中关于打开文件维护了三个数据结构：

- 进程级的文件描述符表：内核为每个进程都维护了一个打开文件描述符表，其每个条目的信息如下：
  - 控制文件描述符操作的一组标志
  - 对打开文件句柄的引用
- 系统级的打开文件描述符表：系统为所有打开文件维护了一个系统级别的描述表格，就是打开文件表，表中的每一项称为打开文件句柄（就是线程级别文件描述符表表项中所引用的）。其包括的信息如下：
  - 当前文件偏移量
  - 打开文件时所使用的状态标志
  - 文件访问模式
  - 与信号驱动IO相关的设置
  - 对该文件i-node对象的引用
- 文件系统的i-node表：文件系统为驻留其上的所有文件建立的i-node信息表：
  - 文件类型
  - 一个指针，指向该文件所持有的锁的列表
  - 文件的各种属性，大小以及各种操作相关的时间