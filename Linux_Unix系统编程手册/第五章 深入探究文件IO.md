### 前言

本章主要在基本IO的基础上引入原子操作。

其次介绍文件描述符和已打开文件的内核数据结构。

最后介绍非阻塞IO。

### 原子操作和竞争条件

所有系统调用都是以原子操作方式执行的。原因是，内核保证了某系统调用中的所有步骤会作为独立操作而一次性加载以执行，期间不会因为其他进程或线程而中断。



#### 两种竞争条件

1. 以独占方式创建一个文件：在创建文件时，使用O_EXCL和O_CRET作为open函数的标志位，这时若要打开（创建）的文件已经存在，则open函数会返回一个错误。

   这种方式就保证了进程是打开文件的创建者。

   加上O_EXCL就可以将文件检索和文件 创建绑定为一个单一的原子操作。

2. 向文件尾部追加数据

   多个进程同时向同一个文件尾部添加数据时也会发生竞争。当多个进程都是先设置文件偏移量然后再添加数据时，如果一个进程的这两个步骤之间被执行相同代码的另一进程中断，那么这两个进程就获得到相同的偏移量，因此肯定有一个进程添加的数据会被另一个进程覆盖。

   要解决这个问题，就是在open函数时加入O_APPEND这个标志。

   O_APPEND可以保证每次写都是添加到此时文件的末尾。

### fcntl函数

```c
#include <fcntl.h>
// 成功的返回值取决于cmd，失败则返回-1
int fcntl(int fd, int cmd, ...);
```

#### cmd的值

1. F_GETFL：根据文件描述符获取打开文件时设置的状态标志
2. F_SETFL：修改打开文件的某些状态标志



### 文件描述符和打开文件之间的关系

文件描述符和打开文件并不是一一对应的，因为多个文件描述符可以指向同一个文件。

在内核中关于打开文件维护了**三个数据结构：**

- **进程级的文件描述符表：**内核为每个进程都维护了一个打开文件描述符表，其每个条目的信息如下：
  - 控制文件描述符操作的一组标志
  - 对打开文件句柄的引用
- **系统级的打开文件描述符表：**系统为所有打开文件维护了一个系统级别的描述表格，就是打开文件表，表中的每一项称为打开文件句柄（就是线程级别文件描述符表表项中所引用的）。其包括的信息如下：
  - 当前文件偏移量
  - 打开文件时所使用的状态标志
  - 文件访问模式
  - 与信号驱动IO相关的设置
  - 对该文件i-node对象的引用
- **文件系统的i-node表：**文件系统为驻留其上的所有文件建立的i-node信息表：
  - 文件类型
  - 一个指针，指向该文件所持有的锁的列表
  - 文件的各种属性，大小以及各种操作相关的时间

### 复制文件描述符

使用dup函数：

```c
#include<unistd.h>
// 成功返回新的文件描述符，失败则返回-1
int dup(int oldfd);
```

新的文件描述符是编号最低的未用文件描述符。

还有一个dup2函数可以返回指定的文件描述符：

```c
#include<unistd.h>
// 成功返回新的文件描述符，失败返回-1
int dup2(int oldfd, newfd);
```

若newfd文件描述符已经打开，则dup2会先将其关闭。若oldfd不是有效的文件描述符，则该函数调用失败并返回错误EBADF且不关闭newfd。

之前提到的fcntl函数的F_DUPFD参数是复制文件描述符的另一种方法：

newfd = fcntl(oldfd, F_DUPFD,startfd);

### 在文件特定处的IO

pread和pwrite函数基本操作与read和write类似，但是前两个函数会在offset参数指定的位置进行IO操作，而后两个函数是在文件的当前偏移量处开始IO操作。

这两个函数不会改变问文件的当前偏移量。

一个pread函数相当于以下一个步骤合为一个原子操作：

- 获取文件当前偏移量 off_t orig = lseek(fd, 0,SEEK_CUR);
- 将文件当前偏移量改为offset参数的值lseek(fd,offset,SEEK_SET);
- 进行read操作 s=read(fd,buf,len);
- 回复原来的文件当前偏移量 lseek(fd,orig,SEEK_SET);

对于pread和pwrite函数fd所指代的文件必须是可定位的，即允许对文件描述符执行lseek函数。

这两个函数不会受到文件当前偏移量的影响，所以适合应用在多线程程序中。



### 分散输入和集中输出

readv和writev函数分别实现分散输入和集中输出。

```c
#include<sys/uio.h>

ssize_t readv(int fd, const struct iovec *iov, int iovcnt);

ssize_t writev(int fd, const struct iovec* iov, int iovcnt);

// 其中iovec结构体如下：
struct iovec{
  void *iov_base; // 缓冲区首地址
  size_t iov_len; // 缓冲区字节数
};
```

这些系统调用一次对多个换成区进行读写。

#### 分散输入：

从文件向缓冲区输入。从fd所指的文件中读取一片连续的字节，然后将其散置在iov参数指定的缓冲区域中，这一动作从iov[0]开始，依次填满每个缓冲区。



#### 集中输出：

将iov指定的所有缓冲区中的数据拼接成连续的字符串写入到fd指代的文件中。

这两个函数也都是原子操作。

#### 指定文件偏移量的分散输入与集中输出

preadv和pwritev函数，就是pread与readv的结合以及pwrite与writev的结合。



### 截断文件

truncate和ftruntcate将文件大小设置为参数length指定的值。

```c
#include<unistd.h>
int truncate(const char *pathname, off_t length);
int ftruncate(int fd, off_t length);
```

truncate无需open就可以修改问价内容。



### 大文件IO

文件偏移量off_t是一个有符号长整型，则在32位体系架构中，将文件大小限制在(2\^31)-1个字节即2GB。

为了突破这个限制，unix联盟在LFS上指定了一些规范。

要访问大文件，可以使用这些函数的64位版本的。在原函数名后加上64就表示64版本的，但要将_FILE_OFFSET_BITS宏定义为64.

### 创建临时文件

mkstemp和tmpfile两个函数。