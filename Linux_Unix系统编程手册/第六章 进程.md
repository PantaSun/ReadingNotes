### 进程和程序

进程是由内核定义的抽象的实体，并为该实体分配用以执行程序的各项系统资源。

程序是包含了一系列信息的文件，这些信息描述了如何在运行时创建一个进程，包含信息有：

- 二进制格式标识
- 机器语言指令
- 程序入口地址
- 数据
- 符号表及重定位表
- 共享库和动态链接信息
- 其他信息



从内核的角度看，进程由用户空间和一些列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态的信息。



### 进程号和父进程号

每个进程都有一个进程号PID，进程号是一个正整数，用来唯一标识系统中某个进程。

进程号在很多时候作为参数传入函数，用以操作进程。可以通过getpid函数来获取当前进程的ID。

```c
#include<unistd.h>
// 总是成功返回当前进程ID
pid_t getpid(void);
```

linux内核限制进程号需要小于32767.



每个进程都有一个创建自己的父进程。使用系统调用getppid函数可以查看父进程ID号

```c
#include<unistd.h>
// 总是成功返回父进程ID
pid_t getppid(void);
```

如果一个进程的父进程终止，那么这个进程就会成为孤儿进程，这是init进程就会收养这个孤儿。init就是1号进程，是所有进程的始祖。



### 进程内存布局

每个进程所分配的内存可以分成多个段segment：

- 文本段：程序机器指令
- 初始化数据段：显示初始化的全局变量和静态变量
- 未初始化数据段：未显示初始化的全局变量和静态变量，称为 BSS段
- 栈：一个动态增长和收缩的段，由栈帧组成。
- 堆：可在运行时动态进行内存分配的一块区域。

在大多数Unix实现（包括Linux）中c语言编程环境提供了3个全局符号：etext、edata、end，可在程序内使用这些符号以获取相应的程序文本段、初始化数据段和非初始化数据段结尾处下一字节的地址。



### 虚拟内存管理

更加详细介绍见操作系统笔记



### 栈和栈帧

在x86-32体系架构中，栈驻留在内存的高位并向下增长（内存方向从上到下地址依次降低，即4GB-0）。

栈顶使用专用寄存器栈指针来进行跟踪，每当调用函数时会在栈上分配一帧，即栈顶向下移动，每当函数返回时再从栈上移除此栈帧。

#### 每个栈帧包含的信息

- 函数实参和局部变量
- 函数调用的链接信息



### 命令行参数

每个c语言程序都会有一个main函数作为入口函数，即作为程序启动的起点。

命令行参数会通过两个参数提供给main函数：

- 第一个参数 int argc，表示命令行参数的个数
- 第二个参数 char *argv[]，指向命令行参数的指针数组，每个参数是用null空字符结尾的字符串。
  - 第一个字符串argv[0] 是改程序的名称



### 环境列表

每个进程都有一个与之相关的名字为环境列表的字符串数组。每个字符串是用名称=值（name=value）的方式定义。

一般称列表中的这些名称为环境变量。

新进程在创建时，会继承父进程的环境副本。这是一种原始的进程间通信的方式。

环境提供了将信息从父进程传递到子进程的方法。

但是这个进程间通信是单向的、一次性的：即只有在创建子进程时才会获取其父进程的副本。

子进程创建完毕后，父子进程各自修改自己的环境副本互相都不会影响。



大多数shell使用export命令向环境中添加变量值。

```shell
$ SHELL=/bin/bash
$ export SHELL
```

上述命令可以把一个值永久地添加到环境中，此后该shell创建的所有子进程都将继承此环境（shell关闭后重新打开shell该变量消失）。

可以使用unset命令撤销这个环境变量。

printenv命令可以显示当前环境列表。



#### 在程序中访问环境

在c中可以使用char\*\*environ 访问环境列表。若要使用需要先使用extern char \*\*environ;语句进行声明。

getenv函数可以根据变量名返回对应值。

```c
#include<stflib.h>
// 成功返回对应值，若变量名不存在则返回NULL
char * getenv(const char*name);
```

putenv函数向环境中添加一个新变量或者修改现有变量值。成功返回0，失败返回非0值。

### 执行非局部跳转

就是跳转到当前执行函数之外的某个位置，使用库函数setjmp和longjmp。

