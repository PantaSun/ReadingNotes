#### 为什么系统调用会需要很多时间？

内核位于系统空间，磁盘只能被内核直接访问。程序要读取磁盘上的数据就只能通过系统调用read，而read的代码在内核中，所以在read调用发生时，执行权会从用户代码转移到内核代码，执行内核代码是需要时间的。

系统调用的开销吧仅仅是因为要传输数据，当运行内核代码时，cpu工作在管理员模式。当系统调用返回时，cpu工作中用户模式。这种模式切换也很耗时间。

#### 自己写的who命令的低效

自己写的who命令是循环的去utmp中读取一条记录，就相当于煎鸡蛋，每次去超市买一个鸡蛋，煎好后再去超市买一个，这样做明显很低效，因为完全可以一次买十几二十个鸡蛋放在家中的篮子里。“去超市”就相当于调用系统函数读取数据，“家中的篮子”就相当于缓冲区。因此，对于who命令而言，可以一次读入多个记录放在缓冲区内。

#### 关于linux下 read/write函数的一个注意事项

> read函数从打开的设备或文件中读取数据。
> `#include <unistd.h>  ssize_t read(int fd, void *buf, size_t count); `
>
> 返回值：成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0
>
> 参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，**同时文件的当前读写位置向后移**。注意这个读写位置和使用C标准I/O库时的读写位置有可能不同，这个读写位置是记在内核中的，而使用C标准I/O库时的读写位置是用户空间I/O缓冲区中的位置。
>
> 作者：落雪无痕 
> 来源：CSDN 
> 原文：https://blog.csdn.net/zzzzcw/article/details/60132550 
> 版权声明：本文为博主原创文章，转载请附上博文链接！

#### 内核缓冲技术

内核中也有一块缓冲区，当用户需要从磁盘读取数据时，内核一般不直接读取磁盘，而是将内核换成区数据复制到进程缓冲区。

当进程所需的数据不在缓冲区时，内核会把相应的数据加载到请求数据列表，然后把该线程挂起，接着为其他进程服务。

理论上内核可以随时写磁盘，但是并不是所有的write都会导致内核的写动作。内核会把要写的数据暂时放在缓冲区，积累到一定量后再一次写入。



#### 文件当前位置

Unix每次打开一个文件都会保存一个指针来记录文件的当前位置。

可以使用`lseek`函数来修改已打开文件的当前位置。

- 头文件：`sys/type.h` 和 `unistd.h`
- 函数原型：`off_t oldpos = lseek(int_fd, off_t dist, int base)`
- 参数：
  - fd：文件描述符
  - dist：移动的距离
  - base：移动的基准位置
    - SEEK_SET：表示文件的开始
    - SEEK_CUR：当前位置
    - SEEK_END：文件末尾
- 返回值：
  - -1：表示发生错误
  - oldpos：指针变化前的位置

