##### 切换图像界面和字符界面

- 在字符界面里通过Ctr+alt+[f7]切换到图形界面，或者startx命令进入；
- 在图形界面里通过Ctr+alt+[f1~f6]切换到文字界面。

#### 为什么系统调用会需要很多时间？

内核位于系统空间，磁盘只能被内核直接访问。程序要读取磁盘上的数据就只能通过系统调用read，而read的代码在内核中，所以在read调用发生时，执行权会从用户代码转移到内核代码，执行内核代码是需要时间的。

系统调用的开销仅仅是因为要传输数据，当运行内核代码时，cpu工作在管理员模式。当系统调用返回时，cpu工作中用户模式。这种模式切换也很耗时间。

#### 自己写的who命令的低效

自己写的who命令是循环的去utmp中读取一条记录，就相当于煎鸡蛋，每次去超市买一个鸡蛋，煎好后再去超市买一个，这样做明显很低效，因为完全可以一次买十几二十个鸡蛋放在家中的篮子里。“去超市”就相当于调用系统函数读取数据，“家中的篮子”就相当于缓冲区。因此，对于who命令而言，可以一次读入多个记录放在缓冲区内。

#### 关于linux下 read/write函数的一个注意事项

> read函数从打开的设备或文件中读取数据。
> `#include <unistd.h>  ssize_t read(int fd, void *buf, size_t count); `
>
> 返回值：成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0
>
> 参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，**同时文件的当前读写位置向后移**。注意这个读写位置和使用C标准I/O库时的读写位置有可能不同，这个读写位置是记在内核中的，而使用C标准I/O库时的读写位置是用户空间I/O缓冲区中的位置。
>
> 作者：落雪无痕 
> 来源：CSDN 
> 原文：https://blog.csdn.net/zzzzcw/article/details/60132550 
> 版权声明：本文为博主原创文章，转载请附上博文链接！

#### 内核缓冲技术

虽然内核模式和用户模式的切换会消耗一定的时间，但是磁盘的I/O操作耗时更多，因此为了提高效率，内核也使用缓冲技术。

内核中也有一块缓冲区，当用户需要从磁盘读取数据时，内核一般不直接读取磁盘，而是将内核换成区数据复制到进程缓冲区。

当进程所需的数据不在缓冲区时，内核会把相应的数据加载到请求数据列表，然后把该线程挂起，接着为其他进程服务。然后在一段很短的时间之后内核会把相应的数据从磁盘读到内核缓冲区内，然后拷贝到进程的缓冲区内，最后唤起挂起的线程。

理论上内核可以随时写磁盘，但是并不是所有的write都会导致内核的写动作。内核会把要写的数据暂时放在缓冲区，积累到一定量后再一次写入。



#### 文件当前位置

Unix每次打开一个文件都会保存一个指针来记录文件的当前位置。read从当前位置读入指定长度的数据，然后指针向后移动写入数据的长度。

如果有两个程序打开了同一文件，那么每个程序都会有个记录当前位置的指针。因此这两个程序的读操作互不影响。

可以使用`lseek`函数来修改已打开文件的当前位置。

- 头文件：`sys/type.h` 和 `unistd.h`
- 函数原型：`off_t oldpos = lseek(int_fd, off_t dist, int base)`
- 参数：
  - fd：文件描述符
  - dist：移动的距离
  - base：移动的基准位置
    - SEEK_SET：表示文件的开始
    - SEEK_CUR：当前位置
    - SEEK_END：文件末尾
- 返回值：
  - -1：表示发生错误
  - oldpos：指针变化前的位置



#### 系统调用中的错误

在调用系统函数时发生错误在所难免，因此在编写程序时凡是用到系统函数都应该进行错误检查，一旦检查到错误就要针对错误做出相应的处理。

内核通过errno这个全局变量来确定错误类型，每个程序都可以访问这个全局变量。

可以通过perror函数来显示错误信息。

