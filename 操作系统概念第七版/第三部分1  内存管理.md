---
title: 第三部分1 内存管理
date: 2019-03-23 11:20:45
tags: 
- 操作系统
categories:
- Reading notes
- 总结
---

## 基础

#### 主存

主存储器（检查内存或主存）是计算机系统中一个主要部件，用于保存进程运行时的程序和数据。

#### 高速缓存

由于主存的访问速度远低于CPU执行指令的速度，为缓和这一矛盾，在计算机系统中引入了寄存器和高速缓存。

#### 地址空间

要是多个程序同时处于内存中并且互不影响，需要解决两个问题：保护和重定位。

一个实现保护的比较好的个方法就是创造一个新的存储抽象：地址空间。就像进程的概念创造了一类抽象的CPU以运行程序一样，地址空间为程序创造了一种抽象的内存。

地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间。

### 地址绑定

在程序执行前，需要经过预处理、编译、汇编和链接才能成为可执行文件，而可执行文件要进入内存执行还需要"加载"这一步骤。

在上述这些步骤中，地址可能有不同的表现形式。

在源代码中，地址一般都是用符号来表示的。编译器通常会把这些符号地址绑定在可重定位的地址（这种地址一般是相对本模块开始地址的偏移量，会跟着模块位置的变化而变化）

#### 重定位的时机

指令与数据绑定到内存地址一般有三种情况：

- 编译时（绑定）：就是在编译时就知道进程将在内存中的驻留地址，就直接生产绝对代码。
- 加载时（绑定）：如果不知道进程将要驻留在内存的什么位置，那么编译器就必须生成可重定位代码。于是地址绑定就延迟到加载时才进行。
- 执行时（绑定）：如果进程在执行时可以从一个内存段移到另一个内存段，那么绑定必须延迟到执行时才进行。这种情况叫做动态重定位。

#### 逻辑地址与物理地址

- 逻辑地址是逻辑上的地址，是相对的地址或者是虚拟地址
- 物理地址是实际内存上的地址，是绝对的地址或是实地址。

在编译时绑定和加载时绑定这两种情况中，内存中的代码中的地址是物理地址。

在执行时绑定的情况中，内存中的代码中的地址是逻辑地址不等于物理地址，只有在执行到该代码时才会转换为物理地址。

运行时从虚拟地址到物理地址的映射是由称为内存管理单元（memory-management unit，MMU）的硬件设备来完成的。

### 动态加载

一个子程序只有在调用时才被加载。所有子程序都以可重定位的形式保存在磁盘上。这样做提高内存空间的利用率。

动态加载的优点是不用的子程序绝不会被加载。

这里使用的重定位是动态重定位。

动态加载不需要操作系统提供特别的支持。

### 动态链接

与动态加载类似，就是将链接延迟到运行时起。这里通常应用与系统库，如果没有这个动态链接，那么系统上的所有程序（在需要时）都必须含有一个系统某个库的副本，这样就浪费了磁盘可内存的空间。

使用动态链接后，二进制镜像中对每个程序库的引用都有一个存根。存根是一小段代码，用来指出如何定位适当的内存驻留程序库，或如果该库不在内存时应该如何装入库。这样使用系统库的所有进程只需要一个代码库副本就可以了。

动态链接通常需要操作系统的帮助。因为内存中进程是彼此保护的，只有操作系统才有权检查所需的子程序是否在其他进程中，或是允许多个进程访问同一内存地址。

## 交换技术

一般来说，如果计算机系统的物理内存足够大，那么就可以将所有运行的进程都保存在内存中，但实际中并不是这样的。实际中的内存大小是有限的，但是有些进程的程序代码和数据加在一起就需要很大的空间，甚至是大于物理内存的空间，这样就产生了内存超载。要解决内存超载有两种通用的方法：

- 交换技术：所谓交换就是将内存中暂时不能运行的进程或暂时不用的进程和数据调出到外存，以便于腾出空间，再把已经具备运行条件的进程或进程所需的数据调入内存。
- 虚拟内存：后面再讨论

交换技术中使用快速磁盘作为备份存储。其容量必须足够大，以便于容纳所有用户的内存镜像副本，也必须提供给对这些内存镜像的直接访问。

交换技术也受其他因素限制：比如有待处理IO的进程不应该被换出，因为一个属于旧进程的IO操作可能是图使用现在已经属于新进程的内存空间。对于这个问题可以有两种解决方案：

1. 不允许换出有待处理IO的进程。
2.  IO操作只能使用操作系统缓冲区。近当换入进程后，才执行操作系统缓冲与进程内存之间的数据交换。



## 连续内存分配



### 固定分区分配法

#### 等大：

- 比空间小的程序浪费空间
- 比空间大的程序无法运行

#### 非等大

- 也会造成空间浪费



### 动态分配

#### 分区分配中的数据结构

为了实现分区分配，系统中必须设置相应的数据结构，来描述空闲分区和已分配分区。

一般有两种方式：

- 空闲分区表：用表格的方式记录空闲分区情况。表项包括：分区号、起始地址、分区大小以及是否已经分配。
- 空闲分区链：在空闲区间起始位置，设置一个前向指针和用于控制分区分配的信息；在分区末尾设置一个后项指针。这样使用双向链表的方式将所有空闲分区链接起来。

在可变分区方案中，操作系统有一个表，用于记录那些内存可用和哪些内存已经被占用。

一开始左右内存都可用于用户进程，因此可以作为一大块可用内存，称为孔（hole）。

#### 分区分配方法

1. First-Fit（首次适应）：分配第一个足够大的孔。
2. Best-fit（最佳适应）：分配最小的足够大的孔。
3. Worst-fit（最差适应）：分配最大的孔。

测试表明，最佳适应和首次适应在执行时间和利用空间等方面都好于最差适应。

#### 内存回收

有四种情况：

1. 回收区与前一个空闲区间临接且与后一个非空闲区间临接，则将回收区合并到前一个空闲区间
2. 回收区与后一个空闲区间临接且与前一个非空闲区间临接，则将后一个空闲区间合并到本回收区
3. 回收区前后临接的都是空闲区间，则这三个区间合并成一个空闲区间，即后两个区级合并到第一个区间
4. 回收区前后都是非空闲区间，则回收区自己形成一个空闲区间。

### 内存碎片

随着进程的装入和移出内存，空闲内存空间被分成小片段，且这些小片段由于太小很多都无法再装入进程。这种不能再内利用的小分区被称为碎片。

- 外碎片：分区之外的碎片称为外碎片。
- 内碎片：一个分区之内未分配的空间。例如固定分区中，由于分区大小已经固定，但是进程所占用的空间小于分区大小，这时分区剩余的空间就是内碎片。

### 内存紧缩（整理内存碎片）

就是将内存中的碎片移动到一起拼接成一个大分区。因为碎片移动也就相当于内存中的进程需要移动，进程中代码和数据的地址也就发生了变化，所以肯定不适用于静态链接和静态加载。

为了使用内存紧缩，要使用动态链接和动态加载。

整理的时机。

## 分页（离散内存分配）

现代操作系统离散内存分配居多。 

### 页面

#### 页面和页框（物理块）

把一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。并为各页加以编号，从0开始编号。

把内存空间分成与页面相同大小的若干个储存块，称为（物理）块或页框（frame），同样也从0开始编号。

进程在加载到内存时，会以块为单位将进程中的若干个页分别装入到多个可以不相临接的物理块中。

进程的最后一页一般来说是装不满的，因此这也就产生了内碎片。

#### 页面大小

页面大小要适中，如果太小，虽然可以使碎片减小，提高内存利用率，但是会使每个进程占用较多页，从而导致页表过长，占用大量内存。此外，还会降低页面换进换出的效率。

如果太大，虽然可以减少页表的长度，提高页面换进换出的效率，但又会增加总的内碎片的大小。

所以页面通常是2的幂。

### 地址结构

分页地址中的地址结构：

| 31～12 | 11～0       |
| ------ | ----------- |
| 页号P  | 页内偏移量d |

若给定一个逻辑地址A，页面的大小为L，则页号P和页内地址d可由下列公式求出：

$$P = int[ A/L],  d= A \% L $$

即P是A除以L得到舍去小数的整数，d是A除以L的余数。



### 页表

系统为每个进程建立一张页面映射表，简称为页表。逻辑地址中的所有页依次在页表中有一页表项，其中记录了相应页在内存中对应的物理块号。于是进程执行时，通过查找该表，即可找到每个页在内存中的物理块号。

页表的表项中也设有存取控制字段，用于对该存储块中的内容加以保护。

### 硬件支持

页表相对比较大，不适合放在寄存器中，因此将页表存放在内存中，并将页表基寄存器（page-tabel base register，PTBR）指向页表。该表页表只需要改变PTBR就可以了。进程未执行时，页表的起始地址和页表长度存放在本进程的PCB中。

当进程访问某个逻辑地址时，分页地址变换机构将逻辑地址分为页号和页内地址两部分，再以页号为索引去检索页表。查找由硬件执行，在查找之前，将页号与页表长度相比，若页号大于页表长度，就会触发越界中断。若未超过页表长度，则用页号乘以页表表项的长度加上页表初始地址得到该表项的物理地址。随后根据物理地址从内存中取出该页的物理块号，再结合页内地址最终得到所要访问数据的物理地址。

页表在查询时，需要去内存中查询，这样会使内存的访问速度减半（本来只需要根据物理地址去内存取数据即可，现在多了一次查询页表的访问）。位了解决这个问题，增加了一个小但专用且快速的硬件缓冲—转换表缓冲区（translation look-aside buffer，TLB）也称为快表。

因为硬件比较昂贵，TLB中也不会存放太多的页表。



### 两级页表

一级页表存在的问题：现代计算机支持非常大的逻辑地址空间。在这种情况下，页表就非常大，要占用非常大的内存空间，而在内存中拿出一整块的空间来放页表是不现实的

解决方法：

1. 采用离散的方式来存放页表，这样就解决了难以找到一块连续的大内存空间的问题。
2. 只将当前需要的部分页表项调入内存，其余的表项仍驻留在磁盘上，需要时再调入。

第一个方法就是可以采用两级页表，就是将页表也进行分页，这样就可以将原来的页表离散开，放在不同的物理块中。这样为页表建立的页表称为外层页表。外层页表的页表项中记录了页表页面的物理块号。



## 分段

虽然引入分页能偶提高内存利用率，但是分页有一个不可避免的问题：用户视角的内存和实际物理内存的分离。

因此引入分段基址，分段基址可以带来一系列的好处：

- 方便编程：程序猿可以按照自己的逻辑将代码划分成若干个段，每个段都从0开始编址
- 便于信息共享：分页中的每个页只是将代码在物理上分块，每一个块没有实际意义。而分段，每一段都是逻辑上分块，每块都有实际意义，便于共享。
- 信息保护：道理同上，信息保护是对信息的逻辑单位进行保护的
- 动态增长：分页中的页是固定大小的，无法应对数据的动态增长，而分段存储可以解决这一问题
- 动态链接：就是在运行时，需要某个段才将该段调入内存并进行链接。

### 基本原理

#### 分段

在分段机制中，作业被划分成若干个逻辑段，如主程序段、数据段、栈段等。这些段用段号来表示，从0开始编号。