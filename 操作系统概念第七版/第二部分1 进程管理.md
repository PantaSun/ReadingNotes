[TOC]

## 基本概念

### 进程的概念

要想说明进程的概念，要先说明程序的概念：程序是指按某种方式组合形成的代码和数据集合，是一种静态的概念。而进程简单来说就是运行的程序，更确切的说，进程是具有独立功能的一个关于某个数据集合的以次运行活动，是一个动态的概念。

#### 进程的两个基本属性

- 进程是一个可拥有资源的独立单位
- 进程同时又是一个可独立调度和分派的基本单位

#### 程序与进程的区别

- 程序是一个静态的概念，进程是动态的
- 程序的存在是永久的，进程有生命周期
- 进程 = 程序 + 数据 + PCB
- 一个程序可以对应多个进程
- 一个进程可以包含多个程序

### 进程的状态

**进程有三种基本状态：**

- 运行态：就是该进程此刻占用CPU
- 就绪态：可运行，但因为其它进程正在运行而暂时停止。出现这种情况的主要是由系统设计造成的因为只有一个CPU，所以不能让一个进程一直占用CPU，这样会降低CPU的利用率。
- 阻塞态：程序自身挂起，需要某种外部事件来促进进程继续运行，如等待键盘输入。

**这三种状态有四种转换关系：**

- 一个正在运行的进程A因为程序需要而不能继续执行下去时就进入阻塞状态
- 一个正在运行的进程A因为被优先级高的进程B抢占CPU或者调度程序认为进程A已经使用足够长时间的CPU于是去调度其他进城从而使该程序A进入就绪状态
- 一个处在就绪状态的进程A被调度程序选中从而进入运行状态
- 一个处在阻塞状态的进程A接收到某个数据或经过某种事件触发进入到就绪状态，若目前没有正在运行的进程，该进程马上就从就绪转为运行。

**其实还有新建和终止两种状态。**

- 新建状态：进程正在创建状态。第一步为一个新进程创建PCB，并填写必要的管理信息；第二步将该进程转入到就绪状态并插入到就绪队列之中。
- 终止状态：等待操作系统善后工作，将PCB清零，并将PCB空间返还给系统。进入终止状态后不能执行，但在操作系统中还保留一个记录，保存状态码和一些计时统计数据，供其他进程收集，一旦其他进程收集完毕，操作系统就删除该进程。



### 进程的实现

操作系统会维持一张进程表，每一个进程占用表中的一个个表项。表项落实到代码中就是结构体。表项也称为进程控制块（process control block，PCB）。

PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。PCB包含了进程执行过程中的所有信息，系统是通过PCB来感知进程的存在，  因此PCB是进程存在的唯一标志。

**程序段、相关的数据段和PCB三部分就构成了进程实体。**

#### PCB中的信息

存放进程的管理和控制信息的数据结构称为进程控制块。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。

在不同的操作系统中对进程的控制和管理机制不同，PCB中的信息多少也不一样，通常PCB应包含如下一些信息。

- 1、进程标识符PID：每个进程都必须有一个唯一的标识符，可以是字符串，也可以是一个数字。UNIX系统中就是一个整型数。在进程创建时由系统赋予。
- 2、进程当前状态 status：说明进程当前所处的状态。为了管理的方便，系统设计时会将相同的状态的进程组成一个队列，如就绪进程队列，等待进程则要根据等待的事件组成多个等待队列，如等待打印机队列、等待磁盘I/O完成队列等等。
- 3、进程相应的程序和数据地址，以便把PCB与其程序和数据联系起来。
- 4、进程资源清单。列出所拥有的除CPU外的资源记录，如拥有的I/O设备，打开的文件列表等。
- 5、进程优先级 priority：进程的优先级反映进程的紧迫程序，通常由用户指定和系统设置。UNIX系统采用用户设置和系统计算相结合的方式确定进程的优先级 。
- 6、CPU现场保护区 cpustatus：当进程因某种原因不能继续占用CPU时（等待打印机），释放CPU，这时就要将CPU的各种状态信息保护起来，为将来再次得到处理机恢复CPU的各种状态，继续运行。
- 7、进程同步与通信机制 用于实现进程间互斥、同步和通信所需的信号量等。
- 8、进程所在队列PCB的链接字
  根据进程所处的现行状态，进程相应的PCB参加到不同队列中。PCB链接字指出该进程所在队列中下一个进程PCB的首地址。
- 9、与进程有关的其他信息。 如进程记账信息，进程占用CPU的时间等。

#### PCB的组织方式

- 连接方式：根据进程状态，将处在相同状态进程的PCB使用PCB中的连接字链接成一个队列。这样就可以形成就绪队列、若干个阻塞队列和空白队列
- 索引方式：根据所有进程的状态建立几张索引表：就绪索引表、阻塞索引表等。



### 进程的调度

进程调度就是选择一个可用的进程到CPU上执行。

**长期（作业）调度程序：**从存放进程的大容量存储设备中选取进程装入到内存中以备执行。长期调度程序控制多道程序设计的程度（也就是内存中进程的数量），又称高级调度。

**短期（CPU）调度程序：**从上述的准备执行的进程中选择进程，并为之分配CPU，又称低级调度。

**还有一种中期调度程序：**核心思想就是把一些进程从内存中移出，从而降低多道程序设计的程度。之后，该进程也能被重新调入内存，并从中断出继续执行，又称中程调度。提高内存利用率和系统吞吐量。

#### 上下文切换：

将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务称为上下文切换。



### 进程操作

#### 进程创建

四种主要事件会导致进程的创建：

- 系统初始化
- 正在运行的程序执行了创建进程的系统调用
- 用户请求创建一个进程
- 一个批处理作业的初始化

一般创建新进程都是由一个已经存在的进程执行了一个用于创建新进程的系统调用（Unix中使用fork）来实现的。

这个新进程是调用进程的子进程，因此调用进程就是父进程。

父子进程拥有相同的内存映像、同样的环境字符串以及同样的打开文件。但是他们的地址空间是各自不同的。

子进程随后会执行execve或类似的系统调用以修改其内存影响并运行一个新的程序。

**创建新进程时，两种执行可能：**

- 父子进程并发执行
- 父进程等待，直到某个子进程或全部子进程执行完毕

**新进程地址空间中的内容**

- 子进程是父进程的复制品，即具有与父进程相同的程序和数据
- 子进程装入另一个程序

**PID**

在Unix系统中，每个进程有一个唯一的非负整数作为进程的标识符，即PID。使用fork函数可一创建一个新进程。新进程复制原来进程的地址空间。这样就允许父子进程之间方便的通信。父子进程都继续执行fork函数之后的代码。对于新进程，fork返回值为0；对于原进程，返回值为子进程的进程标示符（非零）。通常在fork之后，一个进程会使用系统调用exec，以新程序取代进程的内存空间。

#### 进程终止

当进程终止就是进程完成最后的语句并使用系统调用exit请求操作系统删除自身时，进程终止。

通常情况下只有进程的父进程才有资格终止本进程。

父进程终止子进程的原因：

- 子进程使用了超过它所分配到的资源时
- 分配给子进程的任务已不再需要时
- 父进程退出，如果父进程退出，一般操作系统是不会允许其子进程继续。



## 进程之间通信

**独立进程：**一个进程不能影响其他进程或被其他进程影响

**协作进程：**与其他进程共享数据的进程为协作进程

### 协作进程的优点

- 信息共享
- 提高运算速度
- 模块化
- 方便

### 进程间通信机制（interprocess communication，IPC）

**三种基本方式：共享内存系统、消息传递系统以及管道通信系统**

#### 几个特点：

- 消息传递适用于交换数据量小的情况，因为不需要避免冲突
- 共享内存允许以最快的速度进行方便的通信，比消息传递快
- 消息传递慢的原因是它需要通过系统调用来实现

### 信号量     
#### 概念
在内核中创建一个信号量集合（本质是个数组），数组的元素（信号量）都是1，使用P操作进行-1，使用V操作+1

1） P(sv)：如果sv的值⼤大于零，就给它减1；如果它的值为零，就挂起该进程的执⾏ 。
2） V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运⾏，如果没有进程因等待sv⽽挂起，就给它加1。
PV操作用于同一进程，实现互斥。
PV操作用于不同进程，实现同步。
#### 功能：
对临界资源进行保护。   


### 共享内存系统

在该系统中，相互通信的进程共享某些数据结构或共享存储区，然后进程之间通过这些空间进行通信。

这里通常会举生产者-消费者设计模式为例子：**生产者**产生信息以供**消费者**消费。

为了允许生产进程和消费进程并发执行，必须设置一个缓冲来被生产者填充并被消费者使用。

**一般有两种缓冲：**

- 有限缓冲：假设缓冲大小固定，这时如果缓冲为空，消费者必须等待；如果缓冲满了，生产者必须等待。
- 无限缓冲：对缓冲大小没有固定限制，生产者可不停的生产，但消费者要在缓冲为空时进行等待。

#### 共享内存也分为两种：

- 基于共享数据结构的通信方式：一般使用有限缓冲区这种数据结构（可以是一个队列或者一个栈），这种方式是低效的，只适用于传递相对少量的数据。这种方式存在两个问题：
  - 无法完整使用队列（针对书中代码）：会剩余一个空位。解决方法是使用计数器，而不使用in和out标示。
  - 存在忙等（busy waiting）问题（针对循环缓冲队列）：当缓冲队列满了的时候，生产者要不停的检查缓冲队列是否有可用为止，若没用，则什么也不执行，这就是忙等。生产者进程一直在就绪和运行队列中来回切换，但在运行时如果处于忙等状态那么就什么也不执行，这就浪费了CPU资源。解决方法就是当队列满了时，将生产者进程切换到阻塞状态，当消费者消费后队列中产生一个可用位置时再给生产者进程发信号，接收到信号后生产者进程切换到就绪状态。
- 基于共享内存的通信方式：在通信之前，进程先向系统申请一个获得一个共享内存区，并指定该分区的关键字；若系统已经给这个进程分配了共享区，就将这个共享区的关键字返回给该进程。



### 消息队列

消息队列是消息的链表，存放在内核中并由消息队列标识符表示。 

消息队列提供了一个从一个进程向另一个进程发送数据块的方法，每个数据块都可以被认为是一个类型，接受者接受的数据块可以有不同的类型。 

但是同管道类似，它有一个不足之处，就是每个消息的最大长度是有上限的(MSGMAX)，每个消息队列的总的字节数(MSGMNB)有限，系统上消息队列的总数也有上限(MSGMNI)。可以用cat /proc/sys/kernel/msgmax查看具体的数据。 

内核为每个IPC对象维护了一个数据结构struct ipc_perm，用于标识消息队列，让进程知道当前操作的是哪个消息队列。每一个msqid_ds表示一个消息队列，并通过msqid_ds.msg_first、msg_last维护一个先进先出的msg链表队列，当发送一个消息到该消息队列时，把发送的消息构造成一个msg的结构对象，并添加到msqid_ds.msg_first、msg_last维护的链表队列。

![](E:\ReadingNotes\操作系统概念第七版\消息队列.png)

#### 特点

- 生命周期随内核，消息队列会一直存在，需要我们显示的调用接口删除或使用命令删除
- 消息队列可以双向通信
- 克服了管道只能承载无格式字节流的缺点

#### 相关函数

##### msgget
功能：创建和访问一个消息队列 
原型：

```
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/types.h>
int msgget(key_t key, int msgflag);
```

参数： 
key：某个消息队列的名字，用ftok()产生 
msgflag：有两个选项IPC_CREAT和IPC_EXCL，单独使用IPC_CREAT，如果消息队列不存在则创建之，如果存在则打开返回；单独使用IPC_EXCL是没有意义的；两个同时使用，如果消息队列不存在则创建之，如果存在则出错返回。 
返回值：成功返回一个非负整数，即消息队列的标识码，失败返回-1

```c
#include <sys/types.h>
#include <sys/ipc.h>
key_t ftok(const char *pathname, int proj_id);

```



调用成功返回一个key值，用于创建消息队列，如果失败，返回-1

##### msgctl
功能：消息队列的控制函数 
原型：

```C
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
int msgctl(int msqid, int cmd, struct msqid_ds *buf);

```


参数： 
msqid：由msgget函数返回的消息队列标识码 
cmd：有三个可选的值，在此我们使用IPC_RMID

IPC_STAT 把msqid_ds结构中的数据设置为消息队列的当前关联值
IPC_SET 在进程有足够权限的前提下，把消息队列的当前关联值设置为msqid_ds数据结构中给出的值
IPC_RMID 删除消息队列
返回值： 
成功返回0，失败返回-1

##### msgsnd
功能：把一条消息添加到消息队列中 
原型：

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
```



参数： 
msgid：由msgget函数返回的消息队列标识码 
msgp：指针指向准备发送的消息 
msgze：msgp指向的消息的长度（不包括消息类型的long int长整型） 
msgflg：默认为0 
返回值：成功返回0，失败返回-1

消息结构一方面必须小于系统规定的上限，另一方面必须以一个long int长整型开始，接受者以此来确定消息的类型

```

struct msgbuf{
     long mtye;
     char mtext[1];
};
```


##### msgrcv
功能：是从一个消息队列接受消息 
原型： 
`ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); `
参数：与msgsnd相同 
返回值：成功返回实际放到接收缓冲区里去的字符个数，失败返回-1

此外，我们还需要学习两个重要的命令 
前面我们说过，消息队列需要手动删除IPC资源 
ipcs: 显示IPC资源 

ipcrm: 手动删除IPC资源 





### 消息传递系统

在该系统中，进程间的数据交换是以格式化的消息为单位的。消息传递工具提供至少两种操作：发送（消息）和接收（消息）。

两个进程之间通信必须需要逻辑上的通信线路。实现方法有：

- 直接或间接通信：
  - 直接：需要通信的每个进程必须明确的命名通信的接收者或发送者。一个线路只与两个进程相关；每对进程之间只有一个线路。线路是在需要通信的两个进程之间自动建立。
  - 间接：通过邮箱或端口来接收发送消息。只有两个进程共享一个邮箱时，才能建立通信线路；一个线路可以与两个或更多的进程相关联；两个通信进程之间可以有多个不同的线路，每个线路对应一个邮箱。
- 同步或异步通信：进程之间的消息可以是阻塞或非阻塞的，也叫同步与非同步。
  - 发送进程阻塞：直到消息被接收进程或邮箱接收
  - 发送进程非阻塞：发送进程发送消息后可继续执行其他操作
  - 接收进程阻塞：直到接收到消息
  - 接收进程非阻塞：接收到一个有效消息或空消息。
- 自动或显示缓冲：通信进程所交换的消息都驻留在临时队列中，队列的实现有三种方法：
  - 零容量：队列最大长度为零，也就是阻塞发送，直到消息送达。这种情况称为没有缓冲的消息系统。
  - 有限容量：队列长度为n，最多有n个消息驻留在队列中。若队列满了，必须阻塞发送直到队列中有可用空间为止。
  - 无限容量：队列长度无限，不用阻塞发送
  - 后两种称为自动缓冲。

### 管道通信

用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件称为“管道”，又叫pipe文件。

管道有两种：匿名管道和命名管道

#### 匿名管道

在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，一般使用fork函数实现父子进程的通信。匿名管道使用pipe()创建。

``` 
int pipe(int pipefd[2]); //成功：0；失败：-1，设置errno
```

函数调用成功返回r/w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。

管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？通常可以采用如下步骤：

![](E:\ReadingNotes\操作系统概念第七版\匿名管道.jpg)

1. 父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。

2. 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。

3. 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。



#### 命名管道FIFO

在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，没有血缘关系的进程也可以进程间通信。

创建命名管道的系统函数有两个：mknod和mkfifo。两个函数均定义在头⽂件sys/stat.h，函数原型如下：

```c
#include <sys/types.h>
#include <sys/stat.h>
int mknod(const char *path,mode_t mod,dev_t dev);
int mkfifo(const char *path,mode_t mode);
```

函数mknod参数中path为创建的命名管道的全路径名：mod为创建的命名管道的模式，指明其存取权限；dev为设备值，该值取决于⽂件创建的种类，它只在创建设备⽂件时才会⽤到。这两个函数调⽤成功都返回0，失败都返回－1。

##### 特点

1. FIFO可以在无关的进程之间交换数据，与无名管道不同。
2. FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中



#### 其他

管道机制必须提供三个方面的协调能力：

- 互斥：当一个进程对pipe文件读写时，另一个进程必须等待
- 同步：当写进程写完后便去睡眠等待，直到读进程读走数据后才换行；当读进程读一个空pipe时也应该睡眠等待，直到写进程写入数据后唤醒。
- 只有确定了对方已经存在时，才可以进行通信。

其他特点：

- 面向字节流
- 生命周期随内核
- 半双工，单向通信，两个管道实现双向通信。

###   信号（signal）：

信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的  。