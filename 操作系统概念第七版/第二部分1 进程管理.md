## 基本概念

### 进程的概念

要想说明进程的概念，要先说明程序的概念：程序是指按某种方式组合形成的代码和数据集合，是一种静态的概念。而进程简单来说就是运行的程序，更确切的说，进程是具有独立功能的一个关于某个数据集合的以次运行活动，是一个动态的概念。

#### 进程的两个基本属性

- 进程是一个可拥有资源的独立单位
- 进程同时又是一个可独立调度和分派的基本单位

#### 程序与进程的区别

- 程序是一个静态的概念，进程是动态的
- 程序的存在是永久的，进程有生命周期
- 进程 = 程序 + 数据 + PCB
- 一个程序可以对应多个进程
- 一个进程可以包含多个程序

### 进程的状态

**进程有三种基本状态：**

- 运行态：就是该进程此刻占用CPU
- 就绪态：可运行，但因为其它进程正在运行而暂时停止。出现这种情况的主要是由系统设计造成的因为只有一个CPU，所以不能让一个进程一直占用CPU，这样会降低CPU的利用率。
- 阻塞态：程序自身挂起，需要某种外部事件来促进进程继续运行，如等待键盘输入。

**这三种状态有四种转换关系：**

- 一个正在运行的进程A因为程序需要而不能继续执行下去时就进入阻塞状态
- 一个正在运行的进程A因为被优先级高的进程B抢占CPU或者调度程序认为进程A已经使用足够长时间的CPU于是去调度其他进城从而使该程序A进入就绪状态
- 一个处在就绪状态的进程A被调度程序选中从而进入运行状态
- 一个处在阻塞状态的进程A接收到某个数据或经过某种事件触发进入到就绪状态，若目前没有正在运行的进程，该进程马上就从就绪转为运行。

**其实还有新建和终止两种状态。**

- 新建状态：进程正在创建状态。第一步为一个新进程创建PCB，并填写必要的管理信息；第二步将该进程转入到就绪状态并插入到就绪队列之中。
- 终止状态：等待操作系统善后工作，将PCB清零，并将PCB空间返还给系统。进入终止状态后不能执行，但在操作系统中还保留一个记录，保存状态码和一些计时统计数据，供其他进程收集，一旦其他进程收集完毕，操作系统就删除该进程。



### 进程的实现

操作系统会维持一张进程表，每一个进程占用表中的一个个表项。表项落实到代码中就是结构体。表项也称为进程控制块（process control block，PCB）。

PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。PCB包含了进程执行过程中的所有信息，系统是通过PCB来感知进程的存在，  因此PCB是进程存在的唯一标志。

**程序段、相关的数据段和PCB三部分就构成了进程实体。**

#### PCB中的信息

存放进程的管理和控制信息的数据结构称为进程控制块。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。

在不同的操作系统中对进程的控制和管理机制不同，PCB中的信息多少也不一样，通常PCB应包含如下一些信息。

- 1、进程标识符PID：每个进程都必须有一个唯一的标识符，可以是字符串，也可以是一个数字。UNIX系统中就是一个整型数。在进程创建时由系统赋予。
- 2、进程当前状态 status：说明进程当前所处的状态。为了管理的方便，系统设计时会将相同的状态的进程组成一个队列，如就绪进程队列，等待进程则要根据等待的事件组成多个等待队列，如等待打印机队列、等待磁盘I/O完成队列等等。
- 3、进程相应的程序和数据地址，以便把PCB与其程序和数据联系起来。
- 4、进程资源清单。列出所拥有的除CPU外的资源记录，如拥有的I/O设备，打开的文件列表等。
- 5、进程优先级 priority：进程的优先级反映进程的紧迫程序，通常由用户指定和系统设置。UNIX系统采用用户设置和系统计算相结合的方式确定进程的优先级 。
- 6、CPU现场保护区 cpustatus：当进程因某种原因不能继续占用CPU时（等待打印机），释放CPU，这时就要将CPU的各种状态信息保护起来，为将来再次得到处理机恢复CPU的各种状态，继续运行。
- 7、进程同步与通信机制 用于实现进程间互斥、同步和通信所需的信号量等。
- 8、进程所在队列PCB的链接字
  根据进程所处的现行状态，进程相应的PCB参加到不同队列中。PCB链接字指出该进程所在队列中下一个进程PCB的首地址。
- 9、与进程有关的其他信息。 如进程记账信息，进程占用CPU的时间等。

#### PCB的组织方式

- 连接方式：根据进程状态，将处在相同状态进程的PCB使用PCB中的连接字链接成一个队列。这样就可以形成就绪队列、若干个阻塞队列和空白队列
- 索引方式：根据所有进程的状态建立几张索引表：就绪索引表、阻塞索引表等。



### 进程的调度

进程调度就是选择一个可用的进程到CPU上执行。

长期（作业）调度程序：从存放进程的大容量存储设备中选取进程装入到内存中以备执行。长期调度程序控制多道程序设计的程度（也就是内存中进程的数量）

短期（CPU）调度程序：从上述的准备执行的进程中选择进程，并为之分配CPU。

还有一种中期调度程序：核心思想就是把一些进程从内存中移出，从而降低多道程序设计的程度。之后，该进程也能被重新调入内存，并从中断出继续执行。

#### 上下午切换：

将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务称为上下文切换。



### 进程操作

#### 进程创建

四种主要事件会导致进程的创建：

- 系统初始化
- 正在运行的程序执行了创建进程的系统调用
- 用户请求创建一个进程
- 一个批处理作业的初始化

一般创建新进程都是由一个已经存在的进程执行了一个用于创建新进程的系统调用（Unix中使用fork）来实现的。

这个新进程是调用进程的子进程，因此调用进程就是父进程。

父子进程拥有相同的内存映像、同样的环境字符串以及同样的打开文件。但是他们的地址空间是各自不同的。

子进程随后会执行execve或类似的系统调用以修改其内存影响并运行一个新的程序。

**创建新进程时，两种执行可能：**

- 父子进程并发执行
- 父进程等待，直到某个子进程或全部子进程执行完毕

**新进程地址空间中的内容**

- 子进程是父进程的复制品，即具有与父进程相同的程序和数据
- 子进程装入另一个程序

**PID**

在Unix系统中，每个进程有一个唯一的非负整数作为进程的标识符，即PID。使用fork函数可一创建一个新进程。新进程复制原来进程的地址空间。这样就允许父子进程之间方便的通信。父子进程都继续执行fork函数之后的代码。对于新进程，fork返回值为0；对于原进程，返回值为子进程的进程标示符（非零）。通常在fork之后，一个进程会使用系统调用exec，以新程序取代进程的内存空间。

#### 进程终止

当进程终止就是进程完成最后的语句并使用系统调用exit请求操作系统删除自身时，进程终止。

通常情况下只有进程的父进程才有资格终止本进程。

父进程终止子进程的原因：

- 子进程使用了超过它所分配到的资源时
- 分配给子进程的任务已不再需要时
- 父进程退出，如果父进程退出，一般操作系统是不会允许其子进程继续。



## 进程之间通信

**独立进程：**一个进程不能影响其他进程或被其他进程影响

**协作进程：**与其他进程共享数据的进程为协作进程

### 协作进程的优点

- 信息共享
- 提高运算速度
- 模块化
- 方便

### 进程间通信机制（interprocess communication，IPC）

**三种基本方式：共享内存系统、消息传递系统以及管道通信系统**

#### 几个特点：

- 消息传递适用于交换数据量小的情况，因为不需要避免冲突
- 共享内存允许以最快的速度进行方便的通信，比消息传递快
- 消息传递慢的原因是它需要通过系统调用来实现



### 共享内存系统

在该系统中，相互通信的进程共享某些数据结构或共享存储区，然后进程之间通过这些空间进行通信。

这里通常会举生产者-消费者设计模式为例子：**生产者**产生信息以供**消费者**消费。

为了允许生产进程和消费进程并发执行，必须设置一个缓冲来被生产者填充并被消费者使用。

**一般有两种缓冲：**

- 有限缓冲：假设缓冲大小固定，这时如果缓冲为空，消费者必须等待；如果缓冲满了，生产者必须等待。
- 无限缓冲：对缓冲大小没有固定限制，生产者可不停的生产，但消费者要在缓冲为空时进行等待。

#### 共享内存也分为两种：

- 基于共享数据结构的通信方式：一般使用有限缓冲区这种数据结构（可以是一个队列或者一个栈），这种方式是低效的，只适用于传递相对少量的数据。这种方式存在两个问题：
  - 无法完整使用队列（针对书中代码）：会剩余一个空位。解决方法是使用计数器，而不使用in和out标示。
  - 存在忙等（busy waiting）问题（针对循环缓冲队列）：当缓冲队列满了的时候，生产者要不停的检查缓冲队列是否有可用为止，若没用，则什么也不执行，这就是忙等。生产者进程一直在就绪和运行队列中来回切换，但在运行时如果处于忙等状态那么就什么也不执行，这就浪费了CPU资源。解决方法就是当队列满了时，将生产者进程切换到阻塞状态，当消费者消费后队列中产生一个可用位置时再给生产者进程发信号，接收到信号后生产者进程切换到就绪状态。
- 基于共享内存的通信方式：在通信之前，进程先向系统申请一个获得一个共享内存区，并指定该分区的关键字；若系统已经给这个进程分配了共享区，就将这个共享区的关键字返回给该进程。



### 消息传递系统

在该系统中，进程间的数据交换是以格式化的消息为单位的。消息传递工具提供至少两种操作：发送（消息）和接收（消息）。

两个进程之间通信必须需要逻辑上的通信线路。实现方法有：

- 直接或间接通信：
  - 直接：需要通信的每个进程必须明确的命名通信的接收者或发送者。一个线路只与两个进程相关；每对进程之间只有一个线路。线路是在需要通信的两个进程之间自动建立。
  - 间接：通过邮箱或端口来接收发送消息。只有两个进程共享一个邮箱时，才能建立通信线路；一个线路可以与两个或更多的进程相关联；两个通信进程之间可以有多个不同的线路，每个线路对应一个邮箱。
- 同步或异步通信：进程之间的消息可以是阻塞或非阻塞的，也叫同步与非同步。
  - 发送进程阻塞：直到消息被接收进程或邮箱接收
  - 发送进程非阻塞：发送进程发送消息后可继续执行其他操作
  - 接收进程阻塞：直到接收到消息
  - 接收进程非阻塞：接收到一个有效消息或空消息。
- 自动或显示缓冲：通信进程所交换的消息都驻留在临时队列中，队列的实现有三种方法：
  - 零容量：队列最大长度为零，也就是阻塞发送，直到消息送达。这种情况称为没有缓冲的消息系统。
  - 有限容量：队列长度为n，最多有n个消息驻留在队列中。若队列满了，必须阻塞发送直到队列中有可用空间为止。
  - 无限容量：队列长度无限，不用阻塞发送
  - 后两种称为自动缓冲。

### 管道通信

用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件称为“管道”，又叫pipe文件。

管道机制必须提供三个方面的协调能力：

- 互斥：当一个进程对pipe文件读写时，另一个进程必须等待
- 同步：当写进程写完后便去睡眠等待，直到读进程读走数据后才换行；当读进程读一个空pipe时也应该睡眠等待，直到写进程写入数据后唤醒。
- 只有确定了对方已经存在时，才可以进行通信。