## 基本概念

### 什么是线程

线程是CPU使用的基本单元，它由线程ID、程序计数器、寄存器集合和栈组成。

线程与同一进程的其他线程共享代码段、数据段和其他操作系统资源。

### 为什么要引入线程

都已经存在进程了，为什么还要引入线程？

#### 回顾：进程是什么？

程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。

在多道编程中，允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。就是这样的设计，大大提高了CPU的利用率。进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。

#### 进程的两大属性

- 进程是一个可拥有资源的独立单位
- 进程同时又是一个可独立调度和分派的基本单位

#### 有了进程为什么还要线程？

**中心思想：**按理说进程本身已经很优秀了，那么为什么还要引入线程？那就说明虽然优秀但仍然存在一些缺点，为了克服这些缺点，所以引入线程。

进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在以下几点上：

- 进程是资源的拥有者，所以在创建、撤销、切换操作中需要较大的时空开销，限制了并发程度的进一步提高。

- 进程在一个时间点只能做一件事，如果想同时做两件事或多件事，进程就无能为力了。
- 进程在执行过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作根本不依赖输入的数据，也将无法执行。

为了解决上述的缺点，就引入了线程。

#### 因此可以得到线程的优点

- 响应度高：对一个交互程序采用多线程，即使某部分执行过程阻塞或执行执行较冗长的操作，该程序仍然能继续执行，增加了对用户的响应程度。
- 资源共享：线程默认共享它们所在进程的内存和资源。代码和数据的共享的优点是允许一个应用程序在同一个地址空间有多个不同的活动线程。
- 经济：进程的创建所需要的内存和资源的分配比较昂贵。而创建和切换线程会相对更加经济。
- 多处理器体系结构的利用：不管多少CPU，线程程进程只能运行在一个CPU上。而多线程可以充分利用多处理器体系结构，使每个进程能够并行运行在不同的处理器上。

> 进程和线程的并发层次不同：进程属于在处理器这一层上提供的抽象；线程则属于在进程这个层次上再提供了一层并发的抽象。如果我们进入计算机体系结构里，就会发现，流水线提供的也是一种并发，不过是指令级的并发。这样，流水线、线程、进程就从低到高在三个层次上提供我们所迫切需要的并发！

> 除了提高进程的并发度，线程还有个好处，就是可以有效地利用多处理器和多核计算机。现在的处理器有个趋势就是朝着多核方向发展，在没有线程之前，多核并不能让一个进程的执行速度提高，原因还是上面所有的两点限制。但如果讲一个进程分解为若干个线程，则可以让不同的线程运行在不同的核上，从而提高了进程的执行速度。

#### 进程与线程的区别

1. 调度：在传统操作系统（未引入线程）中，用于资源的基本单位和独立调度、分派的基本单位都是进程。在多线程操作系统中，把线程作为调度和分派的基本单位，进程继续作为资源拥有的独立单位，即把传统进程的两个基本属性分开，使线程基本是不拥有资源，这样线程就能方便操作（指创建、撤销和切换），从而显著提高系统的并发程度。同一进程中，线程切换不会引起进程切换，但从一个进程中的线程切换到另一个进程的线程时，将会引起进程的切换。
2. 并发行：引入线程后，不仅进程之间可以并发执行，在一个进程中的多个线程也可以并发执行。
3. 拥有资源：传统进程和引入线程的进程都可拥有资源，是系统中拥有资源的一个基本单位。线程一般来说不拥有资源，只有一点必不可少的资源，但是线程可以访问其隶属的进程的资源，包括一个进程的代码段、数据段以及拥有的系统资源。
4. 系统开销：系统在创建进程或撤销进程时的开销明显大于线程创建或撤销时的开销。进程的切换要保持当前CPU环境以及设置新被调度的进程的CPU环境，而线程切换至需要保存和设置少量寄存器即可，不涉及存储器管理方面的操作，因此进程切换的开销远高于线程切换的开销。由于一个进程的多个线程拥有相同的地址空间，所以线程之间的同步和通信的操作实现也相对进程容易。



> - 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。
> - 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。
> - 一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。

> 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

#### 总结一句话：

如果说在操作系统中引入进程的目的，是为了使多个程序能并发执行，以提高CPU利用率和系统吞吐量，那么在操作系统中引入线程，则是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。



### 线程的同步和通信

线程同步：即当有一个线程在对某个内地地址进程操作时，其他线程都不可对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作。

#### 进程中线程的同步方式：

预备知识：

> 临界资源：是一次只允许一个进程使用的共享资源。各进程采取互斥的方式，实现共享的资源称为临界资源。属于临界资源的硬件有：打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。

1. 临界区：每个进程中访问临界资源的那段代码称为临界区，每次只允许一个进程进入临界区。临界区是一种轻量级的同步机制，与互斥和事件这些内核级同步对象相比，临界区是用户态下的对象，即只能在同一个进程中实现线程互斥。

   当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止。

   具体应用方式：

   - 定义临界区对象CcriticalSection g_CriticalSection;
   - 在访问共享资源（代码或变量）之前，先获得临界区对象，g_CriticalSection.Lock（）；
   - 访问共享资源后，则放弃临界区对象，g_CriticalSection.Unlock（）；

   

2. 事件：事件（CEvent）
   事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。比如在某些网络应用程序中，一个线程如A负责侦听通信端口，另外一个线程B负责更新用户数据，利用事件机制，则线程A可以通知线程B何时更新用户数据。每个Cevent对象可以有两种状态：有信号状态和无信号状态。Cevent类对象有两种类型：人工事件和自动事件。
   自动事件对象，在被至少一个线程释放后自动返回到无信号状态；
   人工事件对象，获得信号后，释放可利用线程，但直到调用成员函数ReSet()才将其设置为无信号状态。在创建Cevent对象时，默认创建的是自动事件。
   CEvent(BOOL bInitiallyOwn=FALSE,
             BOOL bManualReset=FALSE,
             LPCTSTR lpszName=NULL,
             LPSECURITY_ATTRIBUTES lpsaAttribute=NULL);

   bInitiallyOwn:指定事件对象初始化状态，TRUE为有信号，FALSE为无信号；
   bManualReset：指定要创建的事件是属于人工事件还是自动事件。TRUE为人工事件，FALSE为自动事件；
   后两个参数一般设为NULL，在此不作过多说明。
   BOOL CEvent：：SetEvent();
   将Cevent类对象的状态设置为有信号状态。如果事件是人工事件，则Cevent类对象保持为有信号状态，直到调用成员函数ResetEvent()将其重新设为无信号状态时为止。如果为自动事件，则在SetEvent（）后将事件设置为有信号状态，由系统自动重置为无信号状态。

   BOOL CEvent：：ResetEvent();
   将事件的状态设置为无信号状态，并保持该状态直至SetEvent（）被调用为止。由于自动事件是由系统自动重置，故自动事件不需要调用该函数。
   一般通过调用WaitForSingleObject（）函数来监视事件状态。

3. 互斥量/锁（CMutex）
   互斥对象和临界区对象非常相似，只是其允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，
   但是更节省资源，更有效率。

4. 信号量（CSemphore）
   当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用“信号量”对象。CSemaphore类对象保存了对当前访问某一个指定资源的线程的计数值，该计数值是当前还可以使用该资源的线程数目。如果这个计数达到了零，则所有对这个CSemaphore类对象所控制的资源的访问尝试都被放入到一个队列中等待，直到超时或计数值不为零为止。
   CSemaphore 类的构造函数原型及参数说明如下：
   CSemaphore(
      LONG lInitialCount = 1,
      LONG lMaxCount = 1,
      LPCTSTR pstrName = NULL,
      LPSECURITY_ATTRIBUTES lpsaAttributes = NULL 
   );
   lInitialCount:信号量对象的初始计数值，即可访问线程数目的初始值；
   lMaxCount：信号量对象计数值的最大值，该参数决定了同一时刻可访问由信号量保护的资源的线程最大数目；
   后两个参数在同一进程中使用一般为NULL，不作过多讨论；
   一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号。如果为0，则放入一个队列中等待。线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore（）函数将当前可用资源数加1。
   BOOL ReleaseSemaphore(  HANDLE hSemaphore,       // hSemaphore:信号量句柄 
   　　　　　　　　　　　　　　LONG lReleaseCount,      // lReleaseCount：信号量计数值 
   　　　　　　　　　　　　　　LPLONG lpPreviousCount   // 参数一般为NULL);

## 多线程模型

多线程OS中进程的属性：

1. 进程时系统资源分配的单位
2. 可包括多个线程
3. 进程不再是一个可执行的实体：在多线程OS中，把线程当作独立运行的基本单位，所以此时的进程不再是一个可执行的实体。通常来说的进程处于执行状态实际上是指进程中的某线程正在执行。若将进程挂起，则该进程中的所有线程都将被挂起；若把某进程激活，则该进程中的所有线程也将被激活。

### 线程的实现方式

有两种主要的方法实现线程：在内核中（内核支持线程）和在用户空间中（用户级线程）

#### 1. 内核支持线程：

在内核支持线程的系统中无论是用户进程中的线程还是系统进程中的线程，它们的创建、撤销以及切换等都是依靠内核，在内核空间实现的。在内核中有用来记录系统中所有线程的线程表。

**优点：**

- 在多处理器系统中，内核能够同时调度同一进程中的多个线程并行执行。
- 若进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占有处理器，也可以是执行其他进程中的线程。
- 内核支持线程具有很小的数据结构和栈，线程的切换比较快，切换开销小。
- 内核本身也可以采用多线程技术，可以提高系统的执行速度和效率

**缺点：**

- 对用户的线程切换而言，模式切换的开销较大。同一个进程中的线程进行切换时，需要用用户态转到内核太，因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现，因此系统开销大。

#### 2. 用户级线程：

就是把整个线程包放在进程中，内核对线程一无所知。从内核来看，它认为每个进程就是一个单线程进程。对于这种线程的创建、撤销和切换等，都无须系统调用来实现。这种系统的调度仍是以进程为单位的。

在用户空间管理进程，每个进程需要有专用的线程表，用来跟踪该进程中的线程。该表与进程表类似。

**优点：**

- 最明显的优点是，用户级线程包可以在不支持线程的操作系统上实现，即用户级线程的实现与操作系统平台无关。
- 线程切换不需要转到内核空间，从而节省了模式切换的开销，也节省了内核资源。
- 调度算法可以是进程专用的。也就是说每个进程可以自己定制内部的线程调度算法

**缺点：**

- 存在系统调用的阻塞问题，在基于进程机制的操作系统中，大部分系统调用都会阻塞进程，当进程中的一个线程执行一个系统调用时，不仅该线程会阻塞，这个进程内的其他线程也会被阻塞。这一点在内核支持线程中就可以避免。注意，进程中某个线程引起本地阻塞不会影响到进程中的全部线程，所谓本地阻塞就是在用户级别阻塞而不是系统调用阻塞，比如说一个线程A用到的某些数据要等另一个线程B之后得到的结果，那么线程A就是本地阻塞了，这时进程可能在执行线程B甚至也可以执行其他线程。
- 在单纯的用户级线程实现方式中，多线程不能利用多处理器进行多重处理的优点。因为内核每次只能给一个进程分配一个CPU，因此该进程中的所有线程在进程不阻塞的情况下只能排队使用这一个CPU。补充：如果进程中的一个线程开始执行，那么该进程中的其他进程就不能运行，除非第一个执行的线程主动放弃CPU。
- 补充：不光是执行系统调用会引起阻塞，进程中的某个线程若跳转到一个不在内存的指令上，这就引起了缺页中断问题。由于内核不知道线程的存在，它只能将整个进程阻塞，等待操作系统去磁盘上取回这个丢失的指令。

#### 内核支持线程的实现

就是为每一个线程在内核中建立类似于PCB的TCB（线程控制块）。

#### 用户级线程的实现

用户级线程是在用户空间实现的，它们有相同的结构。这些用户级线程实际上是运行在一个中间系统上的。有两种方式实现中间系统。

1. 运行时系统：就是一个用于管理和控制线程的函数集合。当线程需要系统资源时，基于内核支持线程的系统会由内核来分配相应资源，而用户级线程是向运行时系统请求，然后再由运行时系统经过相应的系统调用来获得系统资讯的。
2. 内核控制线程：即轻型进程LWP（Light Weight Progress）。LWP可以通过系统调用来获得内核提供的服务，当一个用户级线程运行时，只要将它连接到一个LWP上，此时它便具有了内核支持线程的所有属性。LWP就像一个中介，一个LWP都要连接到一个内核进程上，而多个用户线程可以连接到一个LWP上，但LWP一次只能为一个它所连接的用户线程处理业务，其他所连接的用户线程处于阻塞状态。LWP实现了用户线程与内核的隔离。当用户线程不需要使用内核资源时，就不需要LWP。