## 一. 基本概念

所谓CPU调度就是在多道程序环境下，系统能够按照某种算法，动态的把CPU分给就绪队列中的一个进程，使之执行。

CPU调度是多道程序操作系统的基础。通过调度，操作系统可以提高计算机的吞吐率。



### CPU调度的时机

有四种情况会引起CPU的调度。

### 调度程序的工作

- 上下文切换
- 切换到用户模式
- 跳转到适当的位置（上次中断的位置）重启该程序



### 调度准则

- CPU的利用率
- 吞吐量：单位时间内处理作业的数量
- 周转时间：从作业提交完成到作业执行结束之间的时间。组成：
  - 在后备队列中的等待时间
  - 进入内存后在就绪队列中的等待时间之和
  - 在CPU上执行的时间之和
  - 在阻塞队列中的等待时间之和
- 等待时间：在就绪队列中等待的时间，公式：某个作业的等待时间 = 执行完毕的时间（从CPU执行第一个作业开始计时） - 该作业执行需要的时间 - 该作业到达（被提交完成的）时间（也是从CPU执行第一个作业开始计时），这里CPU执行第一个作业的等待时间为0
- 响应时间：从提交完成到首次给出相应的时间

#### 作业的四种状态

- 提交
- 后备（等待进内存）
- 运行（宏观上的运行，只是进入内存了，刚进入内存应该处于就绪状态）：这里选取那个作业进入内存也是一种调度，称为高级调度或作业调度
- 结束或终止



## 二. 调度算法（大部分应用于低级调度）

### 1. FCFS（First-Come，First-Serverd）：

**先来先服务，不用先进先出的原因是有的作业处理时间可能很长所以虽然先进但不一定先出（未处理完）。**

优点是易于理解并且便于在程序中运行。

### 2. SJF（Shortest-Job-Fisrt）：短作业优先

**最短作业优先调度，谁占用CPU的时间短就让谁先执行，又分抢占式和非抢占式，抢占式又称为最短剩余时间优先调度。**

**如何知道下一次执行需要的时间：采用指数平均法进行估计。**

**指数平均法**：用来估计下一次执行期谁执行时间最短。用以前的结果估计未来。

#### SJF存在的不容忽视的缺点：

1⃣️ 该算法对长作业不利，如果一个长作业在进入就绪队列后，调度总是优先调用那些短作业，将导致长作业长期不能被执行。

2⃣️ 该算法完全没有考虑作业的紧迫程度，因而不能保证紧迫性作业被及时处理。

3⃣️ 由于作业的长短只是根据用户所提供的估计执行时间而定的，而用户会有意无意的缩短期估计时间，致使该算法不一定真正做到短作业优先调度。

### 3. Priority Schedulling：根据优先级的调度

每个进程都有一个优先级与之关联，具有高优先级的进程会被分配到CPU。

该算法就是把CPU分配给就绪队列中优先级最高的进程。具有相同优先级的进程按照FCFS顺序调度。

#### 非抢占式优先级算法

系统一旦把CPU分配给就绪队列中优先级最高的进程后，该进程会一直执行下去，直到完成，即使该进程在执行时，就绪队列中出现（新加入或者队列中某个进程优先级被修改）了一个更高优先级的进程也不会影响正在执行的进程；这种算法主要用于批处理系统中。

#### 抢占式优先级算法

在这种方式下，同样是把CPU分配给就绪队列中优先级高的进程，不同的时，如果在其执行期间就绪队列中又出现了更高优先级的线程，进程调度程序就立即停止当前进程的执行，重新将CPU分配给新的优先级更高的进程。

常用于实时系统中，以及对性能要求比较高的批处理和分时系统中。

#### 优先级的类型

1⃣️ 静态优先级：优先级在进程的创建后就确定了，且在进程的整个运行期间保持不变。

2⃣️ 动态优先级：在创建进时所赋予的优先级，是可以随进程的推进或随其等待时间的增加而改变的。

#### 缺点

存在无穷等待或饥饿问题。某个优先级低的进程可能一直没有机会分配到CPU的使用权。

解决这个问题的办法就是“老化”：就是随着等待时间的增长而增加该进程的优先级，这样该进程最终一顶会达到最高优先级，从而分配到CPU。

#### 一种结合FCFS和SJF算法：高响应比优先调度算法

首先要说明的是，FCFS和SJF从广义上讲都算是优先级调度算法，在FCFS中把进入就绪队列的先后次序当作优先级，级先来的优先级对高；同理在短作业优先中，最短作业优先级最高。

回到本算法，其公式为：

$$ 优先级 = \frac{等待时间 + 要求服务时间} { 要求服务时间}$$

也就是说：

- 相同要求服务时间的情况下，等待时间的越大的进程，优先级越大
- 相同等待时间的情况下，要求服务时间越短的进程，优先级越大
- 对于长作业来说，随着其等待时间的增加，其优先级总是会增加的，最终也会分配到CPU的。

### 4. Round-Robin Schedulling：轮转法调度

专门为分时系统设计的。

它类似于FCFS调度，但在其基础上添加了抢占以切换进程。

说白了就是一人执行一会儿。这个一会儿就是时间片，一个固定的时间值。

从队首开始执行，执行一个时间片后，该进程被放入队尾，CPU执行新的队首。

这个算法的重点是时间片大小的却确定，如果时间片太小，虽然会对短作业很有利，但是其会频繁的发生中断、进程上下文切换，会增加系统的开销；若时间片过大此算法就会退化成FCFS算法。

### 5. Multilevel Queue Schedulling：多级队列

将就绪队列中的进程划分成多个独立队列。根据队列的属性，一个进程被永久的分配到一个队列。每个队列采用自己的调度算法。

队列之间的进程也必须有调度，通常采用固定优先级抢占调度，也可以在队列之间使用时间片。

### 6. Mutilevel Feedback Queue：多级反馈队列

基本流程：

- 设置多个就绪队列，每个队列优先级不同，假设第一队列优先级对高，第二队列次高，以此类推。每个队列的时间片一次按倍数增加，例如第一队列时间片为t，则第二队列为2t，第三个队列4t，以此类推
- 一个新进程进入内存后，先放入第一队列（优先级最高）队尾，按照FCFS顺序等待调度。若在第一对了的一个时间片内执行完毕，则可准备撤离系统；若在第一队列的时间片内未执行完毕，则调度程序将其转入第二队列队尾，按照FCFS顺序等待调度，以此类推。
- 只有在第一队列为空时，调度程序才会调度第二队列中的进程运行。对于除了 第一队列的其他队列来说，只有其前几个队列（比本队列优先级高的所有队列）全部为空时才可以调度。若第i个队列中某进程正在执行，又有新的进程进入比第i队列高的队列中时，新进程会抢占CPU。
- 此外，在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列，以阻止饥饿的发生。

