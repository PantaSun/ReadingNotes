---
title: 第二部分4 进程同步
date: 2019-03-19 09:30:27
tags: 
- 操作系统
categories:
- Reading notes
- 总结
---



## 重点内容

- 临界区问题
- 基于硬件的同步
- 信号量机制
- 经典同步问题
- 管程

## 背景

共享数据的并发访问可能产生数据的不一致。而进程同步机制就是用来确保共享同一逻辑地址空间的协作进程（这个并不是协程）可有序的执行，从而维护数据的一致性。

## 临界区问题

**1.临界资源**

临界资源是一次仅允许一个进程使用的共享资源。*各进程采取互斥的方式，实现共享的资源称作临界资源。*属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。

**2.临界区：**

每个进程中访问临界资源的那段代码称为临界区（*criticalsection*），每次只允许一个进程进入临界区，进入后，不允许其他进程进入。不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。*多个进程涉及到同一个临界资源的的临界区称为相关临界区。*使用临界区时，一般不允许其运行时间过长，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会被挂起而进入等待状态，并在一定程度上影响程序的运行性能。



每个进程必须请求允许进入临界区。实现这一请求的代码段称为进入区，临界区之后可有退出去，其它代码为剩余区。



**3. 临界区的使用原则**

- 互斥：如果一个进程在其临界区执行，则其他进程都不能在其临界区内执行（忙则等待）
- 前进：如果没有进程在其临界区内执行且有进程需要进入临界区，那么只有那些不在剩余区内执行的进程可参加选择，以确定下一个进入临界区，且这种选择不能无限推迟。（空闲让进）
- 有限等待：从一个进程作出进入临界区的请求，直到该请求允许为止，其他进程允许进入其临界区的次数有上限。对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。
- 让权等待：不能忙等，要让出CPU。当进程不能进入自己的临界区时，应立即释放CPU，以免进程陷入“忙等”状态。

### Peterson算法

该算法适用于两个进程在临界区与剩余区间交替执行。假设有两个进程P0和P1。Peterson算法需要在两个进程之间共享两个数据项：`int turn；和boolean flag[2];`这里用i和j表示两个进程。

则有代码：

```c
do {
	// 进入区
    flag[i] = TRUE;
    turn = j;
    while(flag[j] && turn == j);
    // 临界区
    do somethins；
    // 退出区
    flag[i] = FALSE;
    // 剩余区
    others;
} while(TRUE);
```

变量turn等于谁就表示谁可以进入临界区。

flag中哪个为TRUE就表示哪个进程想要进入临界区。

上述代码是表示进程i的，而进程j的代码和上述代码一致，但是要把i和j对调。

**按代码流程解释：** 

先不管最外层的do-while循环

- 首先将flag中进程i设为TRUE，表示进程i想要进入临界区

- 将turn设为j，这里表示如果另一个进程j想要进入临界区，那么j进程就能进入。如果两个进程同时想要进入，那么肯定都要设置turn，但最后turn只有一个值，就是i和j中的一个。这个turn等于谁，最终谁就会进入临界区。

- while循环中的判断是若另一个进程j不想进入临界区（flag[j]==FALSE）或者另一个进程允许本进程i进入临界区（turn==i），那么本进程i就可以进入临界区。
- 进入临界区
- 退出时要把flag[i]设为FALSE，表示不想进入临界区了，允许其他进程进入临界区
- 剩余区



## 信号量

#### 原子操作

所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何上下文切换。

### 整型信号量

就是一个用于表示资源数目的整型变量S，它与一般的整型变量不同，除初始化外，S仅能通过两个标准的原子操作wait(S)和signal(S)来访问。这两个操作也被称为P（荷兰语proberen，测试）、V（荷兰语verhogen，增加）操作。

这两个操作的简单代码描述为：

```c
wait(S)
{
    while(S <= 0)
    	do nothing;
    S--;
}

signal(S)
{
    S++;
}

// 使用方式
do{
    // 进入区
    wait(mutex);
    // 临界区
    do somethin;
    // 退出区
    signal(mutex);
    // 剩余区
    others;
}while(TRUE)
```

这里wait的作用就是用来申请资源，即S—，但是在减之前要进行判断，若S小于等于0就说明目前没有可用资源，所以需要不停循环等待，也就是忙等。而signal的作用就是释放资源，当一个进程不需要使用共享资源时就释放，即S++；

### 记录型信号量

整型信号量有个缺点，那就是会出现忙等情况，因此该机制未遵循让权等待的准则。记录型信号量就不存在忙等的情况，因为当一个进程执行wait操作时，若发现信号量值不为正时，该进程不是忙等而是阻塞自己。阻塞操作将该进程放入与信号量相关的等待队列中，并将该进程切换为等待状态。因此在该类型信号量中，除了一个用于记录资源数目的整型变量value以外，还增加一个进程链表指针L，用于链接所有等待进程。

首先定义一个数据结构：

```c
typedef struct{
    int value;
    struct process *L;
}semaphore;
```

两个操作的代码：

```c
wait(semaphore *S)
{
    S->value--;
    if(S->value < 0)
    {
        add this process to S->L;
        block(); // 挂起调用它的进程
    }
}

signal(semaphore *S)
{
    S->value++;
    if(S->value <= 0)
    {
        remove a process P from S->L; // 唤醒一个等待进程
        wakeup(P);
    }
}
```

这里当value为负时，该值的绝对值就是等待进程的个数。



### AND型信号量

上述的进程互斥问题，是针对各进程之间共享一个临界资源而言的。AND型信号量用于一个进程需要先获得两个共享资源时使用的。

AND同步机制的基本思想是：将进程在整个运行过程中需要的所有资源，一次性全部分配给进程，待进程使用完后再一起释放。如果只有一个共享资源无法分配给该进程，那么其他所有可以分配给进程的共享资源也不分配给进程。也就是说对若干个临界资源的分配采用原子操作。这就相当于在wait操作中，增加了一个“AND”条件，所以称为AND同步。

### 信号量集

在记录型信号量机制中，wait或signal一次只能对信号量加一或减一。若要一次需要N个某临界资源，就要进行N次wait操作，这显然很低效。

在有些情况下，当资源数量低于某一下限值时，便不予分配。

为了解决上述两个问题，可以讲AND型信号量进行扩展，形成信号量集机制。

其原型为$Swait(S_1, t_1, d_1, S_2 ,t_2, d_2…..)$，这里S为信号量，d为需求值，t为下限值。这个原型的简单解释就是，对于信号量$S_1$，若其值大于$t_1$，则对其进行减$d1$操作，同理可扩展到$S_2、S_3、、S_n$。

## 经典同步问题

### 生产者-消费者问题

假设有缓冲池有n个缓冲项，每个缓冲项能存放一个数据项。信号量mutex提供了对缓冲池访问的互斥要求，其初始值设为1.信号量empty和full分别表示空缓冲项和满缓冲项的个数。empty初始值为n；full初始值为0.

```c
// 生产者
do{
	// 生产者生产了一个商品（这里就是数据）
    wait(empty);
    wait(mutex);
    
    // 把商品添加到缓冲区
    
    signal(mutex);
    signal(full);
}while(TRUE);

// 消费者
do{
    wait(full);
    wait(mutex);
    
    // 消费者购买一个商品，就是从缓冲区取出一个缓冲项
    signal(mutex);
    signal(empty);
    
    // 消费者消费商品
}while(TRUE);
```



### 读者-写者问题

#### 问题描述

- 读者有多个，只能读不能写
- 写者有多个，可读可写

#### 操作限制

- 读者和写者之间互斥，也就是说读的时候不能写，写的时候不能读
- 多个写者之间互斥，一个写者写的时候，其他写者不能同时写
- 无写者时，多个读者之间不互斥

#### 共享数据以及信号量设置

- 读写数据集合是一个共享数据

- 如何知道有多少个读者：设置读者计数器readcount，每加入一个读者就要将该变量加一；每离开一个读者也要将其减一。因为每个读者都可以操作readcount，所以它也是一个共享数据。其初始值设为0，即最开始有零个读者。
- 还要设置一个互斥信号量mutex，用以对共享变量readcount的互斥，其初始值设为1，即最开始可以修改readcount。
- 读写之间也要设置一个互斥信号量wrt，用来读写互斥，同时这个信号量也可以用于多写者之间互斥，其初始值设为1，即最开始可以读也可以写。

#### 伪代码

```c
// semaphore mutex, wrt;
// mutex.value = wrt.value = 1;
// int readcount = 0;
// parbegin:
	// Reader process
	// begin
	while(TRUE)
    {
    	wait(mutex);
    	readcount++;
    	if(readcount == 1) wait(wrt);
    	signal(mutex);
    	// reading
    	wait(mutex);
    	readcount--;
    	if(readcount == 0) signal(wrt);
    	signal(mutex);
	}
	// end
// parend
```

```c
// semaphore mutex, wrt;
// mutex.value = wrt.value = 1;
// int readcount = 0;
// parbegin:
	// Writer process
	// begin
	while(TRUE)
	{
        wait(wrt);
		// writing
        signal(wrt);
	}
	// end
```





### 哲学家进餐问题

假设有5个哲学家，它们除了吃饭就是思考。这五个人坐在一个圆桌子周围。桌子上有5只筷子，即每个哲学家左手边右手边各有一只筷子，每只筷子是两个哲学家公用的，桌子中间是食物。一个哲学家饥饿时就想要进餐，进餐需要两只筷子，而哲学家一次只能拿起一只筷子，且不能从其他哲学家手里拿筷子。这是在多个进程之间分配多个资源时不会出现死锁和饥饿的典型例子。

放在桌子上的筷子就是临界资源，在一段时间内只允许一位哲学家使用。

设置信号量数组 semaphore chopstick[5]; 其中所有的chopstick的元素初始化为1。

一种基本的解决方案：

```c
do{
    wait(chopstick[i]);
    wait(chopstick[(i+1)%5]);
    // eat
    signal(chopstick[i]);
    signal(chopstick[(i+1)%5]);
}
```

这里假设哲学家i左边的筷子的编号为i右边的筷子编号为（i+1）% 5。在需要进餐时先拿左边的筷子，再拿右边的筷子，然后开始吃，最后依次释放筷子。

这里又个极端的情况就是五个哲学家同时都想进餐，于是他们都拿起左边的筷子，这时要拿起右边的筷子时，就进入阻塞状态，这样五个哲学家都进入阻塞状态。这就产生了死锁的情况，最终五个哲学家都要饿死。



### 顾客与理发师问题

#### 问题描述

熟睡的理发师问题描述的是多个进程(线程)之间的通信与同步问题:

- 有一个理发师的椅子，和N个顾客等候理发的椅子。
- 如果有顾客在椅子上等，那么理发师为他剪发，否则理发师就在自己的椅子上睡觉。

- 如果理发师在熟睡，那么顾客会叫醒理发师，否则顾客会看有没有空椅子，有的话，他坐下等，否则，他将离开理发店。

####问题分析：

- 首先是避免死锁，也就是理发师一直在睡觉，所以我们采取让顾客叫醒理发师的方式，只要理发师一空闲下来，等待的顾客就会叫醒理发师。
- 因为顾客的座位是顾客进程(线程)共享的，所以要防止发生冲突
- 可以讲顾客看成N个生产者，理发师是一个消费者
- 理发（师）椅子和等候椅子是临界资源
- 顾客之间互斥关系
- 理发师和顾客之间同步关系。

####基本思路:
  利用信号量来解决这个问题:
- 首先顾客的座位被所有顾客进程(线程)共享，所以要设置互斥量mutex，来防止多个进程(线程)同时修改内存造成的错误
- 理发师只有一个，所以需要设置信号量，来让顾客判断何时叫醒理发师。
- 顾客可以最多有“座位个”，需要设置信号量，让理发师判断是否去睡觉。
- 顾客会在获得互斥锁后，查看剩余座位数，来决定走或者留

#### 定义信号量

引入3 个信号量和一个控制变量：

- 控制变量waiting 用来记录等候理发的顾客数，初值均为0；
- 信号量customers 用来记录等候理发的顾客数，并用作阻塞理发师进程，初值为0；
- 信号量barbers 用来记录正在等候顾客的理发师数，并用作阻塞顾客进程，初值为0；
- 信号量mutex 用于互斥对椅子上等待的顾客数量的操作，初值为1。

#### 伪代码

顾客操作：

```c
Customer(){

	while(TRUE){

		wait(mutex);    		//顾客想要理发

		if(waiting < N){   		//店里人没有满
			waiting++；		   //等候区顾客人数加一
    		signal(customers);	//理发师睡觉的话，唤醒他理发
	    	signal(mutex);    	//释放互斥量
     		wait(baber);    	//等待理发师进行理发操作

		}
		else{
			signal(metux);    	//释放互斥量，打消进店理发的举动，或者去其他店

		}

    }
}

```

理发师操作：

```c
Barber(){

	while(TRUE){

        wait(customers);    //唤醒等待的一位顾客  
        wait(mutex);		//尝试获取椅子资源
        waiting--;    		//当前等候区顾客数减1
        siagnal(mettux):   	//释放互斥信号量
		// 开始理发
        signal(barber);   	//理发师理完发，理发师空闲
        
	}

}

```





## 管程

出现的意义：信号量机制中每个协作进程都需要自备同步操作。这使得大量同步操作分散在各个进程中。这样不易管理，操作不当还容易产生死锁。位了解决这个问题，就出现了管程。

### 管程的定义

一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。

管程的四个部分：

- 管程的名称
- 局部于管程内部的共享数据结构说明
- 对该数据结构进程操作的一组过程
- 对于管程内部的共享数据设置初值的语句。

**基本思想**：管程内部的共享资源只能被管程内部的过程访问。管程就像围墙，把共享变量和对共享变量的操作围了起来，所有进程要访问临界资源时，都必须经过管程才能进入，而管程每次只允许一个进程进入管程，从而实现了进程互斥。

### 进程和管程的区别

- 虽然都定义了数据结构，但是进程定义的是私有数据结构PCB，管程定义公共数据结构，如消息队列。
- 二者都存在对各自数据结构上的操作，但进程是顺序执行的，管程主要是进行同步和初始化操作。
- 设置进程的目的在于实现系统的并发性，而管程的设置是解决共享资源的互斥使用问题
- 进程通过调用管程中的过程对共享数据实行操作，该过程如同普通的字程序一样被调用，因此管程为被动工作方式，而进程则为主动工作方式
- 进程之间具有并发性，而管程则不能与其调用者并发
- 进程具有动态性，由创建而诞生，由撤销而消亡，而管程则是操作系统中的一个资源管理模块，供进程调用

### 条件变量

使用管程又一个缺点，那就是如果一个进程进入管程后，在管程中该进程如果挂起或阻塞了，那么该进程不释放管程，其他进程也无法使用管程。位了解决这个问题，引入条件变量condition。

在管程中设置多个条件变量，对这些条件变量的访问只能在管程中进行。

对条件变量的操作仅仅是wait和signal，每个条件变量保存一个链表，用于记录因该条件变量而阻塞的所有进程。

对条件变量的操作可表示为x.wait和x.signal：

- x.wait：正在调用管程的进程因为x条件变量需要而被阻塞，则调用x.wait将自己插入到x的等待队列上，并释放管程，直到x变化。此时其他进程可以使用管程。
- x.signal：正在调用管程的进程发现x发生了变化，则调度用x.signal，重新启动一个因x条件而阻塞的进程。如果有多个这样的阻塞进程，就选择一个；若一个没有，则原进程继续执行。

### 总结

这里带条件变量的管程的概念有点像CPU的感觉，一个CPU一次也只能执行一个进程，若进程因中断而阻塞则将其放入等待队列转而执行另一个进程。这里就和带条件变量的管程的理念很像。条件变量的变化就像是系统中断一样。

### 哲学家进餐问题的管程解决方式

筷子分布由管程dp来控制，每个哲学家进餐前先调用pickup，表示拿起筷子，当然该函数也可能挂起进程，即无法一次拿起两只筷子时就会挂起。成功拿起两只筷子后，哲学家开始进餐，进餐完毕后再调用putdown放下筷子并开始思考。

```c
dp.pickup(i);
// eating
dp.putdown(i);
```

这里dp的定义以及pickup和putdown的定义如下：

```c
monitor dp{
    enum {THINKING, HUNGRY, EATING} state[5];  // 表示哲学家状态的数组
    condition self[5];	// 条件变量数组，哲学家在饥饿且不能拿到所需的筷子时可阻塞自己
    						
    
    void pickup(int i){			// 准备拿起筷子
        state[i] = HUNGRY;		// 将状态设置为饥饿
        test(i);				// 检查是否能拿起筷子并顺利进餐
        if(state[i] != EATING)	// 如果无法进餐则挂起该进程
        	self[i].wait();		
    }
    
    void putdown(int i){		// 放下筷子
        state[i] = THINKING;	// 将哲学家设为思考状态
        test((i+4)%5);			// 检查右边的哲学家是否能进餐
        test((i+1)%5);			// 检查左边的哲学家是否能进餐
    }
    
    void test(int i){
        if((state[(i+4)%5] != EATING) && 	// 判断，若一个哲学家i的左右哲学家都没有在进餐
        (state[(i+1)%5] != EATiING) && 		// 且本哲学家想要进餐，则允许哲学家i进餐
        (state[i] == HUNGRY) ){
         	state[i] = EATING;				// 设置哲学家i为进餐状态
            self[i].singal();				// 唤醒挂起的i哲学家，若i哲学家没有挂起则继续执行
        }
    }
    initialization_code(){					// 初始化程序
        for(int i=-;i<5;i++)		
            state[i] = THINKING;
    }
}
```

