## 重点内容

- 临界区问题
- 基于硬件的同步
- 信号量机制
- 经典同步问题
- 管程

## 背景

共享数据的并发访问可能产生数据的不一致。而进程同步机制就是用来确保共享同一逻辑地址空间的协作进程（这个并不是协程）可有序的执行，从而维护数据的一致性。

## 临界区问题

**1.临界资源**

临界资源是一次仅允许一个进程使用的共享资源。*各进程采取互斥的方式，实现共享的资源称作临界资源。*属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。

**2.临界区：**

每个进程中访问临界资源的那段代码称为临界区（*criticalsection*），每次只允许一个进程进入临界区，进入后，不允许其他进程进入。不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。*多个进程涉及到同一个临界资源的的临界区称为相关临界区。*使用临界区时，一般不允许其运行时间过长，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会被挂起而进入等待状态，并在一定程度上影响程序的运行性能。



每个进程必须请求允许进入临界区。实现这一请求的代码段称为进入区，临界区之后可有退出去，其它代码为剩余区。



**3. 临界区的使用原则**

- 互斥：如果一个进程在其临界区执行，则其他进程都不能在其临界区内执行（忙则等待）
- 前进：如果没有进程在其临界区内执行且有进程需要进入临界区，那么只有那些不在剩余区内执行的进程可参加选择，以确定下一个进入临界区，且这种选择不能无限推迟。（空闲让进）
- 有限等待：从一个进程作出进入临界区的请求，直到该请求允许为止，其他进程允许进入其临界区的次数有上限。对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。
- 让权等待：不能忙等，要让出CPU。当进程不能进入自己的临界区时，应立即释放CPU，以免进程陷入“忙等”状态。

### Peterson算法

该算法适用于两个进程在临界区与剩余区间交替执行。假设有两个进程P0和P1。Peterson算法需要在两个进程之间共享两个数据项：`int turn；和boolean flag[2];`这里用i和j表示两个进程。

则有代码：

```c
do {
	// 进入区
    flag[i] = TRUE;
    turn = j;
    while(flag[j] && turn == j);
    // 临界区
    do somethins；
    // 退出区
    flag[i] = FALSE;
    // 剩余区
    others;
} while(TRUE);
```

变量turn等于谁就表示谁可以进入临界区。

flag中哪个为TRUE就表示哪个进程想要进入临界区。

上述代码是表示进程i的，而进程j的代码和上述代码一致，但是要把i和j对调。

**按代码流程解释：** 

先不管最外层的do-while循环

- 首先将flag中进程i设为TRUE，表示进程i想要进入临界区

- 将turn设为j，这里表示如果另一个进程j想要进入临界区，那么j进程就能进入。如果两个进程同时想要进入，那么肯定都要设置turn，但最后turn只有一个值，就是i和j中的一个。这个turn等于谁，最终谁就会进入临界区。

- while循环中的判断是若另一个进程j不想进入临界区（flag[j]==FALSE）或者另一个进程允许本进程i进入临界区（turn==i），那么本进程i就可以进入临界区。
- 进入临界区
- 退出时要把flag[i]设为FALSE，表示不想进入临界区了，允许其他进程进入临界区
- 剩余区



## 信号量

#### 原子操作

所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何上下文切换。

### 整型信号量

就是一个用于表示资源数目的整型变量S，它与一般的整型变量不同，除初始化外，S仅能通过两个标准的原子操作wait(S)和signal(S)来访问。这两个操作也被称为P（荷兰语proberen，测试）、V（荷兰语verhogen，增加）操作。

这两个操作的简单代码描述为：

```c
wait(S)
{
    while(S <= 0)
    	do nothing;
    S--;
}

signal(S)
{
    S++;
}

// 使用方式
do{
    // 进入区
    wait(mutex);
    // 临界区
    do somethin;
    // 退出区
    signal(mutex);
    // 剩余区
    others;
}while(TRUE)
```

这里wait的作用就是用来申请资源，即S—，但是在减之前要进行判断，若S小于等于0就说明目前没有可用资源，所以需要不停循环等待，也就是忙等。而signal的作用就是释放资源，当一个进程不需要使用共享资源时就释放，即S++；

### 记录型信号量

整型信号量有个缺点，那就是会出现忙等情况，因此该机制未遵循让权等待的准则。记录型信号量就不存在忙等的情况，因为当一个进程执行wait操作时，若发现信号量值不为正时，该进程不是忙等而是阻塞自己。阻塞操作将该进程放入与信号量相关的等待队列中，并将该进程切换为等待状态。因此在该类型信号量中，除了一个用于记录资源数目的整型变量value以外，还增加一个进程链表指针L，用于链接所有等待进程。

首先定义一个数据结构：

```c
typedef struct{
    int value;
    struct process *L;
}semaphore;
```

两个操作的代码：

```c
wait(semaphore *S)
{
    S->value--;
    if(S->value < 0)
    {
        add this process to S->L;
        block(); // 挂起调用它的进程
    }
}

signal(semaphore *S)
{
    S->value++;
    if(S->value <= 0)
    {
        remove a process P from S->L; // 唤醒一个等待进程
        wakeup(P);
    }
}
```

这里当value为负时，该值的绝对值就是等待进程的个数。

## 经典同步问题

### 生产者-消费者问题

### 读者-写者问题

#### 问题描述

- 读者有多个，只能读不能写
- 写者有多个，可读可写

#### 操作限制

- 读者和写者之间互斥，也就是说读的时候不能写，写的时候不能读
- 多个写者之间互斥，一个写者写的时候，其他写者不能同时写
- 无写者时，多个读者之间不互斥

#### 共享数据以及信号量设置

- 读写数据集合是一个共享数据

- 如何知道有多少个读者：设置读者计数器readcount，每加入一个读者就要将该变量加一；每离开一个读者也要将其减一。因为每个读者都可以操作readcount，所以它也是一个共享数据。其初始值设为0，即最开始有零个读者。
- 还要设置一个互斥信号量mutex，用以对共享变量readcount的互斥，其初始值设为1，即最开始可以修改readcount。
- 读写之间也要设置一个互斥信号量wrt，用来读写互斥，同时这个信号量也可以用于多写者之间互斥，其初始值设为1，即最开始可以读也可以写。

#### 伪代码

```c
// semaphore mutex, wrt;
// mutex.value = wrt.value = 1;
// int readcount = 0;
// parbegin:
	// Reader process
	// begin
	while(TRUE)
    {
    	wait(mutex);
    	readcount++;
    	if(readcount == 1) wait(wrt);
    	signal(mutex);
    	// reading
    	wait(mutex);
    	readcount--;
    	if(readcount == 0) signal(wrt);
    	signal(mutex);
	}
	// end
// parend
```

```c
// semaphore mutex, wrt;
// mutex.value = wrt.value = 1;
// int readcount = 0;
// parbegin:
	// Writer process
	// begin
	while(TRUE)
	{
        wait(wrt);
		// writing
        signal(wrt);
	}
	// end
```





### 哲学家进餐问题

假设有5个哲学家，它们除了吃饭就是思考。这五个人坐在一个圆桌子周围。桌子上有5只筷子，即每个哲学家左手边右手边各有一只筷子，每只筷子是两个哲学家公用的，桌子中间是食物。一个哲学家饥饿时就想要进餐，进餐需要两只筷子，而哲学家一次只能拿起一只筷子，且不能从其他哲学家手里拿筷子。这是在多个进程之间分配多个资源时不会出现死锁和饥饿的典型例子。

放在桌子上的筷子就是临界资源，在一段时间内只允许一位哲学家使用。

设置信号量数组 semaphore chopstick[5]; 其中所有的chopstick的元素初始化为1。

一种基本的解决方案：

```c
do{
    wait(chopstick[i]);
    wait(chopstick[(i+1)%5]);
    // eat
    signal(chopstick[i]);
    signal(chopstick[(i+1)%5]);
}
```

这里假设哲学家i左边的筷子的编号为i右边的筷子编号为（i+1）% 5。在需要进餐时先拿左边的筷子，再拿右边的筷子，然后开始吃，最后依次释放筷子。

这里又个极端的情况就是五个哲学家同时都想进餐，于是他们都拿起左边的筷子，这时要拿起右边的筷子时，就进入阻塞状态，这样五个哲学家都进入阻塞状态。这就产生了死锁的情况，最终五个哲学家都要饿死。