---
title: 第二部分5 死锁
date: 2019-03-20 20:44:12
tags: 
- 操作系统
categories:
- Reading notes
- 总结
---

## 主要内容

- 系统模型
- 死锁特点
- 死锁预防
- 死锁避免
- 死锁检测
- 死锁恢复



## 系统模型

### 死锁

两个或两个以上进程由于竞争资源导致系统无法推进，系统此时所处的状态就为死锁状态。也就是说死锁是一种系统状态。或者说当一组进程中的每个进程都在等待一个事件，而这个事件只能由这一组进程的另一个进程引起，那么这组进程就处于死锁状态。

### 产生原因

1. 资源相对不足
2. 进程的推荐顺序不合理



## 死锁特征

### 产生的必要条件

如果一个系统中以下四个条件同时满足，那么就会引起死锁：

1. 互斥：至少有一个资源必须处于非共享模式，即一次只有一个进程使用。如果另一个进程申请该资源，那么申请必须等到该资源释放为止。
2. 占有并等待：一个进程必须已经占有至少一个资源，并等待另一个资源，而这个另一资源被其他进程所占用。
3. 非抢占：资源不能被抢占，只能在进程完成任务后自动释放。
4. 循环等待（环路等待）：假设有一组等待进程，进程P0在等待的资源被进程P1占有，P2等待的资源被P3占有，以此类推Pn-1等待的资源被Pn占有，而Pn等待的资源被P0占有，即形成一个环路。

### 资源分配图

- 资源分配图由节点V的集合和边E的集合组成。

- 节点集合V可分成两种类型的节点：$P=\{ P_1, P_2 ,,, P_n\}，R=\{R_1,  R_2 ,,, R_n\}$。P是系统活动进程的集合，R是系统所有资源类型的集合

- 进程指向资源的边，称为申请边。例如$P_i -> R_i$，表示进程$P_i$已经申请了资源$R_i$的一个实例，并正在等待该资源。

- 资源指向进程的边，称为分配边。例如$rj->pj$，表示资源类型$R_j$的一个实例已经分配给进程$P_j$。

- 在图中，资源用正方形表示，进程用圆圈⭕️表示。方形中有小点，用来表示某种资源的实例数。
- 当一个进程向某个资源申请一个实例时，就在资源分配图中添加一条申请边。当该申请得到满足时，那么申请边就立即转换为分配边。
- 当进程不在需要访问资源时，它就释放资源，因此就要在图中删除该分配边。
- 资源分配图中出现环路不一定代表出现了死锁。因为可能每个资源有多个实例，这也就证明了环路是出现死锁的必要而非充分条件。
- 如果图中没有环，则一定没有死锁
- 如果图中有环，分两种情况：
  - 每个资源只有一个实例，那么就一定会产生死锁
  - 每个资源有多个实例，那么就是可能产生死锁

## 死锁处理方法

三种方法：

- 使用协议以预防死锁或避免死锁，确保系统不会进入死锁状态
- 可允许系统进入死锁，然后检测它，并加以恢复
- 可忽视这个问题，认为死锁不可能在系统内发生

## 死锁预防

基本思路就是破坏死产生的四个必要条件之一。

互斥和非抢占理论上可以破坏，但在实际中不允许破坏，例如打印机资源。

### 破坏"占有并等待"

- 占有不等待：一次性资源分配法。缺点是资源浪费严重。
- 等待就不占有：也不可适合

### 破坏环路等待

- 有序资源使用法：将所有的资源进行编号，使用资源时，只能按资源的编号顺序申请。

## 死锁避免





## 死锁检测





## 死锁恢复

