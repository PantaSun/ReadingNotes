---
title: 第二部分5 死锁
date: 2019-03-20 20:44:12
tags: 
- 操作系统
categories:
- Reading notes
- 总结
---

## 主要内容

- 系统模型
- 死锁特征
- 死锁预防
- 死锁避免
- 死锁检测
- 死锁恢复



## 系统模型

### 死锁

两个或两个以上进程由于竞争资源导致系统无法推进，系统此时所处的状态就为死锁状态。也就是说死锁是一种系统状态。或者说当一组进程中的每个进程都在等待一个事件，而这个事件只能由这一组进程的另一个进程引起，那么这组进程就处于死锁状态。

### 产生原因

1. 资源相对不足
2. 进程的推荐顺序不合理



## 死锁特征

### 产生的必要条件

如果一个系统中以下四个条件同时满足，那么就会引起死锁：

1. 互斥：至少有一个资源必须处于非共享模式，即一次只有一个进程使用。如果另一个进程申请该资源，那么申请必须等到该资源释放为止。
2. 占有并等待：一个进程必须已经占有至少一个资源，并等待另一个资源，而这个另一资源被其他进程所占用。
3. 非抢占：资源不能被抢占，只能在进程完成任务后自动释放。
4. 循环等待（环路等待）：假设有一组等待进程，进程P0在等待的资源被进程P1占有，P2等待的资源被P3占有，以此类推Pn-1等待的资源被Pn占有，而Pn等待的资源被P0占有，即形成一个环路。

### 资源分配图

- 资源分配图由节点V的集合和边E的集合组成。

- 节点集合V可分成两种类型的节点：$P=\{ P_1, P_2 ,,, P_n\}，R=\{R_1,  R_2 ,,, R_n\}$。P是系统活动进程的集合，R是系统所有资源类型的集合

- 进程指向资源的边，称为申请边。例如$P_i -> R_i$，表示进程$P_i$已经申请了资源$R_i$的一个实例，并正在等待该资源。

- 资源指向进程的边，称为分配边。例如$rj->pj$，表示资源类型$R_j$的一个实例已经分配给进程$P_j$。

- 在图中，资源用正方形表示，进程用圆圈⭕️表示。方形中有小点，用来表示某种资源的实例数。
- 当一个进程向某个资源申请一个实例时，就在资源分配图中添加一条申请边。当该申请得到满足时，那么申请边就立即转换为分配边。
- 当进程不在需要访问资源时，它就释放资源，因此就要在图中删除该分配边。
- 资源分配图中出现环路不一定代表出现了死锁。因为可能每个资源有多个实例，这也就证明了环路是出现死锁的必要而非充分条件。
- 如果图中没有环，则一定没有死锁
- 如果图中有环，分两种情况：
  - 每个资源只有一个实例，那么就一定会产生死锁
  - 每个资源有多个实例，那么就是可能产生死锁

## 死锁处理方法

三种方法：

- 使用协议以预防死锁或避免死锁，确保系统不会进入死锁状态
- 可允许系统进入死锁，然后检测它，并加以恢复
- 可忽视这个问题，认为死锁不可能在系统内发生

## 死锁预防

基本思路就是破坏死产生的四个必要条件之一。

### "破坏"互斥

一般来说，非共享资源，必须使用互斥条件。比如说一台打印机不能同时打印多个进程的输出。而共享资源不要求互斥，因此不会涉及死锁。

所以通常不通过破坏互斥条件来预防死锁。

### "破坏"非抢占

非抢占理论上可以破坏，但在实际中有些情况是不允许破坏的，例如打印机资源和磁带驱动器。

### 破坏"占有并等待"

- 占有不等待：一次性资源分配法，就是在进程执行前就申请并获得所有需要的资源。缺点是资源浪费严重。有些资源只有在进程运行到某一步骤时才需要，如果在进程已开始就非配好，那么该资源就会在该进程执行的整个期间都是被该进程占有。
- 等待就不占有：也不可适合，这可能发生饥饿，一个进程如果需要多个常用资源，可能永久等待，因为其需要的资源只少有一个会已分配给其他进程。

### 破坏环路等待

- 有序资源使用法：将所有的资源进行编号，使用资源时，只能按资源的编号顺序申请。
- 也有资源浪费的缺点，但浪费程度低。
- 只是把资源编号并不能防止死锁，而是要靠程序员在编程时按资源编号顺序来编写程序。



## 死锁避免

死锁避免就是系统在面对进程的资源申请时，要考虑现有可用资源、现已分配给每个进程的资源和每个进程将来申请与释放的资源，以决定当前申请是否予以满足或让其等待，从避免死锁发生的可能性。

因此需要每个进程在建立时要说明可能需要的资源的种类和每种资源实例的个数的最大需求。

### 安全状态

只要能找到一个进程的**安全序列**，能使所有进程都能完成，这就是安全状态。如果系统能够按某个顺序为每个进程分配资源并能避免死锁，那么系统状态就是安全的。这个使系统处于安全状态的序列就是**安全序列**。

如果没有安全序列存在，那么系统就处于不安全状态。但是不安全状态不代表一定会进入死锁状态；而安全状态一定不会进入死锁状态。死锁状态是不安全状态。

### 银行家算法

在每次资源分配前，线通过算法计算一次，看是否会产生死锁（避免产生环路），若不会产生那就分配该资源，否则不予分配。

首先当新进程进入系统时，要声明该进程中每种资源所需的最大数量。

在资源分配时动态的进行死锁检测。

#### 基本思想

- 多实例
- 每个进程必须预先声明所需最大资源数
- 当一个进程请求资源时它可能必须要等待。
- 当一个进程获取所有资源时必须在完成任务后在有限时间内返还这些资源。

#### 需要的数据结构

- Available：长度为m的向量，表示每种资源现有实例的数量。$Available[j] = k$就表示资源$R_j$需要k个
- Max：n✖️m矩阵，定义每个进程的最大需求。例如$Max[i] [j] =k$，那么进程Pi最多可申请k个资源类型$R_j$的实例。 
- Allocation：n✖️m举证，定义每个进程现在所分配的各种资源类型的实例数量。$Allocation[i] [j] = k$，进程$P_i$现在已经分配k个资源$R_j$的实例。
- Need：n✖️m矩阵，定义每个进程还需要的剩余的资源。$Need[i] [j] = k$， 进程$P_i$还需要k资源$P_j$的实例
- $Need[i][j] = Max[i][j] - Allocation[i][j]$

#### 安全算法

本算法时用来确定计算机系统是否处于安全状态的算法：

1. 设Work和Finish分别为长度m和n的向量。初始化值为：Work=Available，对于所有的进程i，i=0～n-1，$Finish[i] = false$。初始时假设所有进程都未完成。

2. 查找符合下列两个条件的i：

   1⃣️：$Finish[i] = false$

   2⃣️：$Need_i <= Work$

   如果没有这样的进程i，那就转到第4步。

   就是从未完成的进程中找到一个所需资源小于等于可分配资源数的进程。

3. $Work = Work + Allocation_i$

   $Finish[i] = true$

   返回到第2步。

   假设将资源分配给找的的进程i，然后进程i由于获得了全部所需资源，最终会完成执行，并将其所占有的资源全部释放，也就是将进程i的$Allocation_i$加回可分配资源中。

4. 如果对所有进程i，$Finish[i] = true$，那么系统就处于安全状态，否则就是不安全状态。所有进程都能达到完成状态，那么就说名不会产生死锁。若存在几个进程无法完成，那么就是不安全状态，可能会发生死锁。



#### 进程Pi资源申请算法

设$Request_i$未进程$P_i$的请求量，这个请求量是一定小于等于$Need_i$的，要不然不符合最初进程声明的资源的最大需求数量。$Request_i[j] = k$，表示进程$P_i$需要资源$R_j$的实例数量为k个。

1. 如果$Request_i <= Need_i$，进入第2步，否则产生错误，原因正如上文所述

2. 如果$Request_i <= Availabe$，那么进入第三步。否则，$P_i$必须进行等待，因为没有那么多资源可供分配给进程i的这次请求

3. 先假设将资源按$Request_i$分配给进程i，并暂时修改各个数据结构：

   $Available = Available - Request_i;​$

   $Allocation_i = Allocation_i + Request_i;i$

   $Need_i = Need_i - Request_i​$

   然后调用上文所说的安全算法进行判断，验证在假设的情况下，系统是否处于安全状态。若是安全的那么就给进程 $P_i$ 分配其本次请求的资源；若不安全，那么$P_i$进程必须等待，且恢复到原来的资源分配状态，即将假设情况下修改的那些数据结构改回去。



## 死锁检测

### 每种资源只有一个实例：使用等待图

等待图中的一条辨Pi-》Pj表示，Pi申请的资源Rq现在已经分配给Pj，所以进程Pi要等待进程Pj执行完毕后才有机会得到资源Rq。

当等待图中出现一个有向环时，系统就存在死锁。

### 每种资源有多个实例：使用随时间变换的数据结构



## 死锁恢复

- 一个方法就是简单的终止一个或多个进程以打破循环等待
- 从一个或多个死锁进程那里抢占一个或多个资源。

### 进程终止

- 终止所有死锁进程：这样做代价大，因为某些进程可能已经计算了很长时间了，只差一个资源就能结束了，结果被终止了，那前边的计算所用到的时空资源和系统资源都浪费了。
- 一次只终止一个进程，直到取消死锁循环为止。这样做开销也相当大，因为没终止一个进程都要进行一次死锁检测。

### 资源抢占

要使用资源抢占就要解决三个问题：

1. 选择一个牺牲品：就是要选择哪个进程被抢占。
2. 回滚：如果对一个进程实施了抢占，那么被抢占的进程必须回滚到某个安全状态。
3. 饥饿：如何确保某个进程不会总是被抢占。因为被抢占就会回滚，所以可以限制一个进程的回滚次数，这样就不会无限被抢占了。

