## CPU如何与外设通信

CPU与外设通过IO借口进行通信的。

IO接口用来协调转换CPU与外设，它是连接CPU与外设的逻辑控制部件。

### IO接口的一些功能

1. 设置数据缓冲，解决CPU与外设的处理速度不匹配问题
2. 设置信号电平转换电路。
3. 设置数据格式。外设多种多样，它们的输出也是不同的，有模拟信号也有数字信号。但是CPU只能处理数字信号，所以此时IO接口就相当于一个数/模或模/数转换器。
4. 设置时序电路来同步CPU和外部设备。
5. 提供地址译码。

总结起来就是：IO接口就是“翻译”。

### CPU如何选择与某个接口通信

IO接口有很多，但是同一时刻，CPU只能与一个接口通信。决定某一个时刻由谁来和CPU通信的工作是由输入输出控制中心（I/O control hub，ICH）做的。ICH也就是主板上的南桥芯片。

###CPU如何与IO接口通信

IO接口通过寄存器的方式与CPU通信。IO接口中有专用于数据交互的寄存器，一般称为端口。

一般的IO接口有一组端口。

可以通过内存映射的方式来访问这些端口，即把一些内存地址作为端口的映射，访问这些内存地址也就相当于访问可这些端口。

#### 汇编指令

**in指令：从端口中读取数据**

- in al, dx 
- In ax, dx
- 其中al和ax用来存储从端口获取的数据，dx是端口号，这里是固定操作，源操作数（端口号）必须是dx，而目的操作数也必须是ax或al，至于用ax还是al要取决于dx端口指代的寄存器是16位宽度还是8位宽度。

**out指令：往端口中写入数据**

- out dx, al
- out dx, ax
- 形式与in类似只是源和目的操作数进行了切换，毕竟输入和输出是相反的。
- out指令之可以使用立即数来代替dx指定端口号



## bochs调试

bochs中的字不是2字节而是4四节：

- b表示1个字节
- h表示半个字，也就是2个字节
- w表示1个字，4个字节
- g表示双字，8个字节



## 让MBR使用硬盘

通过与接口通信来读区硬盘。

这里让MBR读区放在硬盘上的laoder（加载器），loader就是用来加载操作系统的。

目前还没写好操作系统，loader中只是放着能在屏幕打印字符串的代码。

改写MBR后的代码：

```nasm
;主引导程序 Master Boot Record
;----------------------------------------------------------------
%include "boot.inc"		;导入boot配置文件
SECTION MBR vstart=0x7c00
	mov ax, cs
   	mov ds, ax
   	mov es, ax
   	mov ss, ax
   	mov fs, ax 			;4-8使用cs寄存器的值取初始化其他寄存器
   	mov sp, 0x7c00		;初始化栈指针
   	mov ax, 0xb800
   	mov gs, ax

;清屏，利用0x06号功能，上卷全部行即可清屏
;---------------------------------------------------------------
;INT 0x10 功能号：0x06 功能描述：上卷窗口
;---------------------------------------------------------------
;输入：
;AH = 上卷的行数（0表示全部）
;AL = 上卷行属性
;(CL, CH) = 窗口的左上角的坐标
;(DL, DH) = 窗口的右下角的坐标
;无返回值：
	mov ax, 0x600
	mov bx, 0x700
	mov cx, 0      			;左上角（0,0）		
	mov dx, 0x184f			;右下角（80,25）
							;VGA文本模式中，一行只能容纳80个字符，共25行
							;下标从0开始所以0x18=24, 0x4f=79
	int 0x10				;int 0x10

;------------------------ end -----------------------------------


;--------------------通过操作显卡来打印--------------------------
	mov byte [gs:0x00], '1'
	mov byte [gs:0x01], 0xA4

	mov byte [gs:0x02], ' '
	mov byte [gs:0x03], 0xA4

	mov byte [gs:0x04], 'M'
	mov byte [gs:0x05], 0xA4

	mov byte [gs:0x06], 'B'
	mov byte [gs:0x07], 0xA4

	mov byte [gs:0x08], 'R'
	mov byte [gs:0x09], 0xA4
;----------------------------- end -------------------------------


;--------------------- 设置函数需要的参数 ------------------------
	mov eax, LOADER_START_SECTOR	;起始扇区lba地址
	mov bx, LOADER_BASE_ADDR	;写入的地址
	mov cx, 1			;待读入的扇区数
	call rd_disk_m_16		;调用函数将加载器加载到内存中
	jmp LOADER_BASE_ADDR		;跳转到loadbooter开始执行加载器程序
;-------------------------- end ----------------------------------

;------------------- 读取磁盘第n个扇区 ---------------------------
rd_disk_m_16:
	; eax = LBA扇区号
	; bx = 将数据写入的内存地址
	; cx = 读入的扇区数
	;对寄存器进行备份
	mov esi, eax
	mov di, cx

; 1 设置要读取的扇区数 0x1f2号端口是用来设置要读取扇区数的
	mov dx, 0x1f2
	mov al, cl
	out dx, al

	mov eax, esi

;2 将LBA地址存入0x1f3 ~ 0x1f6
	;LBA地址7～0位写入0x1f3
	mov dx, 0x1f3
	out dx, al
	
	;LBA地址15～8位写入0x1f4
	mov cl, 8
	shr eax, cl 	;eax右移8位
	mov dx, 0x1f4
	out dx, al

	;LBA地址23～16位写入0x1f5
	shr eax, cl
	mov dx, 0x1f5
	out dx, al

	;LBA地址27～24位存放在device寄存器中，也就是0x1f6
	shr eax, cl
	and al, 0x0f	;将除了后四位的其他位置为零
	or al, 0xe0		;将device高四位设置为1110表示lba模式，
					;其中第4位表示主盘还是从盘，0表示主盘，1表示从盘
					;第6位为1表示LBA模式，为0表示CHS模式
	mov dx, 0x1f6
	out dx, al

; 3 向0x1f7端口写入读命令，0x20
	mov dx, 0x1f7
	mov al, 0x20
	out dx, al

; 4 检查硬盘状态，还是0x1f7端口，
; 在写的时候表示用来接受命令，当读的时候表示硬盘状态
    .not_ready:
	nop		;无操作，使程序计数器加一，即占用一个机器时钟
	in al, dx
	and al, 0x88	;第4位为1表示硬盘控制器已经准备好数据
					;第7位为1表示硬盘忙
					;0x88==10001000，该句用来获取第4位和第7位
	cmp al, 0x08	;比较第7位，就是将al与0x08相减
	jnz .not_ready	;若结果不等于0就跳转到标签开始位置，即循环
					;若等于0说明数据已经准备号，硬盘不在忙

; 5 从0x1f0端口读数据，该端口就是管数据进出的。该寄存器为16位所以一次读写2字节
; 一个扇区512字节，所以需要256次读写
	mov ax, di
	mov dx, 256
	mul dx
	mov cx, ax

	mov dx, 0x1f0
    .go_on_read:
	in ax, dx
	mov [bx], ax
	add bx, 2
	loop .go_on_read
	ret
	
;-------------------------- 读取结束 ------------------------------------

	;message db "1 MBR"
	times 510-($-$$) db 0
	db 0x55, 0xaa

```

这里在屏幕打印字符串不使用之前的中断方式，而是通过操作显卡接口来进行打印输出。

在“rd_disk_m_16”这个函数中，里面的代码虽然很多，但都是对硬盘接口的基本操作。

