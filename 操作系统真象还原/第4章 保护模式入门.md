## 保护模式概述

实模式的一些特点（缺点）：

1. 实模式下操作系统和用户程序属于同一特权级
2. 用户所引用的地址都是指向真实的物理地址，即逻辑地址等于物理地址
3. 用户程序可以自由修改段基址

上述三条存在严重的安全隐患，一旦用户恶意操作内存，将产生不可预计的后果。

4. 访问超过64KB的内存区域时要切换段基址
5. 一次只能运行一个程序，无法充分利用计算机资源
6. 共20条地址线，最大可用内存为1MB，这不符合现在海量数据的环境。



为了克服这些缺点，处理器厂商开发出保护模式。因此物理内存地址不能直接被程序直接访问，程序内部的地址（虚拟地址）需要被转化为物理地址后再去访问。

地址转换是由处理器和操作系统共性协作完成的，处理器在硬件上提供地址转换部件，操作系统提供转换过程中所需要的页表。

**实模式：**是32位CPU中的概念，指32位的CPU处于16位运行模式下的状态。



### 寄存器的扩展

因为在32位CPU中地址总线和数据总线也扩展到32位，其寻址空间达到了2的32次方，即4GB。为了让一个寄存器能够访问到4GB空间，需要将寄存器宽度提升至32位。

**除了段寄存器外，其他寄存器都由16位扩展到32位。**在原来的寄存器前加个e表示扩展。

寄存器中低16位是为了兼容实模式，可以单独使用。高16位没办法单独使用，只有在用32位寄存器时才有机会用到他们。



在保护模式中偏移地址和实模式中的一样，但是段基址就不一样了。保护模式中使用段描述符来存放内存段的描述信息，这些描述符存放在一个全局描述符表中GDT。这时段寄存器中放的只是一个选择子，用来索引GDT中的段描述符。

GDT因为比较大所以存放在内存中，由GDTR寄存器指向该表首地址。

### 寻址扩展

在实模式下，内存寻址只能使用几个固定的寄存器来操作，如基址寄存器bx、bp和变址寄存器si、di。

到了保护模式下，内存寻址的基址寄存器可以是所有32位的通用寄存器，变址寄存器可以是除了esp之外的所有32位通用寄存器。

### 运行模式反转

为了兼容16位运行模式，32位指令格式也与16位相同。在这种情况下位了区分不同运行模式，32位运行模式重新定义各寻址方式、寄存器的编码。

但是编译器不知道你是想将一句代码编译成16位模式的还是32位模式的，因此可以使用一个位指令bits来通知编译器：

- [bits 16]告诉编译器，下面的代码编译成16位的机器码
- [bits 32]告诉编译器，下面的代码编译成32位的机器码
- 所谓“下面”是指从当前bits到下一个bits之间的代码
- 中括号可以省略



#### 反转前缀

- 操作数反转前缀0x66：如果要用另一种模式下的操作数大小，需要在指令前添加指令前缀0x66，将当前模式临时改变成另一种模式，这就是反转的意思。不管当前模式是什么，总能反转成相反的运行模式（相反值得是16位和32位相反）

- 寻址方式反转前缀0x67，比如在16位模式下使用了eax寄存器，当编译成机器码时就会有一个0x67前缀。

### 指令扩展

**关于push命令：**

- push 8位立即数：由于CPU要考虑对其，所以操作数要么是16位要么是32位，所以8位立即数会被扩展为各模式下默认操作数宽度，即实模式下8位立即数扩展为16位，保护模式下扩展为32位。
- push 16位立即数，CPU直接将其入栈，sp-2
- push 32位立即数，CPU直接将其入栈，sp-4

**段寄存器的入栈，无论在哪种模式下，都按当前模式的默认操作数大小入栈。**

**对于通用寄存器和内存入栈，无论实模式还是保护模式：**

- 如果压入的是16位数据，栈指针减2
- 如果压入的是32位数据，栈指针减4

## 全局描述符表GDT（Global Descriptor Table）

- 段描述符占8个字节，其中段基址占4个字节即32位
- 段界限表示段边界的扩展最值，就是表示段的边界、大小、范围。
- 段基址和段界限在段描述符中不是连续存放的，这是为了兼容当时80286CPU的。

#### 详细说明段描述符

**高32位：**

| 31~24       | 23   | 22   | 21   | 20   | 19~16       | 15   | 14~13 | 12   | 11~8 | 7~0         |
| ----------- | ---- | ---- | ---- | ---- | ----------- | ---- | ----- | ---- | ---- | ----------- |
| 段基址31~24 | G    | D/B  | L    | AVL  | 段界限19~16 | P    | DPL   | S    | TYPE | 段基址23~16 |

**低32位：**

|   31~16    |    15~0    |
| :--------: | :--------: |
| 段基址15~0 | 段界限15~0 |



- 从低32位开始：0～15位用来存放段界限的0～15位，16～31位用来存放段基址的0～15位
- 高32位中（这里高32位位了说明也从0开始算起，也就是0～31，但实际表示的是32～63）：0～7位是段基址的16～23，24～31是段基址的24～31，算上低32位中的16～31位段基址的全部32位已经齐了。
- 高32位中：8～11位是type字段。共四位，用来指定本描述符的类型。要在S字段确定后才有意义。
  - 当S为1时，即非系统段时，type有两种情况：
    - 代码段：四位从低到高分别为A、C、R、X
    - 数据段：四位从低到高分别为A、E、W、X
- 高32位中：第12位是S字段，用来指示是否是系统段。S为0表示系统段，S为1表示非系统段（数据段，代码段也算在数据段中）。S跟type字段配合使用。
- 高32位中：13～14位时DPL字段 Descriptor Privilege Level，特权描述符，指所代表的内存段的特权级。
- 高32位中：15位是P字段，Present，即段是否存在。P为1则该段在内存中，P为0则不在。
- 高32位中：16~19是段界限的16~19，即20位段界限全了
- 高32位中：20是AVL字段，表示段是否可用的。是针对用户来说的
- 高32位中：21位是L字段。用来设置是否是64位代码段，1表示64位代码段否则为32位代码段
- 高32位中：22是D/B字段，用来指示有效地址及操作数的大小
  - 对于代码段来说，此位是D位：
    - 若D为0，表示指令中的有效地址和操作数是16位
    - 若D为1，表示指令中的有效地址及操作数是32位
  - 对于栈段来说，此位是B位，用来指定操作数大小，此操作数涉及到栈指针寄存器的选择及栈的地址上限：
    - 若B为0，使用sp寄存器，栈的起始地址是16位寄存器的最大寻址范围：0xFFFF
    - 若B位1，使用esp寄存器，也就是栈的起始地址是32位寄存器的最大寻址范围：0xFFFFFFFF
- 高32位中：23是G字段，表示粒度，用来指定段界限的单位大小
- 高32位中：24~31是段基址的第24~31位，段基址也全了

#### GDT、LDT以及段选择子

GDT是存放在内存中的，那么如何直到Gdt的位置呢？这就需要gdtr寄存器，该寄存器专门用来存储gdt的内存地址和大小。gdtr是个48位寄存器，低16位是gdt以字节为单位的界限值，后32位就是gdt的起始地址。

**段选择子**

段寄存器在实模式下存储的是段基址，即内存段的起始地址。在保护模式下，段寄存器中存放的是一个叫段选择子的东西。

段寄存器大小为16位，其低2位（0~1）用来存放rpl，即请求特权级。

第2位是TI位，指明选择子是在gdt中还是在ldt中索引描述符。

剩下的13位就是描述符的索引值。2的13次方=8192，所以最多可以索引8192个段。

gdt中的第0个描述符不可使用，因为如果选择子忘记初始化其值便会是0，就会访问到第0个描述符。为了避免因忘记初始化而选择第0个描述符，直接将第0个设置为不可用。

#### 打开A20地址

在8086的16位cpu时代地址总线是20为的，最大寻址空间是0x00000~0xFFFFF。当地址超出最大地址时，会采用地址回绕，即重新回到0开始。这个就行对0xFFFFF取模。

到了80286时代，地址总线24位，地址最大值位0x10FFEF。为了兼容8086，在实模式下也希望能够实现地址回绕，于是使用A20（第21位地址线，这里也称为A20Gate）来控制是否开启地址回绕：

- 当A20Gate被打开，当访问0x100000~0x10FFEF之间的地址时，cpu就可以真正访问这块物理地址
- 当A20Gate被禁止时，就开启地址回绕模式。

当我们要使用保护模式时，地址总线是32位的，也就是要访问更大是的内存空间，所以要开启A20Gate，具体代码：

```asm
in al, 0x92
or al, 0000_0010B
out 0x92, al
```

就是将端口0x92的第一位置为1即可

#### 保护模式的开关，CR0寄存器的PE位

PE（Protection Enable）

代码：

```asm
mov eax, cr0
or eax, 0x00000001
mov cr0, eax
```

### 总结：进入保护模式的三个步骤

1. **设置gdt全局描述符表**
2. **打开A20Gate，以便于访问1M以上内存**
3. **设置CR0寄存器的PE字段（第0位）为1，这个表明已经进入了保护模式中。**

### 修改mbr.S、boot.inc和loader.S

#### 平坦模式：

平坦模型是相对于多段模型而言的，即平坦模型就一个段。在实模式下，访问超过64KB的内存时，需要重新指定不同的段基址，通过这种迂回变通的方式才能达到目的。在保护模式下，由于其是32位地址总线，寻址范围能够达到4GB，而其段内偏移地址也是32位。所以在32位环境下，用一个段就能访问到硬件所支持的所有内存。

#### boot.inc

```asm
;--------------------- loader and kernel ----------------
LOADER_BASE_ADDR equ 0x900
LOADER_START_SECTOR equ 0x2
;-------------------- gdt描述符属性 ---------------------
DESC_G_4K equ 	  1_00000000000000000000000b	;第23位（从0开始算）G字段，粒度
DESC_D_32 equ  	   1_0000000000000000000000b	;第22位 D/B字段段 这里选择32位
DESC_L    equ       0_000000000000000000000b	;第21位 L字段 L为0表示32位代码段
DESC_AVL  equ        0_00000000000000000000b	;第20位 AVL字段

DESC_LIMIT_CODE2 equ  1111_0000000000000000b 	;段界限19～16
DESC_LIMIT_DATA2 equ DESC_LIMIT_CODE2
DESC_LIMIT_VIDEO2 equ  0000_000000000000000b
DESC_P 		equ 	  	  1_000000000000000b	;第15位 P字段，描述读是否在内存中，1表示在
DESC_DPL_0 equ             00_0000000000000b	;第14～13 DPL
DESC_DPL_1 equ             01_0000000000000b
DESC_DPL_2 equ             10_0000000000000b
DESC_DPL_3 equ             11_0000000000000b
DESC_S_CODE equ              1_000000000000b	;第12位 S字段 是否使系统段 1表示非系统段，又分为代码段和数据段，此处为代码段
DESC_S_DATA equ DESC_S_CODE			;数据段
DESC_S_SYS equ               0_000000000000b	;系统段
DESC_TYPE_CODE	equ	          1000_00000000b	;第11～8位 type字段，配和S字段使用 代码段11～8分别是x、c、r、a，这里是代码段
						                        ;x=1可执行，c=0非一致性，r=0不可读，a=0已访问位a清零，每当被cpu访问过a就设为1
DESC_TYPE_DATA	equ 	      0010_00000000b	;数据段11～8位分别是x、e、w、a
						                        ;x=0不可知行，e=0向上扩展，w=1可写，a=0已访问位a清零
DESC_CODE_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + \
DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + \
DESC_P + DESC_DPL_0 + DESC_S_CODE + \
DESC_TYPE_CODE + 0x00

DESC_DATA_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + \
DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + \
DESC_P + DESC_DPL_0 + DESC_S_DATA + \
DESC_TYPE_DATA + 0x00

DESC_VIDEO_HIGH4 equ (0x00<<24) + DESC_G_4K + DESC_D_32 + \
DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + \
DESC_P + DESC_DPL_0 + DESC_S_DATA + \
DESC_TYPE_DATA + 0x0b

;------------------ 选择子属性 --------------------------
RPL0 equ 00b
RPL1 equ 01b
RPL2 equ 10b
RPL3 equ 11b
TI_GDT equ 000b
TI_LDT equ 100b


```

**一些解释**

- 段描述符大小为64位，8个字节，其中低32位比较简单，分别是16位的段基址的一部分和16位的段界限的一部分。而高32位比较复杂，涉及到很多参数，所以在配置文件中进行设置。

- 这里主要设置的三种段描述符的高32位，分别是数据段、代码段和显存段。

- 代码中相关字段均体现在名字上，如DESC_G_4K，表示G字段，且粒度为4K。

- 这里DESC_LIMIT_CODE2、DESC_LIMIT_DATA2和DESC_LIMIT_VIDEO2分别是代码段、数据段以及显存段的段界限最后四位部分。

- 最后用这些字段加起来合成DESC_CODE_HIGH4、DESC_DATA_HIGH4和DESC_VIDEO_HIGH4三种段的高4字节（高32位）。

- 注意高32位中的低8位是段基址中间部分，数据段和代码段采用平坦模式，所以段基址都从0开始。而显存段为了方便操作不使用平坦模式，直接把其段基址设置位文本模式的起始地址0xb8000，也就是0x000b8000（因为是32位地址）所以位了将该基址存入段描述符中，要将地址分开，其中低16位0x8000要存入段描述符的低32位中，段基址的16～23位，即0x0b要存入段描述符高32位部分中的低8位中，所以DESC_VIDEO_HIGH4中的等式最后要加上0xb，而代码段和数据段都是从0开始，所以只是加上0x00。

- 这三个段描述符的高32位中的最高8位都是0，所以用0x00左移24位。



#### loader2.S

```asm
;------------------------------- boot loader ----------------------------
	%include "boot.inc"
	section loader vstart=LOADER_BASE_ADDR
	LOADER_STACK_TOP equ LOADER_BASE_ADDR
	jmp loader_start

; 构建gdt及其内部的描述符
	GDT_BASE:	dd 0x00000000		;第0个描述符不使用设为0
		  	    dd 0x00000000
	
	CODE_DESC:	dd 0x0000FFFF		;先设置低32位，即低4字节，最低两字节位段界限的低16位全设置为1
									;高四字节是段基址的低16位
			    dd DESC_CODE_HIGH4	;高32位，即高4字节在配置文件中设置

	DATA_STACK_DESC:	dd 0x0000FFFF
						dd DESC_DATA_HIGH4

	VIDEO_DESC:	dd 0x80000007		;limit=(0xbffff-0xb8000)/4K=0x7
				dd DESC_VIDEO_HIGH4

	GDT_SIZE equ $ - GDT_BASE
	GDT_LIMIT equ GDT_SIZE - 1
	times 60 dq 0				;预留60个描述符的空位

	SELECTOR_CODE 	equ (0x0001<<3) + TI_GDT + RPL0	;相当于(CODE_DESC-GDT_BASE)/8 + TI_GDT + RPL0
	SELECTOR_DATA 	equ (0x0002<<3) + TI_GDT + RPL0
	SELECTOR_VIDEO 	equ (0x0003<<3) + TI_GDT + RPL0

; 以下是gdt的指针，前2字节是gdt的界限，后四字节是gdt起始地址
	gdt_ptr dw GDT_LIMIT
			dd GDT_BASE
	loadermsg db '2 loader in real.'

;----------------------------- loader_start 函数 -------------------------
loader_start:
	

; 打印字符串

	mov sp, LOADER_BASE_ADDR
	mov bp, loadermsg	;ES:BP = 字符串地址
	mov cx, 17		;字符串长度
	mov ax, 0x1301
	mov bx, 0x001f
	mov dx, 0x1800
	int 0x10

; 准备进入保护模式
	; 1. 打开A20Gate
	in al, 0x92
	or al, 0000_0010B
	out 0x92, al
	
	; 2. 加载gdt
	lgdt [gdt_ptr]

	; 3. 将cr0的pe置为1
	mov eax, cr0
	or eax, 0x00000001
	mov cr0, eax

	;jmp dword SELECTOR_CODE:p_mode_start
	jmp SELECTOR_CODE:p_mode_start		;清空流水线

[bits 32]
p_mode_start:
	mov ax, SELECTOR_DATA
	mov ds, ax
	mov es, ax
	mov ss, ax
	mov esp, LOADER_STACK_TOP
	mov ax, SELECTOR_VIDEO
	mov gs, ax
	
	mov byte [gs:160], 'p'

	jmp $


```

**一些解释**

- LOADER_STACK_TOP是用于loader在保护模式下的栈，它等于LAODER_BASE_ADDR，虽然这是loader在实模式下的栈指针地址。但是进入保护模式后，可以为保护模式下的esp初始化，于是就用相同地址作为栈顶。该0x900是loader被加载到内存中的位置，在此地址之下便是栈。
- GDT只是内存中的一片区域，每8个字节就是一个表项。这里采用4个字节4个字节的定义方式。程序编译后的地址时从上到下一次增高，所以先dd（define double-word，定义双字变量）低四字节，如代码段的dd 0x0000FFFF，其中四个F是用来指定段界限的低16位，即全为1，四个0是指定段基址的低16位，从零开始，所以全是0。然后dd DESC_CODE_HIGH4，这里是在boot.inc中配置好了的高32位。
- 实模式下使用平坦模式，即整个内存在一个段里，所以代码段和数据段的段基址都是从0开始，段界限也相同。
- 显存段之前说过段基址采用0xb8000，0xb在高32位中，即在boot.inc已经设置在DESC_VIDEO_HIGH4中了，0x8000要设置在低32位中，所以dd 0x80000007，至于段界限低16位为什么设置位0x0007，因为这里使用文本模式显示器的内存配置，其地址范围是0xb8000～0xbffff，所以有 (0xbffff - 0xb8000)/4KB=7。
- 关于显存地址，首先这里没有使用分页功能，所以，线性地址就等于物理地址，因为在32位系统中，物理地址本身就能达到4GB，因此在没分页的基础上实模式下操作的显存地址就等于保护模式下操作的地址。
- lgdt 用来将GDT的首地址存入gdtr寄存器中。
- 打印字母P时，只需将‘P’的ascii值存入显存段所在内存即可。



### 微处理器架构

#### 清空流水线

CPU是按照程序中指令顺序来填充流水线的，就是说按照程序计数器PC中的值来装载流水线的，当前指令和下一条指令在空间上是紧挨着的。一个指令在执行，下一条指令已经被送上流水线译码，下下条指令已经被送上流水线取指了。但是如果最初执行的那条指令是个jmp指令，即不会按顺序执行接下来的二三两条指令，那么这个两条上了流水线的指令就没意义了，因此CPU在遇到无条件转移jmp指令时，会清空流水线。

## 使用远跳转指令清空流水线，更新段描述符缓冲寄存器

### 这样做解决了两个问题

#### 1. 更新段描述符缓冲寄存器

因为它们在更新前还是实模式下的值，进入保护模式后需要填入正确的信息。

**段缓冲寄存器**

段缓冲寄存器首次出现在80286中，是为了加速访问段描述符中的信息而设置的。

在实模式下，访问内存时需要用段基址左移4位，然后加上偏移地址最终得到实际内存地址。而有了段描述符缓冲器后，可以将段基址左移4位的值放入缓冲器中，这样下次再有段内访问时就不需要每次都要左移计算了。

也就是说段缓冲寄存器在CPU的实模式和保护模式中都要使用，在不重新引用一个段时，段描述符缓冲器中的内容是不更新的。而且不论在哪中模式下，CPU都以段描述符缓冲器中的内容为主。

所以在进入保护模式后，由于此时缓冲寄存器中仍然存放实模式下的缓冲内容，这对保护模式来说必然会造成错误，所以就需要更新之。

### 2. 流水线指令译码错误

在默认情况下，如果未使用bits伪指令来设置运行环境，编译器默认按照16位是模式编译代码。而CPU为了提高效率使用了流水线，这样在进入保护模式之前，保护模式中开始的几句代码（也就是bits伪指令之后的一两句代码）可能已经进入流水线了，提前进入流水线会被提前译码，因此此时还未进入保护模式，CPU会将这几句代码按照16位指令格式译码。但是由于这几句代码在bits伪指令之后，编译器编码是按照32位指令格式编码的，这样也必然会产生错误。所以就需要清空流水线。



### 总结

综上所述，解决问题的关键是既要改变代码段描述符缓冲器的值，又要清空流水线。对应代码中就是`jmp dword SELECTOR_CODE:p_mode_start`

该代码是按照16位指令格式编码的，但在执行该代码时已经进入保护模式了，所以是属于16位保护模式