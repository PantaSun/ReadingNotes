## 保护模式概述

实模式的一些特点（缺点）：

1. 实模式下操作系统和用户程序属于同一特权级
2. 用户所引用的地址都是指向真实的物理地址，即逻辑地址等于物理地址
3. 用户程序可以自由修改段基址

上述三条存在严重的安全隐患，一旦用户恶意操作内存，将产生不可预计的后果。

4. 访问超过64KB的内存区域时要切换段基址
5. 一次只能运行一个程序，无法充分利用计算机资源
6. 共20条地址线，最大可用内存为1MB，这不符合现在海量数据的环境。



为了克服这些缺点，处理器厂商开发出保护模式。因此物理内存地址不能直接被程序直接访问，程序内部的地址（虚拟地址）需要被转化为物理地址后再去访问。

地址转换是由处理器和操作系统共性协作完成的，处理器在硬件上提供地址转换部件，操作系统提供转换过程中所需要的页表。

**实模式：**是32位CPU中的概念，指32位的CPU处于16位运行模式下的状态。



### 寄存器的扩展

因为在32位CPU中地址总线和数据总线也扩展到32位，其寻址空间达到了2的32次方，即4GB。为了让一个寄存器能够访问到4GB空间，需要将寄存器宽度提升至32位。

**除了段寄存器外，其他寄存器都由16位扩展到32位。**在原来的寄存器前加个e表示扩展。

寄存器中低16位是为了兼容实模式，可以单独使用。高16位没办法单独使用，只有在用32位寄存器时才有机会用到他们。



在保护模式中偏移地址和实模式中的一样，但是段基址就不一样了。保护模式中使用段描述符来存放内存段的描述信息，这些描述符存放在一个全局描述符表中GDT。这时段寄存器中放的只是一个选择子，用来索引GDT中的段描述符。

GDT因为比较大所以存放在内存中，由GDTR寄存器指向该表首地址。

### 寻址扩展

在实模式下，内存寻址只能使用几个固定的寄存器来操作，如基址寄存器bx、bp和变址寄存器si、di。

到了保护模式下，内存寻址的基址寄存器可以是所有32位的通用寄存器，变址寄存器可以是除了esp之外的所有32位通用寄存器。

### 运行模式反转

为了兼容16位运行模式，32位指令格式也与16位相同。在这种情况下位了区分不同运行模式，32位运行模式重新定义各寻址方式、寄存器的编码。

但是编译器不知道你是想将一句代码编译成16位模式的还是32位模式的，因此可以使用一个位指令bits来通知编译器：

- [bits 16]告诉编译器，下面的代码编译成16位的机器码
- [bits 32]告诉编译器，下面的代码编译成32位的机器码
- 所谓“下面”是指从当前bits到下一个bits之间的代码
- 中括号可以省略



#### 反转前缀

- 操作数反转前缀0x66：如果要用另一种模式下的操作数大小，需要在指令前添加指令前缀0x66，将当前模式临时改变成另一种模式，这就是反转的意思。不管当前模式是什么，总能反转成相反的运行模式（相反值得是16位和32位相反）

- 寻址方式反转前缀0x67，比如在16位模式下使用了eax寄存器，当编译成机器码时就会有一个0x67前缀。

### 指令扩展

**关于push命令：**

- push 8位立即数：由于CPU要考虑对其，所以操作数要么是16位要么是32位，所以8位立即数会被扩展为各模式下默认操作数宽度，即实模式下8位立即数扩展为16位，保护模式下扩展为32位。
- push 16位立即数，CPU直接将其入栈，sp-2
- push 32位立即数，CPU直接将其入栈，sp-4

**段寄存器的入栈，无论在哪种模式下，都按当前模式的默认操作数大小入栈。**

**对于通用寄存器和内存入栈，无论实模式还是保护模式：**

- 如果压入的是16位数据，栈指针减2
- 如果压入的是32位数据，栈指针减4

## 全局描述符表GDT（Global Descriptor Table）

- 段描述符占8个字节，其中段基址占4个字节即32位
- 段界限表示段边界的扩展最值，就是表示段的边界、大小、范围。
- 段基址和段界限在段描述符中不是连续存放的，这是为了兼容当时80286CPU的。

#### 详细说明段描述符

**高32位：**

| 31~24       | 23   | 22   | 21   | 20   | 19~16       | 15   | 14~13 | 12   | 11~8 | 7~0         |
| ----------- | ---- | ---- | ---- | ---- | ----------- | ---- | ----- | ---- | ---- | ----------- |
| 段基址31~24 | G    | D/B  | L    | AVL  | 端界限19~16 | P    | DPL   | S    | TYPE | 段基址23~16 |

**低32位：**

|   31~16    |    15~0    |
| :--------: | :--------: |
| 段基址15~0 | 段界限15~0 |



- 从低32位开始：0～15位用来存放段界限的0～15位，16～31位用来存放段基址的0～15位
- 高32位中（这里高32位位了说明也从0开始算起，也就是0～31，但实际表示的是32～63）：0～7位是段基址的16～23，24～31是段基址的24～31，算上低32位中的16～31位段基址的全部32位已经齐了。
- 高32位中：8～11位是type字段。共四位，用来指定本描述符的类型。要在S字段确定后才有意义。
  - 当S为1时，即非系统段时，type有两种情况：
    - 代码段：四位从低到高分别为A、C、R、X
    - 数据段：四位从低到高分别为A、E、W、X
- 高32位中：第12位是S字段，用来指示是否是系统段。S为0表示系统段，S为1表示非系统段（数据段，代码段也算在数据段中）。S跟type字段配合使用。
- 高32位中：13～14位时DPL字段 Descriptor Privilege Level，特权描述符，指所代表的内存段的特权级。
- 高32位中：15位是P字段，Present，即段是否存在。P为1则该段在内存中，P为0则不在。
- 高32位中：16~19是段界限的16~19，即20位段界限全了
- 高32位中：20是AVL字段，是否可用的。是针对用户来说的
- 高32位中：21位是L字段。用来设置是否是64位代码段，1表示64位代码段否则为32位代码段
- 高32位中：22是D/B字段，用来指示有效地址及操作数的大小
- 高32位中：23是G字段，表示粒度，用来指定段界限的单位大小
- 高32位中：24~31是段基址的第24~31位，段基址也全了

#### GDT、LDT以及段选择子

GDT是存放在内存中的，那么如何直到Gdt的位置呢？这就需要gdtr寄存器，该寄存器专门用来存储gdt的内存地址和大小。gdtr是个48位寄存器，低16位是gdt以字节为单位的界限值，后32位就是gdt的起始地址。

**段选择子**

段寄存器在实模式下存储的是段基址，即内存段的起始地址。在保护模式下，段寄存器中存放的是一个叫段选择子的东西。

段寄存器大小为16位，其低2位（0~1）用来存放rpl，即请求特权级。

第2位是TI位，指明选择子是在gdt中还是在ldt中索引描述符。

剩下的13位就是描述符的索引值。2的13次方=8192，所以最多可以索引8192个段。

gdt中的第0个描述符不可使用，因为如果选择子忘记初始化其值便会是0，就会访问到第0个描述符。为了避免因忘记初始化而选择第0个描述符，直接将第0个设置为不可用。

#### 打开A20地址

在8086的16位cpu时代地址总线是20为的，最大寻址空间是0x00000~0xFFFFF。当地址超出最大地址时，会采用地址回绕，即重新回到0开始。这个就行对0xFFFFF取模。

到了80286时代，地址总线24位，地址最大值位0x10FFEF。为了兼容8086，在实模式下也希望能够实现地址回绕，于是使用A20（第21位地址线，这里也称为A20Gate）来控制是否开启地址回绕：

- 当A20Gate被打开，当访问0x100000~0x10FFEF之间的地址时，cpu就可以真正访问这块物理地址
- 当A20Gate被禁止时，就开启地址回绕模式。

当我们要使用保护模式时，地址总线是32位的，也就是要访问更大是的内存空间，所以要开启A20Gate，具体代码：

```asm
in al, 0x92
or al, 0000_0010B
out 0x92, al
```

就是将端口0x92的第一位置为1即可

#### 保护模式的开关，CR0寄存器的PE位

PE（Protection Enable）

代码：

```asm
mov eax, cr0
or eax, 0x00000001
mov cr0, eax
```

### 总结：进入保护模式的三个步骤

1. **设置gdt全局描述符表**
2. **打开A20Gate，以便于访问1M以上内存**
3. **设置CR0寄存器的PE字段（第0位）为1，这个表明已经进入了保护模式中。**

