## BIOS（Basic Input Output System）

Bios提供的功能

- 基本输入输出的程序
- 系统设置信息
- 开机后自检程序
- 系统自启动程序等

Bios工作流程

- Bios初始化完成之后它就会从磁盘上读引导扇区，引导扇区只有512字节，加载到0x7c00
- 跳转到CS:IP = 0000:7c00
- 然后把控制权转到加载程序

加载程序

- 将操作系统的代码和数据从硬盘加载到内存中
- 跳转到操作系统的起始地址并把控制权转给操作系统

为什么不直接在Bios工作时直接从磁盘中把操作系统的内核映像直接读到内存？

- 因为不同操作系统有不同的文件系统，在机器出厂时不可能直接限定Bios只能读取某种文件系统
- 而且Bios又不能加上认识所有文件系统的代码
- 因此Bios只负责读取加载程序，让加载程序去识别各个操作系统的文件系统

Bios系统调用在英特尔的CPU上还有个限制是：只能在x86的实模式下访问



## 计算机启动流程

BIOS（系统加电，Bios初始化） 	》》》》》》》》》》》》》》

主引导记录（Bios读取引导扇区代码） 	》》》》》》》》》》》》

活动分区（主引导扇区代码读取活动分区的引导扇区代码） 》》》》

加载程序（引导扇区代码读取文件系统的加载程序） 



### CPU初始化

#### CPU加点稳定后从0XFFFF0读取第一条指令

- CS:IP = 0xf000:fff0
- 第一条指令是跳转指令

#### CPU初始状态为16位实模式

- CS:IP是16位寄存器
- 指令指针PC = 16 * CS + IP
- 最大地址空间是1MB

### BIOS初始化过程

- 硬件自检POST
- 检测系统中内存和显卡等关键部件的存在和工作状态
- 查找并执行显卡等接口卡BIOS，进行设备初始化
- 执行系统BIOS，进行系统检测：检查和配置系统中安装的即插即用设备
- 更新CMOS中的扩展系统配置数据ESCD
- 按指定启动顺序从软盘、硬盘或光驱启动，读进第一块扇区，这个分区里存放主引导记录MBR格式

### 主引导记录MBR格式

大小为512字节，其中：

- 启动代码占了446字节：检查分区表正确性，加载并跳转到磁盘上的引导程序
- 硬盘分区表占了64字节：描述分区状态和位置，每个分区描述信息占16字节
- 结束标志占了剩下的2字节：结束标志字为55AA，主引导记录的有效标志，有了这个之后它才认为这是一个合法的主引导记录

#### 分区引导扇区格式

- 跳转指令：跳转到启动代码，这个代码与平台相关

- 文件卷头：文件系统描述信息

- 启动代码：跳转到加载程序

- 结束标志：55AA

### 加载程序（bootloader）

加载程序从文件系统中读取启动配置信息，然后选择启动参数（可选的操作系统内核列表和加载参数），依据配置加载指定（操作系统）内核并跳转到（操作系统）内核执行。



### 系统启动规范

- BISO
  - 固化到计算机主板上的程序
  - 包括系统设置、自检程序和系统自启动程序
  - BIOS-MBR、BIOS-GPT、PXE
- UEFI（同一可扩展固件接口）
  - 接口标准
  - 在所有平台上一致的操作系统启动服务

## 中断、异常和系统调用比较

- 系统调用（system call）：应用程序主动向操作系统发出的服务请求
- 异常（exception）：非法指令或者其他原因导致当前指令执行失败（如：内存出错）后的处理请求
- 中断（hardware interrupt）：来自硬件设备的处理请求



### 源头

- 中断的源头是：外设
- 异常的源头是：应用程序意想不到的行为
- 系统调用的源头是：应用程序请求操作系统提供服务

### 响应方式

- 中断：异步
- 异常：同步
- 系统调用：异步或同步

### 处理机制

- 中断：持续，对用户应用程序是透明的

- 异常：杀死或者重新执行意想不到的应用程序指令

- 系统调用：等待和持续



### 中断处理机制（这里包括中断、异常和系统调用）

#### 硬件处理

在CPU初始化时设置中断使能标志

- 依据内部或外部事件设置中断标志

#### 软件

- 现场保存（编译器）
- 中断服务处理（服务例程）
- 清除中断标记（服务例程）
- 现场恢复（编译器）



**1. 下列选项中，不可能在用户态发生的事件是( )。**

A．系统调用 
B．外部中断 
C．进程切换 
D．缺页  

本题目考查用户态发生的事件。系统调用可以是在用户程序执行时发出，请求操作系统的服务；外部中断也可以在用户程序执行时发生，例如请求外设；用户程序在执行时若所需页面不再内存，则发生缺页中断。因此，系统调用、外部中断、缺页都可能在用户态发生。而进程切换是在进程调度的过程中发生的，此时系统一定是处于核心态。因此应该选择C。



## 系统调用

- 系统调用是操作系统服务的编程接口
- 通常由高级语言编写
- 程序访问通常是通过高层次的API接口而不是直接进行系统调用
- 三种最常用的应用程序编程接口（API）
  - Win32 API 用于Windows
  - POSIX API 用于POSIX-based systems（包括UNIX、LINUX、Mac OS X的所有版本）
  - JavaAPI 用于JAVA虚拟机（JVM）

### 系统调用的实现

- 每个系统调用对应一个系统调用号：系统调用接口根据系统调用号来维护表的索引
- 系统调用接口调用内核态中的系统调用功能实现，并返回系统调用的状态和结果
- 用户不需要知道系统调用的实现
  - 需要设置调用参数和获取返回结果
  - 操作系统接口的细节大部分都隐藏在应用编程接口后，通过运行程序支持的库来管理。



### 系统调用与函数调用的不同

系统调用：

- INT和IERET指令用于系统调用：系统调用时，堆栈切换和特权级的转换

函数调用：

- CALL和RET指令用于常规函数调用：常规调用时没有堆栈切换



### 中断、异常恶化系统调用的开销

- 超过函数调用
- 开销：
  - 引导机制
  - 建立内核堆栈
  - 验证参数
  - 内核态映射到用户态的地址空间：更新页面映射权限
  - 内核态独立地址空间：TLB

> 系统调用相对常规函数调用执行开销要大，因为这会涉及到用户态栈和内核态栈的切换开销，特权级变化带来的开销，以及操作系统对用户态程序传来的参数安全性检查等开销。如果发出请求的请求方和应答请求的应答方都在内核态执行，则不用考虑安全问题了，效率还是需要的，直接用常规函数调用就够了。 以ucore OS为例，我们可以看到系统调用的开销在执行“int 0x80”和“iret”带来的用户态栈和内核态栈的切换开销，两种特权级切换带来的执行状态（关注 kern/trap/trap.h中的trapframe数据结构）的保存与恢复等（可参看 kern/trap/trapentry.S的__alltraps和__trapret的实现）。而函数调用使用的是"call"和“ret”指令，只有一个栈，不涉及特权级转变带来的各种开销。如要了解call, ret, int和iret指令的具体功能和实现，可查看“英特尔 64 和 iA-32 架构软件开发人员手册卷 2a's,指令集参考（A-M）”和“英特尔64 和 iA-32 架构软件开发人员手册卷 2B’ s,指令集参考（N-Z）”一书中对这些指令的叙述。