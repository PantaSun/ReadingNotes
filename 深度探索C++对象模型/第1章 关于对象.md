## 前言

### 对象模型

对象模型是深层结构的知识，关系到“与语言无关、与平台无关、跨网络可执行”软件组建的基础原理。

#### 什么是C++对象模型

1. 语言中直接支持面向对象程序设计的部分。
2. 对于各种支持的底层实现机制。



## C++对象模型

在C++中有两种class data members：static 和 nonstatic，以及三种class member functions：static、nonstatic和virtual。

### 关于对象

对于C语言来说，语言本身并没有支持“数据和函数”之间的关联性。这种程序方法称为程序性的：由一组分布在各个以功能为导向的函数中的算法所驱动，它们处理的是共同的外部数据。



#### 一个小Tips

若想要在一个类中创建一个数组对象，且又想不把数组的大小固定住，可以使用模板把数组大小参数化。直接使用int会出现一个问题，就是当用户不小心输入一个负数作为参数，这时数组的大小为负肯定是不对的，因此可以使用**静态成员常量**来对输入参数进行判断：

````c++
template <int dim>
class A{
public:
    void printSize(){
        std::cout <<  sizeof(a)/ sizeof(int) << std::endl;
    }
private:
    const static size_t dims = (dim > 0 ? dim : 0);
    int a[dims];

};
int main() {
    A<-10> a;
    a.printSize();
    return 0;
}
````

这样就即可以避免程序出错，又可以动态设定数组大小。



### C++对一个C语言的结构体加上封装后的布局成本

将一个C结构体转换为C++类后，并没有增加成本。

C++在布局以及存取时间上主要的额外负担是由virtual引起的，包括：

1. virtual function 机制：用以支持一个有效率的执行期绑定
2. virtual base class：用以实现多次出现在继承体系中的base class，有一个单一而被共享的实例。 

### 关于对象模型

#### 简单对象模型

一个对象中只有指向每一个数据成员或函数成员的slots（插槽，即指向成员指针），这个模型可以避免不同类型的成员需要不同大小的空间所带来的问题。该模型并未应用到C++编译器中

#### 表格驱动对象模型

一个对象存放指向数据成员表和函数成员表这两个表格指针。在数据表中直接存放数据成员本身，在函数表中存放的是一系列slots，每个slot指向一个成员函数。该模型也未实际应用于C++编译器中，但是函数成员表被应用于虚函数的处理方案中。

#### C++对象模型

- 对于data members
  - 非静态数据成员（Nonstatic data members）存放在每个class object中，
  - 静态数据成员（Static data members）存放在class object之外。
- 对于function members
  - 静态和非静态函数成员（Static 、Nonstatic function members）都存放在class object之外
  - virtual functuons ：
    - 每一个类产生一堆指向virtual functions的指针，这些指针放在virtual table（称为vtbl）中
    - 每个class object都有一个指向该class virtual table的指针（称为vptr）。vptr的设定和重置都由每一个class的constructor、destructor和copy assignment运算符自动完成。
    - 每个class所关联的type_info_object也由vtbl被指出来，通常放在表格的第一项。
- 优点：空间和存取时间的效率高
- 缺点：当存在于object中的nonstatic data members有所改变时，就需要重新编译，而在上述的表格模型中就没有这种麻烦。



#### 加上继承

在继承时可以加上virtual关键字表示共享的意思，在虚拟继承的情况下，base class不管在继承串中被派生多少次，永远只会有一个实例（成为subobject）。

在C++初期，base data members 直接放在derived class object中。这样做的优点是存取效率高，缺点是当base class members的任何改变都会使用到此base class 或其derived class都要重新编译。

在C++2.0时新加入了virtual base class，需要一些间接的base class表现方法。virtual base class的原始模型是在class object中为每一个有关联的virtual base class加上一个指针。其他演化出来的版本不是导入一个virtual base class table，就是扩充已经存在的vtbl，以便于维护每一个virtual base class的位置。



#### P21

组合（composition），而非继承，才是把C++和C组合在一起的唯一可行方法。

要想实现多态，其充分非必要条件就是使用指针或引用。非必要的原因是使用了指针未必是多态，例如普通的基本数据类型的指针`int *pi; void *pvi;`等就不是多态。多态还有一个必要条件就是指针或引用应该是一个指向base class类型的指针或引用。