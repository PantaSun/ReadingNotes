## Default Constrcutor 的构造操作

### 默认构造函数（Default Constrcutor）

#### 什么是默认构造函数？

　　**默认构造函数是可以不用实参进行调用的构造函数，它包括了以下两种情况：**

1. **没有带明显形参的构造函数。**
2. **提供了默认实参的构造函数。** 

#### 在ARM（C++ Annotated Reference Manual，c++注释参考手册）中

ARM中有说明：“默认构造函数……在需要的时候被编译器产生出来”，这句话的重点是“在需要的时候”。那么问题来了，被谁需要？需要做什么？

##### 被编译器需要

被编译器需要时，才会和成一个默认构造函数，而不是被程序需要。程序如果有需要，那是程序员的责任。

被合成出来的默认构造函数只执行编译器所需要的行动。

#### 在C++ Standard中

对于class X，如果没有任何用户声明的构造函数，则编译器会声明一个隐式构造函数，这个隐式构造函数将是一个trivial（没啥用）的构造函数；而一个nontrivial default constructor就是ARM中编译器所需的那种。

### 四种nontrivial default constructor

#### 带有Default Constructor的Member Class Object

```c++
class Foo
{
 public:
    Foo();
    Foo(int);
};
class Bar
{
  public:
    Foo foo;
    char * str;
};

void foo_bar()
{
    Bar bar;
    ...
  
}

```

上述代码中，编译器为class Bar合成一个默认构造函数，这个合成默认构造函数能够调用class Foo的默认构造函数来处理member object Bar::foo，但它并不产生任何代码来初始化Bar::str，str的初始化是由程序员做的。

若程序员为了初始化str而创建了一个默认构造函数：` Bar::Bar(){str = 0;}`，这时候由于默认构造函数已经被定义出来了，因此编译器就没法再合成一个。这时候编译器会扩充现有的默认构造函数，可能像这样：`Bar::Bar(){foo.Foo::Foo(); str = 0;}`。

#### 带有Default Constructor的Base class

如果一个没有任何构造函数的类派生自一个带有默认构造函数的基类，那么这个派生类的合成默认构造函数会被视为nontrivial的。

如果设计者提供了多个构造函数但没有默认构造函数，那么编译器会用调用基类构造函数的代码扩张每一个现有的构造函数；而不是合成一个新的。因为当有其他有用户提供的构造函数时就不会合成默认构造函数。

如果这个派生类还有“带着默认构造函数的member class objects”时，还会把“调用这些objects的默认构造函数的代码”扩充到现有的构造函数中，且放在“调用基类的构造函数的代码”之后。

#### 带有一个Virtual Function的class

1. class 声明或继承一个virtual function
2. class派生自一个继承串链，其中有一个或更多的virtual base classes

当class没有显示声明构造函数时，编译器会合成一个默认的构造函数用以初始化vtbl和vtpr。若class已经有构造函数，那么编译器就会向现有构造函数中插入一些做上述事情的代码。

#### 带有一个virtual base class的class

因为指向virtual base class的指针需要在构造期间建立，所以需要合成默认构造函数来做这件事，当已经有构造函数，那么就扩充这些构造函数。



### 总结

有四种情况会造成编译必须为“未声明构造函数的类”合成一个默认构造函数。C++ standard中把这些生成的合成构造函数成为implicit nontrivial default constructor。

这些合成构造函数会满足编译器的需求，这些类能完成任务就是借着“调用member object或base class 的默认构造函数”或是为每一个object初始化其虚函数机制或virtual base class机制，就这四种。至于没有这四种情况的也没有声明任何构造函数的类，他们拥有的是implicit trivial default constructor，它们实际上并不会被合成出来。

在合成的default constructor中，只有base class subobject和member class object会被初始化，其他非静态数据成员如整数、整数指针、整数数组等都不会被初始化。

#### 两个误解

1. 任何class如果没有定义default constructor，编译器就会合成一个出来（只有被编译器需要时才会合成）。
2. 编译器合成出来的default constructor 会显示设定“class 内每一个data member 的默认值”。


对于这两个误解我确实存在，这源自当是看的《C++ Primer》这本书（中文第五版）的236页一个Note：“只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数”，这么一对比这不是冲突了么？这两本书的作者都是C++大佬，应该不会出错吧？于是我就搜了一下，得到一个比较好的解释：

原文链接：https://www.cnblogs.com/QG-whz/p/4676481.html 

侵删

原文部分节选：

> **对于C++默认构造函数，我曾经有两点误解：**
>
> - **类如果没有定义任何的构造函数，那么编译器（一定会!）将为类定义一个合成的默认构造函数。**
> - **合成默认构造函数会初始化类中所有的数据成员。**
>
> 　　**第一个误解来自于我学习C++的第一本书 《C++ Primer》，在书中392页：** **“只有当一个类没有定义构造函数时，编译器才会自动生成一个默认构造函数”。**
>
> **实际上这句话也没有说错，它说明了默认构造函数定义的必要非充分条件，然而却给当时初学C++的我造成了一定的误解。**
>
> 　　**第二个误解依旧来自于Primer中的一句话： ** **“合成的默认构造函数使用与变量初始化相同的规则来初始化成员。具有类类型的成员通过运行各自的默认构造函数来进行初始化”。** **然而这也是我理解的片面，因为Primer也说到了：“如果类包含内置或复合类型的成员，则该类不应该依赖于合成的默认构造函数”，言下之意就是合成的默认构造函数并不会初始化内置或复合类型的成员。**
>
> 　　**总结了我有这些误解的原因，第一是初学时知识体系没形成，对Primer中所说的内容没有真正的理解，第二就是Primer在某种程度上的确不是C++初学者能看懂的书，或许看时觉得懂了，却是遗漏了很多知识。也说明了Primer 是座宝库，常常回顾将会有新的感悟。**
>
> 　　**让我对上面两个观点产生疑惑，是在看《Effective C++》时，条款05《了解C++默认编写并调用哪些函数》中说到“….惟有当这些函数被需要（被调用），它们才会被编译器创建出来。” （“这些函数“指的是编译器版本的复制构造函数、赋值操作符和析构函数，还包括了默认构造函数。）也就是说，默认构造函数“被需要”的时候编译器才会帮我们合成，那什么情况才是默认构造函数”被需要“呢？这个问题《Effective C++》并没有给出答案，直到看了《深度探索C++对象模型》，才明白了编译器何时才会帮我们合成一个默认构造函数。**
>
> 　　**我写这篇文章的目的是给和我有同样误解或疑惑的C++初学者看的，如果你对合成默认构造函数已有充分的认识，请忽略本文的内容。**
>
> #### 理解“被需要”这三个字
>
> 　　**前面提到在《Effective C++》中指出惟有默认构造函数”被需要“的时候编译器才会合成默认构造函数。关键字眼是”被需要“。被谁需要?做什么事情？像下面这段代码，默认构造函数”被需要“了吗？**
>
>  
>
> ```c++
> class A
> {
> public:
>     bool isTrue;
>     int num;
>
> };
> int main()
> {
>     A a;
>     if (a.isTrue)
>         cout << a.num;
>     return 0;
> }
> ```
>
> 　　**你可能认为这里定义类对象a的时候没有提供参数且A没有定义默认构造函数，编译器肯定是合成了一个默认构造函数并调用它来初始化A的数据成员，实则不是。当你试图查看合成默认构造函数把数据成员num初始化为什么值的时候，你会发现编译器甚至都让你运行不了程序：**
>
> ![img](https://images0.cnblogs.com/blog2015/610439/201507/251943334219256.png)
>
>  
>
> 　　**当类只含有内置类型或复合类型的成员时，编译器是不会为类合成默认构造函数的，这种类并不符合”被需要“的条件，甚至当类满足“被需要”条件，编译器合成了默认构造函数时，类中内置类型与复合类型数据成员依然不会在默认构造函数中进行初始化。Primer中也有提到：“如果类包含内置或复合类型的成员，则该类不应该依赖于合成的默认构造函数“。**
>
> 　 **上面代码中，默认构造函数”被需要“是对程序来说的，程序需要isTrue被初始化以便可以进行条件判断，需要num被初始化以便可以输出。然而这种需要并不会促使编译器合成默认构造函数。惟有被编译器所需要时，编译器才会合成默认构造函数。那怎样的类才是编译器需要合成默认构造函数的呢？**
>
> **总结：**
>
> 1. **合成默认构造函数总是不会初始化类的内置类型及复合类型的数据成员。**
> 2.   **分清楚默认构造函数被程序需要与被编译器需要，只有被编译器需要的默认构造函数，编译器才会合成它。**



这位大佬的困惑和我一样，经过他的解释，确实是把“只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数”这句话理解错了，我理解成“**只要没有**”编译器“**就会生成**”，而原文的意思是“**只有在没有的情况下**”，编译器“**才可以生成**”，即编译器在这时候可以生成了，但具体生不生成要看情况的（是否被需要）。反过来说当类声明任意构造函数时，编译器就一定不会生成合成默认构造函数（顶多是扩充那些现有的构造函数）。正如引文中说的“必要非充分”。

至于大佬对于“被需要”解释中的代码，我先是在Clion（基于MinGW3.20）中进行测试，居然编译通过且运行成功了，但是打印出的结果是一个随机数，那么这里其实可以认为并没有生成合成默认构造函数且没有为isTrue和num进行初始化（例如把整数初始化为0之类的），这两个数只是内存中原有的随机数。在Visual Stdio 2017中测试，得到的结果和引文中一致。这也就是很好的证明了第二个误解确实是个误解。



## Copy Constructor的构造操作

#### 拷贝构造函数

当以一个object的内容作为同一个class的另一个object的初值时使用的构造函数就是拷贝构造函数。

显示定义的构造函数可以是：

首先是一个构造函数，其次是该构造还是的一个参数的类型是class type的。

用户定义得拷贝构造函数也可以是多参数，但class type的参数要放在第一个，其第二参数及后继参数都以一个默认值。

若一个class没有定义拷贝构造函数，类内部会使用default memberwise initialization 手法完成拷贝构造函数该做的事：把每个内建的或派生的data member的值，从实参class object 拷贝到另一个object中。

### default memberwise initialization

default memberwise initialization 的意思是按成员初始化，但是它不会拷贝member class object，而是以递归的方式对member class object使用 memberwise initialization。

**在ARM中：**default memberwise initialization 这个操作在概念上被称为（合成）拷贝构造函数，但是和合成默认构造函数一样只有在**被需要**的时候才会被编译器产生出来，而不是在“一个class没有定义拷贝构造函数时”才被编译器产出。

#### 被需要的情况

这里的被需要的情况和合成默认构造函数的那四种情况不一样，而是当class不展现bitwise copy semantic 时才会被需要。（**后来发现“不展现”只是表象，深层原因还是有四种情况，具体的和默认构造那四种还是有些区别的**）

同合成默认构造函数一样，C++ standard中也说明了当class 没有声明copy constructor时，就会隐式声明一个，但这个隐式声明的还分trivial和nontrivial两种。这里与上述ARM所说的并不矛盾，因为只有nontrivial的才会被合成与程序之中。也就是说trivial的隐式声明只是一种说法，并没有实际合成，这就符合了上述在ARM中的说法。

而判断是否是nontrival（即可以理解为被需要）的依据就是看一个class是否展现出 bitwise copy semantic。

### bitwise copy semantic（位逐次拷贝）

当我们的类中只含有内置类型或复合类型时，类展现了Bitwise copy 语意。这种情况下并不需要合成一个默认拷贝构造函数。

### 不展现bitwise copy semantic的情况

1. 当一个类内含一个member object 而后者的class声明有一个拷贝构造函数（不管是class设计者设计的还是编译器合成的）
2. 当class继承自一个base class而后者存在一个拷贝构造函数时（不论显示构造还是被合成的）
3. 当class声明了一个或多个virtual functions时
4. 当class派生自一个继承串链，其中有一个或多个virtual base class时

#### 前两种情况

编译器必须将“**类成员或基类的复制构造函数调用操作**”安插到新合成的拷贝构造函数中去，如果类设计者已经明确声明了一个拷贝构造函数，则这些调用操作代码将插入到已有的拷贝构造函数中去（在函数体的最前端插入）。

#### 后两种情况

后两种操作涉及到了虚表指针与虚基类指针的产生于初值设置。我们知道，当一个类含有虚函数时（无论这虚函数是类本身定义还是继承而来），在编译期间会有以下两个程序扩张操作:

- 为类增加一个虚表（virtual function table），虚表内含有每一个有作用的虚函数的地址。
- 为每一个类对象增加一个虚表指针（vptr)，虚表指针指向了该类的虚表。

##### 虚指针

显然，如果编译器对每个新定义的类对象不能正确地设置好初值，将导致严重的后果。所以编译器需要合成出一个复制构造函数来适当地初始化类对象的vptr。万一类设计者明确定义了自己的复制构造函数，则编译器会把设置vptr的操作插入到已有的拷贝构造函数中。而vptr的拷贝又有两种情况：

- 同类型对象间的vptr拷贝：同类型的对象各自的vptr总是指向了同一个位置：该类的虚表指针。这时两个对象的vptr的拷贝都可以直接靠”bitwise copy“来完成（除了可能会有的其他指针成员）。所以同类型对象间的vptr拷贝总是安全的。
- 把子类对象vptr拷贝给父类对象：不用担心把子类对象拷贝给父类对象时，vptr也会采用bitwise copy来拷贝，这点编译器给我们做了保证：编译器合成的默认构造函数（或者说在明确声明的拷贝构造函数中安插的代码）会明确设定父类的vptr指向父类的虚函数表，而不是采用傻瓜式直接拷贝子类对象vptr。

##### 虚继承

基类的存在需要特殊处理，一个类对象如果以另一个对象作为初值，而后者派生于虚基类，那么这种情况下bitwise copy语意也会失效，编译器会对派生自虚基类的类合成一个默认构造函数，在其中安插一些操作。对于虚继承，编译器有承偌：派生类对象中的虚基类位置在执行期就要准备妥当，维护“位置的完整性”是编译器的责任，而显然的，Bitwise copy 语意会破坏这个位置（这种傻瓜式的拷贝好像只适用内置类型的拷贝以及同类型对象间vptr的拷贝），所以编译器必须在它自己合成出来的拷贝构造函数中做出仲裁。同样的，如果类设计者明确声明了拷贝构造函数，则这些仲裁代码将安插在这个拷贝构造函数中。



## 程序转化语意学

就是讲初始化的

### 显示的初始化操作



1. 重写每一个定义，剥除其中的初始化部分
2. 类的拷贝构造函数会被安插进去

就是在用一个（旧）object来初始化定义另一个（新）0object时，将一句代码改写成两句：先声明要生成的object，然后用这个object调用其拷贝构造函数并以旧object作为参数。

### 参数初始化

把一个class object当做参数传递给一个函数。

在编译器实现时有一种策略是导入临时object，并调用拷贝构造函数将它初始化。然后将以值传递的函数参数形式改写为以引用传递的形式。最后在函数运行结束后，临时object会调用析构函数将这个临时object销毁。

```c++
//某个类
class X{};
// 函数
void foo(X x0);
// 调用函数
X xx;
foo(xx);

// 根据上述实现方式
// 伪码
// 创建临时object
X __temp0;
__temp0.X::X(xx);
// 调用
foo(__temp0); //这里的函数已经从 void foo(X x0);转变为void foo(X &x0);
// foo执行完毕，调用析构函数
__temp0.X::~X();
```

当然，这只是编译器实现策略中的一种，还有其他的策略。比如以“拷贝构建”的方式将实际参数直接建构在其应该在的位置上，此位置视函数活动范围的不同，记录于程序堆栈中。在函数返回之前，局部对象的析构函数会被执行。

### 返回值的初始化

函数的返回值是一个class类型的值。

在cfront中有一种双阶段转化：

1. 为函数新增一个返回值类型的class object reference参数
2. 在 return 之前调用新增参数的copy constructor，以便将欲返回的object的内容当做新增参数的初值。

```c++
// 函数返回X类型的值
X bar()
{
    X xx;
    ...
    return xx;
}
// 转化伪码
void bar(X &__result)  // 新增引用参数
{
    X xx;
    ...
    __result.X::X(xx); // 调用新参数的构造函数
    return;
}
```

在此设计策略下，编译器应对每个bar()调用操作进行转换：

```c++
// 情况1
X xx = bar();
// 转化为
X xx;
bar(xx);

// 情况2
bar().memfunc();
// 转化为
X __temp0;
(bar(__temp0), __temp0).memfunc(); //这句话的意思相当于bar(__temp0); __remp0.memfunc();

// 情况3
X(*pf)();
pf = bar();
// 转化为
void (*pf)(X&);
pf = bar;
```

### 优化

#### 在使用者层面做优化

有时候返回值可以不调用拷贝构造函数，而是直接调用构造函数，即上述的__result是被直接计算出来的，而不是经由cpoy constructor拷贝而得。

#### 在编译器曾名做优化

在像bar这样的函数中，将所有的return指令返回的具名参数用__result参数进行取代。这种方法叫Named return value ，即NRV优化。

#### 一个问题

在书中67页说到：“这个程序不能实施NRV优化，因为test class缺少一个 copy constructor。”我就奇怪了，NRV不是直接使用`__result`从而取代xx么，也就是不会先创建xx，再以xx作为参数调用`__resulr.X::X(xx);`了啊，那么是否能进行NRV优化与copy constructor有什么关系？于是还是各种搜索，找到一些靠谱的回答：

原文地址：https://www.cnblogs.com/cyttina/archive/2012/11/26/2790076.html#commentform

侵删

部分节选：

> 下面是jjhou的FAQ： 
> C++ Object Model 答客问 (3) - NRV 最佳化 
> 2000.03.25 
>
> leetron wrote (2000/02/11) : 
>
> > 您好，关於深度探索C++物件模型一书，2.3节程式 
> > 转化语意学的部分，有个问题 
> > 想请教您。 
> >
> > 问题： 
> > 在67页，最下面两行： 
> > 这个程式的第一个版本不能实施NRV最佳化，因为test class 
> > 缺少一个copy constructor。 
> > 但是在66页「在编译器层面做最佳化」那一段中所列的码显示， 
> > 当编译器把xx以__result取代，变成__result.X::X(); 
> > 即default constructor被唤起。唤起default constructor 
> > 是可以理解的，可是编译器转换后的码并没有使用到 
> > copy constructor呀，为什麽67页最后两行却说缺少一个 
> > copy constructor，就不能实施这个最佳化了呢？ 
> >
> > 我对上面这个问题做了些解释，但不知我的猜想是否正确。 
> >
> > 我的解释是： 
> > 如同63页与64页「回返值的初始化」这一段，编译器可能将 
> > 63页下面的 X bar()函式定义转换成64页的虚拟码，其中有 
> > 一行__result.X::X(xx); 这会使用到copy constructor。 
> >
> > 转换成64页的码后，65页与66页分述了两种后续可能出现的 
> > 最佳化动作，其中一种即是66页的编译器层面做最佳化。 
> > 如此，虽然66页最佳化后的码看起来并不使用到copy constructor， 
> > 但是这些码是根据像64页那种样子的码(注一)最佳化而来的， 
> > 而若没有copy constructor，根本无法转换成64页那种虚拟码， 
> > 因为其中有一个呼叫copy constructor的动作。所以，虽然 
> > 66页经过编译器最佳化的结果省去了__result.X::X(xx); 
> > 这个copy constructor的呼唤动作（因为根本没有xx了）， 
> > 但若没有明白提供一个copy constructor，却无法让编译器 
> > 进行这样的最佳化。 
> >
> > 另一方面，我叁考第5章，205页最下面一段话： 
> > 「一般而言如果你的设计之中，有许多函式都需要以传值(by value) 
> > 传回一个local class object....那麽提供一个copy constructor 
> > 就比较合理--甚至即使default memberwise语意已经足够。 
> > 它的出现会触发NRV最佳化。然而，就像我在前一个例子中 
> > 所展现的那样，NRV最佳化后将不再需要唤起copy constructor， 
> > 因为运算结果已经被直接计算於「将被传回的object」体内了。」 
> > 所以，我提出如上所述那个解释，但不确定是否正确，所 
> > 以e-mail给您以确认一下。 
> >
> > 注一：当然，编译器到底怎麽实作这些转换动作，理论上 
> > 我们是未知的，不能一概而论。所以我写「像64页那种样子的码」。 
>
>
> 侯捷回覆： 
>
> 我最害怕的事情就是，读者写信来讨论《深度探索 C++ 物件模型》 
> 一书内容。因为都是些高手提出些深奥的题目，而我必须把尘封的 
> 记忆找出来┅ :) 
>
> OK，作者（或译者）没有抱怨的权利 :)。我的回覆如下。 
>
> 首先，我要说 leetron 把他的意思描述得非常清楚。在我收到 
> 的读者来函中，算是上品 — 尤其是描述这麽复杂的思路。 
>
> 其次，我同意 leetron 说： 
>
> > 转换成64页的码后，65页与66页分述了两种后续可能出现的 
> > 最佳化动作，其中一种即是66页的编译器层面做最佳化。 
>
> 但是我不同意 leetron 这样的看法： 
>
> > 如此，虽然66页最佳化后的码看起来并不使用到copy constructor， 
> > 但是这些码是根据像64页那种样子的码(注一)最佳化而来的， 
>
> 我认为，NRV 最佳化并非是由 p63 的原始码而至 p64 的虚拟码， 
> 再至 p66 的最佳化。我认为是从 p63 的原始码直接至 p66 的最佳化。 
> 所以，似乎可以不需要 copy ctor。 
>
> 但这麽一来我也无法解释为什麽 lippman 在 p67 最下强调 
> 「必须要有 copy ctor 才能实施 NRV 最佳化」。 
>
> 以下是其他读者的讨论，给您叁考。 
>
> -- quote -- （引自 www.jjhou.com ：书籍勘误/深度探索 C++ 物件模型） 
>
> ★黄俊达先生认为：Lippman 在 p67 最后一行所言『这个程式的第一个版本 
> 不能实施 NRV 最佳化，因为 test class 缺少一个 copy constructor』， 
> 此语错误。黄先生认为如果程式没有 explicit copy constructor，编译器会 
> 自动为我们做出来（如为 trivial，则直接 bitwise copy；如为 nontrivial， 
> 则由编译器为我们合成出一个 copy constructor）。因此，有没有 explicit 
> copy constructor 并不影响 NRV 最佳化的实施。他认为 NRV 最佳化主要是 
> 由编译器 option 来决定要不要实施。他并且做了一些实验，判断 VC 和 gcc 
> 都没有做到 NRV 最佳化，而其不做的理由不是因为技术上的困难，是为了 
> 避免造成「user defined copy constructor 之副作用失效」-- 所谓副作用 
> 是指，例如「在 user defined copy constructor 中做一个 cout 输出」之类 
> 这种「与 memberwise copy 无关」的动作。 
>
> ★侯俊杰答覆：颇有道理。但请注意，Lippman 
> 在 p.205 下方, p.221 上方等处，仍再三强调 copy constructor 
> 对於 NRV 最佳化的导引之功，不知是否其间有什麽是我们没想到的？
>
> 有查了一下，李普曼原来是给出了答案的了。
>
> 见如下地址： <http://book.douban.com/annotation/19292671/>
>
> 转过来了：
>
>
> 书中说，NRV优化和拷贝构造函数是有关系的，只有定义了拷贝构造函数才会开启NRV优化，但现代编译器NRV优化的开启一般都与拷贝构造函数没有关系，
> 下面一段话摘自网络，参考关于cfront的NRV优化，解释了为什么lippman在书中说有关的原因：
> “早期的 cfront需要一个开关来决定是否应该对代码实行NRV优化，这就是是否有客户（程序员）显式提供的拷贝构造函数：
> 如果客户没有显示提供拷贝构造函数，那么cfront认为客户对默认的逐位拷贝语义很满意，由于逐位拷贝本身就是很高效的，
> 没必要再对其实施NRV优化；但 如果客户显式提供了拷贝构造函数，这说明客户由于某些原因(例如需要深拷贝等)摆脱了高效的逐位拷贝语义，
> 其拷贝动作开销将增大，所以将应对其实施NRV 优化，其结果就是去掉并不必要的拷贝函数调用。
> ”需要说明的一点：NRV优化会导致原本预想中的调用“拷贝构造函数”变成调用别的“构造函数”，
> 一旦这个时候，拷贝构造函数和别的构造函数提供的功能不同，就可能会出问题。
>
> 另一个解释如下：
> 如果程式没有 explicit copy constructor，编译器会自动为我们做出来（如为 trivial，则直接 bitwise copy；
> 如为 nontrivial，则由编译器为我们合成出一个 copy constructor）。
> 因此，有没有 explicitcopy constructor 并不影响 NRV 最佳化的实施。NRV 最佳化主要是由编译器 option 来决定要不要实施。
>
> 

