## Default Constrcutor 的构造操作

### 默认构造函数（Default Constrcutor）

#### 什么是默认构造函数？

　　**默认构造函数是可以不用实参进行调用的构造函数，它包括了以下两种情况：**

1. **没有带明显形参的构造函数。**
2. **提供了默认实参的构造函数。** 

#### 在ARM（C++ Annotated Reference Manual）中

ARM中有说明：“默认构造函数……在需要的时候被编译器产生出来”，这句话的重点是“在需要的时候”。那么问题来了，被谁需要？需要做什么？

##### 被编译器需要

被编译器需要时，才会和成一个默认构造函数，而不是被程序需要。程序如果有需要，那是程序员的责任。

被合成出来的默认构造函数只执行编译器所需要的行动。

#### 在C++ Standard中

对于class X，如果没有任何用户声明的构造函数，则编译器会声明一个隐式构造函数，这个隐式构造函数将是一个trivial（没啥用）的构造函数；而一个nontrivial default constructor就是ARM中编译器所需的那种。

### 四种nontrivial default constructor

#### 带有Default Constructor的Member Class Object

```c++
class Foo
{
 public:
    Foo();
    Foo(int);
};
class Bar
{
  public:
    Foo foo;
    char * str;
};

void foo_bar()
{
    Bar bar;
    ...
  
}

```

上述代码中，编译器为class Bar合成一个默认构造函数，这个合成默认构造函数能够调用class Foo的默认构造函数来处理member object Bar::foo，但它并不产生任何代码来初始化Bar::str，str的初始化是由程序员做的。

若程序员为了初始化str而创建了一个默认构造函数：` Bar::Bar(){str = 0;}`，这时候由于默认构造函数已经被定义出来了，因此编译器就没法再合成一个。这时候编译器会扩充现有的默认构造函数，可能像这样：`Bar::Bar(){foo.Foo::Foo(); str = 0;}`。

#### 带有Default Constructor的Base class

如果一个没有任何构造函数的类派生自一个带有默认构造函数的基类，那么这个派生类的合成默认构造函数会被视为nontrivial的。

如果设计者提供了多个构造函数但没有默认构造函数，那么编译器会用调用基类构造函数的代码扩张每一个现有的构造函数；而不是合成一个新的。因为当有其他有用户提供的构造函数时就不会合成默认构造函数。

如果这个派生类还有“带着默认构造函数的member class objects”时，还会把“调用这些objects的默认构造函数的代码”扩充到现有的构造函数中，且放在“调用基类的构造函数的代码”之后。

#### 带有一个Virtual Function的class

1. class 声明或继承一个virtual function
2. class派生自一个继承串链，其中有一个或更多的virtual base classes

当class没有显示声明构造函数时，编译器会合成一个默认的构造函数用以初始化vtbl和vtpr。若class已经有构造函数，那么编译器就会向现有构造函数中插入一些做上述事情的代码。

#### 带有一个virtual base class的class

因为指向virtual base class的指针需要在构造期间建立，所以需要合成默认构造函数来做这件事，当已经有构造函数，那么就扩充这些构造函数。



### 总结

有四种情况会造成编译必须为“未声明构造函数的类”合成一个默认构造函数。C++ standard中把这些生成的合成构造函数成为implicit nontrivial default constructor。

这些合成构造函数会满足编译器的需求，这些类能完成任务就是借着“调用member object或base class 的默认构造函数”或是为每一个object初始化其虚函数机制或virtual base class机制，就这四种。至于没有这四种情况的也没有声明任何构造函数的类，他们拥有的是implicit trivial default constructor，它们实际上并不会被合成出来。

在合成的default constructor中，只有base class subobject和member class object会被初始化，其他非静态数据成员如整数、整数指针、整数数组等都不会被初始化。

#### 两个误解

1. 任何class如果没有定义default constructor，编译器就会合成一个出来（只有被编译器需要时才会合成）。
2. 编译器合成出来的default constructor 会显示设定“class 内每一个data member 的默认值”。


对于这两个误解我确实存在，这源自当是看的《C++ Primer》这本书（中文第五版）的236页一个Note：“只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数”，这么一对比这不是冲突了么？这两本书的作者都是C++大佬，应该不会出错吧？于是我就搜了一下，得到一个比较好的解释：

原文链接：https://www.cnblogs.com/QG-whz/p/4676481.html 

侵删

原文部分节选：

> **对于C++默认构造函数，我曾经有两点误解：**
>
> - **类如果没有定义任何的构造函数，那么编译器（一定会!）将为类定义一个合成的默认构造函数。**
> - **合成默认构造函数会初始化类中所有的数据成员。**
>
> 　　**第一个误解来自于我学习C++的第一本书 《C++ Primer》，在书中392页：** **“只有当一个类没有定义构造函数时，编译器才会自动生成一个默认构造函数”。**
>
> **实际上这句话也没有说错，它说明了默认构造函数定义的必要非充分条件，然而却给当时初学C++的我造成了一定的误解。**
>
> 　　**第二个误解依旧来自于Primer中的一句话： ** **“合成的默认构造函数使用与变量初始化相同的规则来初始化成员。具有类类型的成员通过运行各自的默认构造函数来进行初始化”。** **然而这也是我理解的片面，因为Primer也说到了：“如果类包含内置或复合类型的成员，则该类不应该依赖于合成的默认构造函数”，言下之意就是合成的默认构造函数并不会初始化内置或复合类型的成员。**
>
> 　　**总结了我有这些误解的原因，第一是初学时知识体系没形成，对Primer中所说的内容没有真正的理解，第二就是Primer在某种程度上的确不是C++初学者能看懂的书，或许看时觉得懂了，却是遗漏了很多知识。也说明了Primer 是座宝库，常常回顾将会有新的感悟。**
>
> 　　**让我对上面两个观点产生疑惑，是在看《Effective C++》时，条款05《了解C++默认编写并调用哪些函数》中说到“….惟有当这些函数被需要（被调用），它们才会被编译器创建出来。” （“这些函数“指的是编译器版本的复制构造函数、赋值操作符和析构函数，还包括了默认构造函数。）也就是说，默认构造函数“被需要”的时候编译器才会帮我们合成，那什么情况才是默认构造函数”被需要“呢？这个问题《Effective C++》并没有给出答案，直到看了《深度探索C++对象模型》，才明白了编译器何时才会帮我们合成一个默认构造函数。**
>
> 　　**我写这篇文章的目的是给和我有同样误解或疑惑的C++初学者看的，如果你对合成默认构造函数已有充分的认识，请忽略本文的内容。**
>
> #### 理解“被需要”这三个字
>
> 　　**前面提到在《Effective C++》中指出惟有默认构造函数”被需要“的时候编译器才会合成默认构造函数。关键字眼是”被需要“。被谁需要?做什么事情？像下面这段代码，默认构造函数”被需要“了吗？**
>
>  
>
> ```c++
> class A
> {
> public:
>     bool isTrue;
>     int num;
>
> };
> int main()
> {
>     A a;
>     if (a.isTrue)
>         cout << a.num;
>     return 0;
> }
> ```
>
> 　　**你可能认为这里定义类对象a的时候没有提供参数且A没有定义默认构造函数，编译器肯定是合成了一个默认构造函数并调用它来初始化A的数据成员，实则不是。当你试图查看合成默认构造函数把数据成员num初始化为什么值的时候，你会发现编译器甚至都让你运行不了程序：**
>
> ![img](https://images0.cnblogs.com/blog2015/610439/201507/251943334219256.png)
>
>  
>
> 　　**当类只含有内置类型或复合类型的成员时，编译器是不会为类合成默认构造函数的，这种类并不符合”被需要“的条件，甚至当类满足“被需要”条件，编译器合成了默认构造函数时，类中内置类型与复合类型数据成员依然不会在默认构造函数中进行初始化。Primer中也有提到：“如果类包含内置或复合类型的成员，则该类不应该依赖于合成的默认构造函数“。**
>
> 　 **上面代码中，默认构造函数”被需要“是对程序来说的，程序需要isTrue被初始化以便可以进行条件判断，需要num被初始化以便可以输出。然而这种需要并不会促使编译器合成默认构造函数。惟有被编译器所需要时，编译器才会合成默认构造函数。那怎样的类才是编译器需要合成默认构造函数的呢？**
>
> **总结：**
>
> 1. **合成默认构造函数总是不会初始化类的内置类型及复合类型的数据成员。**
> 2.   **分清楚默认构造函数被程序需要与被编译器需要，只有被编译器需要的默认构造函数，编译器才会合成它。**



这位大佬的困惑和我一样，经过他的解释，确实是把“只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数”这句话理解错了，我理解成“**只要没有**”编译器“**就会生成**”，而原文的意思是“**只有在没有的情况下**”，编译器“**才可以生成**”，即编译器在这时候可以生成了，但具体生不生成要看情况的（是否被需要）。换句话说当类声明任意构造函数时，编译器就一定不会生成合成默认构造函数。正如引文中说的“必要非充分”。

至于大佬对于“被需要”解释中的代码，我先是在Clion（基于MinGW3.20）中进行测试，居然编译通过且运行成功了，但是打印出的结果是一个随机数，那么这里其实可以认为并没有生成合成默认构造函数且为isTrue和num进行初始化，这两个数只是内存中原有的随机数。在Visual Stdio 2017中测试，得到的结果和引文中一致。这也就是很好的证明了第二个误解确实是个误解。



## Copy Constructor的构造操作

#### 拷贝构造函数

当以一个object的内容作为同一个class的另一个object的初值时使用的构造函数就是拷贝构造函数。

显示定义的构造函数可以是：

首先是一个构造函数，其次是该构造还是的一个参数的类型是class type的。

用户定义得拷贝构造函数也可以是多参数，但class type的参数要放在第一个，其第二参数及后继参数都以一个默认值。

若一个class没有定义拷贝构造函数，类内部会使用default memberwise initialization 手法完成拷贝构造函数该做的事：把每个内建的或派生的data member的值，从实参class object 拷贝到另一个object中。

### default memberwise initialization

default memberwise initialization 的意思是按成员初始化，但是它不会拷贝member class object，而是以递归的方式对member class object使用 memberwise initialization。

**在ARM中：**default memberwise initialization 这个操作在概念上被称为（合成）拷贝构造函数，但是和合成默认构造函数一样只有在**被需要**的时候才会被编译器产生出来，而不是在“一个class没有定义拷贝构造函数时”才被编译器产出。

#### 被需要的情况

这里的被需要的情况和合成默认构造函数的那四种情况不一样，而是当class不展现bitwise copy semantic 时才会被需要。（**后来发现“不展现”只是表象，深层原因还是有四种情况（具体的和默认构造那四种还是有些区别的）**）

同合成默认构造函数一样，C++ standard中也说明了当class 没有声明copy constructor时，就会隐式声明一个，但这个隐式声明的还分trivial和nontrivial两种。这里与上述ARM所说的并不矛盾，因为只有nontrivial的才会被合成与程序之中。也就是说trivial的隐式声明只是一种说法，并没有实际合成，这就符合了上述在ARM中的说法。

而判断是否是nontrival（即可以理解为被需要）的依据就是看一个class是否展现出 bitwise copy semantic。

### bitwise copy semantic（位逐次拷贝）

当我们的类中只含有内置类型或复合类型时，类展现了Bitwise copy 语意。这种情况下并不需要合成一个默认拷贝构造函数。

### 不展现bitwise copy semantic的情况

1. 当一个类内含一个member object 而后者的class声明有一个拷贝构造函数（不管是class设计者设计的还是编译器合成的）
2. 当class继承自一个base class而后者存在一个拷贝构造函数时（不论显示构造还是被合成的）
3. 当class声明了一个或多个virtual functions时
4. 当class派生自一个继承串链，其中有一个或多个virtual base class时

#### 前两种情况

编译器必须将“**类成员或基类的复制构造函数调用操作**”安插到新合成的拷贝构造函数中去，如果类设计者已经明确声明了一个拷贝构造函数，则这些调用操作代码将插入到已有的拷贝构造函数中去（在函数体的最前端插入）。

#### 后两种情况

后两种操作涉及到了虚表指针与虚基类指针的产生于初值设置。我们知道，当一个类含有虚函数时（无论这虚函数是类本身定义还是继承而来），在编译期间会有以下两个程序扩张操作:

- 为类增加一个虚表（virtual function table），虚表内含有每一个有作用的虚函数的地址。
- 为每一个类对象增加一个虚表指针（vptr)，虚表指针指向了该类的虚表。

##### 虚指针

显然，如果编译器对每个新定义的类对象不能正确地设置好初值，将导致严重的后果。所以编译器需要合成出一个复制构造函数来适当地初始化类对象的vptr。万一类设计者明确定义了自己的复制构造函数，则编译器会把设置vptr的操作插入到已有的拷贝构造函数中。而vptr的拷贝又有两种情况：

- 同类型对象间的vptr拷贝：同类类型的对象各自的vptr总是指向了同一个位置：该类的虚表指针。这时两个对象的vptr的拷贝都可以直接考”bitwise copy“来完成（除了可能会有的其他指针成员）。所以同类型对象间的vptr拷贝总是安全的。
- 把子类对象vptr拷贝给父类对象：不用担心把子类对象拷贝给父类对象时，vptr也会采用bitwise copy来拷贝，这点编译器给我们做了保证：编译器合成的默认构造函数（或者说在明确声明的拷贝构造函数中安插的代码）会明确设定父类的vptr指向父类的虚函数表，而不是采用傻瓜式直接拷贝子类对象vptr。

##### 虚继承

基类的存在需要特殊处理，一个类对象如果以另一个对象作为初值，而后者派生于虚基类，那么这种情况下bitwise copy语意也会失效，编译器会对派生自虚基类的类合成一个默认构造函数，在其中安插一些操作。对于虚继承，编译器有承偌：派生类对象中的虚基类位置在执行期就要准备妥当，维护“位置的完整性”是编译器的责任，而显然的，Bitwise copy 语意会破坏这个位置（这种傻瓜式的拷贝好像只适用内置类型的拷贝以及同类型对象间vptr的拷贝），所以编译器必须在它自己合成出来的拷贝构造函数中做出仲裁。同样的，如果类设计者明确声明了拷贝构造函数，则这些仲裁代码将安插在这个拷贝构造函数中。