### 符号表

一种存储键值对的数据结构，支持两个操作：插入和查找。



###顺序查找（基于无序链表）

这种符号表的插入和查找都需要遍历一遍链表，因此未命中的查找和插入操作都需要N次比较。命中的查找在最坏情况下需要N次比较。特别地，向一个空表中插入N个不同的键需要大约$N^2/2$次比较。



### 基于有序数组的二分查找

使用一对平数组，一个存储键，一个存储值。

在N个键的有序数组中进行二分查找最多需要lgN+1次比较（无论成功与否）。

虽然这种方式在查找上时间复杂度降低了，但是插入操作反而更加复杂了：向大小为N的有序数组中插入一个新的元素在最坏情况下需要访问大约2N次数组，因此向一个空有序数组插入N个元素在最坏情况下需要访问$N^2$次数组。

----



## 二叉查找树

二叉查找树是一棵二叉树，其中每个结点都含有一个键用以排序，且每个结点的键都大于其左子树中任意结点的键而小于其右子树中任意结点的键。

### 基本实现

通过嵌套定义一个结构体（类）来表示二叉树上的一个结点。

#### 查找

在二叉查找树中查找一个键的方法是使用递归算法：

- 如果树为空，则返回null，表示未找到
- 若根节点的键为要查找的键，则查找命中
- 若根节点不是要查找的键，则递归的在其子树中继续查找：
  - 若目标键小于根结点的键，则去根的左子树中查找
  - 若目标键大于根结点的键，则去根的右子树中查找

#### 分析

二叉查找树的运行时间取决于树的形状，而树的形状又取决于键插入的先后顺序。

最好的情况下，一棵含有N个结点的树是平衡的，叶子结点与根节点的距离（树的高度）大约为lgN；

最坏的情况下，一棵含有N个结点的树高度为N，级搜索路径上有N个结点。

#### 时间复杂度

在由N个随机构造的二叉查找树中，查找命中平均所需的比较次数为~2lnN（约1.39lgN），所以查找一次是O(lgN)级别的；插入一次的时间复杂度也是O(lgN)级别的。

#### 删除操作

二叉查找树中最难实现的就是删除结点方法。

删除x结点的具体步骤（这里使用被删除结点的后继结点来顶替该被删除结点）：

- 将指向即将被删除的结点的链接保存为t
- 将x指向它的后继结点min(t.right)
- 将x的右链接指向deleteMin(t.right)
- 将x的左链接设为t.left

#### 性能分析

在一棵查找二叉树中所有的操作在最坏情况下所需的时间都跟树的高度成正比。

----



## 平衡查找树



### 使用2-3查找树

2-3查找树或者是一棵空树，或者由以下结点构成：

- 2-结点：含有一个键和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。
- 3-结点：含有两个键和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键在该结点两个键之间，右链接指向的2-3树中的键都大于该结点。

#### 完美平衡的2-3查找树

一棵完美的2-3查找树中所有的空链接到根结点的距离都应该是相同的。

### 一些操作

**查找**操作和原来的二叉查找树的操作类似，只不过在3-结点时多了一个比较区间

**插入**操作有一些不同，这也是使用2-3查找树的主要原因，即该树的插入操作可以维持树的平衡：

- 如果未命中的查找结束于一个2-结点，那么就将该结点替换为一个3-结点，将要插入的键保存其中即可。
- 如果未命中的查找结束于一个3-结点，事情就麻烦了：首先将该结点替换为一个4-结点，然后再根据实际情况来分解这个4-结点：
  - 若这个结点就是一个3-结点的根结点，那么可以将这个结点分解为3个2-结点，这种情况就是**向一棵只含有一个3-结点的树中插入新键**
  - 若这个结点是一个父节点为2-结点的3-结点，对于分解这个新得到的4-结点，不会为中键创建一个新节点，而是将该键移动至原结点的父节点中，这样父节点也就从2-结点变为3-结点。**向一个父节点为2-结点的3-结点中插入新键**
  - 若这个结点是一个父节点为3-结点的3-结点，先将该4-结点分解，然后将中键插入到父节点，父节点此时成为4-结点，再将这个4-父结点分解，即将这个中键再次向上移动。推广到一般情况下，可能会一直不断的向上分解临时4-结点，直到遇到一个2-结点为止或达到根结点。这是就要分解根结点
  - 分解根节点就是将4-结点分解为3个2-结点，使树的高度加一。



#### 时间复杂度

在一棵大小为N的2-3树中，查找和插入的时间复杂度是O(lgN)级别的。

2-3查找树在最坏的情况下也仍有较好的性能。但是由于要维护两种不同的结点，还有各种复制、分解等操作，在实现起来不但需要大量的代码，也可能因为这些操作而产生大量的额外开销，反而可能比标准二叉查找树更慢。



### 红黑二叉查找树

红黑树的基本思想就是用标准的二叉查找树和一些额外的信息（替换3-结点）来表示2-3查找树。

将树中的链接分为两种：

- 红链将两个2-结点连接起来构成一个3-结点，其实就是用由一条左斜的红色链接相连的两个2-结点替换原来的3-结点。
- 黑链就是2-3查找树中普通的链接

#### 红黑树的等价定义

红黑树是一棵满足下列条件的二叉查找树

- 红链接均为左链接
- 没有任何一个结点同时和两个红链相连
- 该树是完美黑色平衡，即任意空链到根结点的路径上的黑链接数量相同。

满足这样定义的红黑树和相应的2-3树是一一对应的。

可以在结点中添加一个变量用来存放指向该结点的链接的颜色，因此当提到一个结点的颜色时，指的就是指向该结点的链接的颜色。

#### 旋转

在对红黑树进行操作时，很可能产生右红链，或者两条连续的红链。这时就需要使用旋转操作来进行修复。旋转会改变红链接的指向，将一个红色的右链接转化为左链接的操作称为左旋转。

旋转完毕后要重置父结点的链接。

#### 插入

##### 向2-结点中插入新键

一个只有一个键的红黑树只有一个2-结点。插入一个新键：

- 若新键小于老键，那么新增的结点就是一个被左红链指向的结点，不需其他操作
- 若新键大于老键，那么新增的结点就是一个被右红链指向的结点，这就需要旋转操作了
- 这两种情况最终都会产生一棵和单个3-结点等价的红黑树，其中含有两个键，一条红链，树的黑链高度为1.

##### 向树底部的2-结点插入新键

在插入操作中，总是使用红链将新结点与其父结点相连。如果它的父结点是个2-结点，那么上述的方法仍可以使用。

##### 向一棵双键树（即一个30-结点）中插入新键

有三种情况：

- 新键大于树中的两个键：直接将新键连接到3-结点的右结点，这时树就平衡了。树的根结点为中间大小的键，它有两条红链分别与最小和最大（三个键中比较的）结点相连。将两个红链都变为黑链就成了一棵2-3树。其它两种情况最终会转化成这种情况。
- 新键小于树中的两个键：新键会被链接到最左边的空连接上，这时就产生了两条连续的红链。这时只需要将上层的红链右旋转即可。这样又得到了根为中间键，且有两条红链的情况，然后将红链变为黑链即可。
- 新键介于树中两个键之间：将新键链接到做边结点的右空链接上，这时树中就有了两条连续的红链接，一条是左链接，一条是右链接。只需对下层红链接进行左旋转就得到了第二中情况，然后再对上层红链右旋转，得到第一种情况，最后将两条红链接变为黑链接即可。
- 这里将一个结点的两个红链变黑链的同时也会将该结点变为红结点，也就是把指向该结点的链接变为红链接。

##### 根结点总是黑色

如果根结点是红色则说明根结点是一个3-结点的一部分，但是该结点都已经是根了不会再是别的结点的一部分，因此在每次插入后都会将根结点设为黑色。

每当根结点由红变黑时树的黑链接高度就会加一。

##### 向树底部的3-结点插入新键

和向2-结点插入一样也会遇到那3情况，只需进行旋转以及颜色转换即可。颜色转变换会使中结点的链接变红，则会就相当于将它送入到父结点中，也就是向父结点中继续插入一个新键，因此也可以用上述相同的方式解决这个问题。

##### 将红色链接向上传递

在2-3树中，向一个3-结点插入新结点，会先临时创建一个4-结点，然后将该结点分解并将中键传递给父结点。重复这个过程，直到遇到一个2-结点或根结点为止。

红黑树道理也相同：经过必要的旋转后进行颜色转换，并使得中结点变红。在父结点看来处理这样一个红色结点的方式和处理一个新插入的红色结点完全相同。

总结起来就是在沿着插入结点到根结点的路径向上所经过的每个结点中顺序完成一下三个操作（符合条件才会执行，不符合条件就跳过，继续执行下一个操作）：

- 如果右子结点为红色而左子结点为黑色，进行左旋转
- 如果左子结点是红色且它的左子结点也是红色，进行右旋转
- 如果左右子结点都是红色，进行颜色转换

路径中的每个结点经过这三个步骤之后，红色链接就会不断上移，直至平衡或达到根结点。

#### 删除操作



#### 红黑树的性质

所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别（范围查找除外，它需要额外的时间和返回的键的数量成正比）。

**一棵大小为N的红黑树的高度不会超过2lgN，根结点到任意结点的平均路径长度为~1.00lgN**



## 散列表



使用散列的查找算法分为两步：

- 第一步是使用散列函数将被查找的键转化为数组的一个索引
- 第二步是处理碰撞冲突的过程，有两种处理碰撞方法：拉链法和线性探测法

要为一个数据类型实现一个优秀的散列方法必须满足三个条件：

- 一致性：等价的键必然产生相等的散列值
- 高效性：计算简便



### 基于拉链法的散列表

将大小为M的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。

这种方法的基本思想是：选择足够大的M，使得所有链表都尽可能短以保证高效的查找。

查找分为两步：

- 先根据散列值找到对应的链表
- 沿着链表顺序查找相应的键



在一张含有M条链表和N个键的散列表中，未命中查找和插入操作所需的比较次数~N/M

#### 关于有序性

散列的主要目的是均匀的将键散布开来，因此在计算完散列值后键的顺序信息就丢失了。因此散列表不适合快速的查找最大或最小的键，亦或是查找某个范围内的键。



### 基于线性探测法的散列表

用一个大小为M的数组保存大小为N个键值对，其中M>N。这样就可以使用数组中的空位来解决碰撞冲突。基于这种策略的所有方法被统称为**开放地址散列表**。

开放地址散列表中最简单的方法是**线性探测法**：当发生碰撞时，直接使用散列表中的下一个位置。

在查找时用散列函数计算键在数组中的索引，检查其中的键与被查找的键是否相同。如果不同就继续查找（索引增大，到达数组末尾时折回数组开头），直到找到该键或遇到一个空元素为止。