

排序算法可以分成两类：

- 一类是原地排序：指除了函数调用所需的栈和固定变量之外无需额外的内存空间的算法
- 一类是非原地排序：需要额外内存空间来存储另一份数据副本的其他排序算法

----

## 初级排序

### 选择排序

首先找到数组中最小的元素，将它与数组第一个数交换位置（如果第一个数恰好是整个最小的数，那么就将其与自身交换）。然后从数组第二个数开始在剩下的元素中找到最小的元素并替换数组第二个元素，以此类推，直到整个数组有序为止。

这就是选择排序，即不断的从数组中选择相对最小的元素。

#### 时间复杂度

对于长度为N的数组，选择排序需要大约$N^2/2$次比较，N次交换。

证明：第一个数需要比较N-1次，第二个数需要比较N-2次，第N-1个数需要比较1次，最后一个数不用比较。因此有：

$$(N-1) + (N-2) + (N-3) + ...+2+1 = ((N-1) + 1) *(N-1)/2 = N^2/2 - N/2 = O(N^2)$$

至于交换的次数，很明显是N-1次，即O(N)级别的。

#### 特点

- 运行时间和输入无关，与函数的规模有关，即N的大小。即使输入的是一个有序的数组，也要进行这么多次的比较和交换。这也证明了该算法在某些情况下的低效。
- 数据移动是最少的。每次循环只是交换一次，最多交换N-1次

-----



### 插入排序

就是将每个元素插入到已经有序部分中适当在的位置上，当每个元素都在它应该的位置上时，这个数组也就有序了。在进行插入时，要给准备插入的元素腾出空间，因此要将其余元素向右移动。

#### 时间复杂度

与选择排序不同的是，插入排序受输入数组的有序性的影响。若一个数组一开始就是有序的，那么这个算法的时间复杂度是O(N)级别的，即需要N-1次比较和0次交换；若一个数组开始就是逆序的，则需要大约次$N^2/2$比较和$N^2/2$次交换。

插入排序需要的交换操作和数组中的倒置的数量相同。

倒置是指数组中两个顺序颠倒的元素对。当一个数组的倒置的个数少于数组的长度时，这个数组就是部分有序的。对于部分有序的数组，插入排序的效率非常高。

----

### 上述两个排序的比较

对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间都是平方级别的，两者之比是一个较小的常数。

----

### 希尔排序

希尔排序是在插入排序的基础上的一种改进。插入排序总是将相邻的元素进行交换，即间隔为1的元素进行交换，如果一个较小的数离它正确位置比较远，那么就要进行多次交换。而希尔排序首先对数组进行分组，每组元素是由原数组中间隔为h的几个元素组成的，先将这几组数据分别排序，这样元素跨度比较大，位置靠后的较小的数可以很快的交换到数组前部去（默认数组前部是索引小的那一方，也就是值比较小的元素的那一方）。即间隔为h的元素进行交换。然后按照一定规律降低h值，并以这个较小的h为间隔将数组分组并排序。逐渐降低h直到h为1退化成普通插入排序，这时候整个数组也成了局部有序的数组。根据之前的结论，插入排序对局部有序的数组的排序效率很高。

总的来说希尔排序的思想是使数组中任意间隔为h的元素都是有序的。这样的数组被称为h有序数组。

希尔排序在最开始各个子数组都很小，排序之后的子数组都是部分有序的。

一般来说希尔排序的时间复杂度达不到平方级别。已知在最坏情况下，采用序列$1/2(3^k-1)$最为h递增序列时，时间复杂度为 $N^{3/2}$ 级别的。

----

### 几个问题

#### 为什么有这么多排序算法？

原因之一就是很多排序算法的性能都和输入模型有很大关系，因此不同的算法适用于不同的输入模型。

----



## 归并排序

将一个数组先递归的分成两部分并分别排序，再将结果归并起来。

### 归并

一种实现归并的简单方法就是将两个有序的数组通过比较归并到第三个数组中。这种方法在遇到数组元素比较多时，就要进行多次归并，也就是多次创建一个新数组来存放归并结果，这样做的效率不是很高，因此就需要一种原地归并的算法。

#### 原地归并

先将前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要使用额外的内存空间。

书中的实现方法是先将所有元素复制到一个辅助数组中，再把归并结果放回到原数组中。（这里有个疑问，在本章的最开始书中就提到原地排序的概念：指除了函数调用所需的栈和固定变量之外无需额外的内存空间的算法。那么这里使用了辅助数组不也是开辟了额外空间？为什么还叫原地排序？难道是因为归并的结果直接在原数组中体现出来而不是在第三个数组中？）

### 自顶向下的归并排序

应用分而治之的思想。

#### 时间复杂度

对于长度为N的数组，自顶向下的归并排序需要$1/2NlgN$至$NlgN$次比较，最多访问数组$6NlgN$次。

因此归并排序的时间复杂度是O(NlgN)级别的。

#### 特点

优点是时间复杂度为O(NlgN)级别的，缺点是该算法的空间复杂度是O(N)级别的。

#### 一些改进

- 对小规模子数组使用插入排序：递归在应对小规模问题时的调用过于频繁，显然太浪费空间了，因此可使用插入排序
- 判断数组是否已经有序，如果a[mid] < a[mid+1]就不用进行merge了，可以跳过。这样对于任意有序的子数组，算法的运行时间就变为线性的了。



### 自底向上的归并排序

一般的归并的思想是分而治之，将一个大问题分割成小问题分别解决，再用小问题来回答大问题；但也可以直接从小问题出发，即先归并小规模的数据，然后再成对的归并得到的子数组，直到将整个数组归并到一起。这就是自底向上的归并排序。

再详细点说就是，先将数组元素两两归并（把每个元素当成大小为1的数组），然后四四归并，然后八八归并，一直下去，最终完成整个数组的归并。在最后一次归并中，可能存在两个子数组大小不一致，但不影响归并操作。

#### 时间复杂度

对于长度为N的数组，自底向上的归并排序需要$1/2NlgN$至$NlgN$次比较，最多访问数组$6NlgN$次。

因此归并排序的时间复杂度是O(NlgN)级别的。

当数组的长度为2的幂的时候，自顶向下和自底向上的归并排序的比较次数和访问数组的次数正好相等。

#### 特点

自底向上的归并适用于用链表组织的数据。这中算法只需要重新组织链表链接的顺序而不需要建立新的链表节点。