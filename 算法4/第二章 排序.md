

排序算法可以分成两类：

- 一类是原地排序：指除了函数调用所需的栈和固定变量之外无需额外的内存空间的算法
- 一类是非原地排序：需要额外内存空间来存储另一份数据副本的其他排序算法

----

## 初级排序

### 选择排序

首先找到数组中最小的元素，将它与数组第一个数交换位置（如果第一个数恰好是整个最小的数，那么就将其与自身交换）。然后从数组第二个数开始在剩下的元素中找到最小的元素并替换数组第二个元素，以此类推，直到整个数组有序为止。

这就是选择排序，即不断的从数组中选择相对最小的元素。

#### 时间复杂度

对于长度为N的数组，选择排序需要大约$N^2/2$次比较，N次交换。

证明：第一个数需要比较N-1次，第二个数需要比较N-2次，第N-1个数需要比较1次，最后一个数不用比较。因此有：

$$(N-1) + (N-2) + (N-3) + ...+2+1 = ((N-1) + 1) *(N-1)/2 = N^2/2 - N/2 = O(N^2)$$

至于交换的次数，很明显是N-1次，即O(N)级别的。

#### 特点

- 运行时间和输入无关，与函数的规模有关，即N的大小。即使输入的是一个有序的数组，也要进行这么多次的比较和交换。这也证明了该算法在某些情况下的低效。
- 数据移动是最少的。每次循环只是交换一次，最多交换N-1次

-----



### 插入排序

就是将每个元素插入到已经有序部分中适当在的位置上，当每个元素都在它应该的位置上时，这个数组也就有序了。在进行插入时，要给准备插入的元素腾出空间，因此要将其余元素向右移动。

#### 时间复杂度

与选择排序不同的是，插入排序受输入数组的有序性的影响。若一个数组一开始就是有序的，那么这个算法的时间复杂度是O(N)级别的，即需要N-1次比较和0次交换；若一个数组开始就是逆序的，则需要大约次$N^2/2$比较和$N^2/2$次交换。

插入排序需要的交换操作和数组中的倒置的数量相同。

倒置是指数组中两个顺序颠倒的元素对。当一个数组的倒置的个数少于数组的长度时，这个数组就是部分有序的。对于部分有序的数组，插入排序的效率非常高。

----

### 上述两个排序的比较

对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间都是平方级别的，两者之比是一个较小的常数。

----

### 希尔排序

希尔排序是在插入排序的基础上的一种改进。插入排序总是将相邻的元素进行交换，即间隔为1的元素进行交换，如果一个较小的数离它正确位置比较远，那么就要进行多次交换。而希尔排序首先对数组进行分组，每组元素是由原数组中间隔为h的几个元素组成的，先将这几组数据分别排序，这样元素跨度比较大，位置靠后的较小的数可以很快的交换到数组前部去（默认数组前部是索引小的那一方，也就是值比较小的元素的那一方）。即间隔为h的元素进行交换。然后按照一定规律降低h值，并以这个较小的h为间隔将数组分组并排序。逐渐降低h直到h为1退化成普通插入排序，这时候整个数组也成了局部有序的数组。根据之前的结论，插入排序对局部有序的数组的排序效率很高。

总的来说希尔排序的思想是使数组中任意间隔为h的元素都是有序的。这样的数组被称为h有序数组。

希尔排序在最开始各个子数组都很小，排序之后的子数组都是部分有序的。

一般来说希尔排序的时间复杂度达不到平方级别。已知在最坏情况下，采用序列$1/2(3^k-1)$最为h递增序列时，时间复杂度为 $N^{3/2}$ 级别的。

----

### 几个问题

#### 为什么有这么多排序算法？

原因之一就是很多排序算法的性能都和输入模型有很大关系，因此不同的算法适用于不同的输入模型。

----



## 归并排序

将一个数组先递归的分成两部分并分别排序，再将结果归并起来。

### 归并

一种实现归并的简单方法就是将两个有序的数组通过比较归并到第三个数组中。这种方法在遇到数组元素比较多时，就要进行多次归并，也就是多次创建一个新数组来存放归并结果，这样做的效率不是很高，因此就需要一种原地归并的算法。

#### 原地归并

先将前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要使用额外的内存空间。

书中的实现方法是先将所有元素复制到一个辅助数组中，再把归并结果放回到原数组中。（这里有个疑问，在本章的最开始书中就提到原地排序的概念：指除了函数调用所需的栈和固定变量之外无需额外的内存空间的算法。那么这里使用了辅助数组不也是开辟了额外空间？为什么还叫原地排序？难道是因为归并的结果直接在原数组中体现出来而不是在第三个数组中？）

### 自顶向下的归并排序

应用分而治之的思想。

#### 时间复杂度

对于长度为N的数组，自顶向下的归并排序需要$1/2NlgN$至$NlgN$次比较，最多访问数组$6NlgN$次。

因此归并排序的时间复杂度是O(NlgN)级别的。

#### 特点

优点是时间复杂度为O(NlgN)级别的，缺点是该算法的空间复杂度是O(N)级别的。

#### 一些改进

- 对小规模子数组使用插入排序：递归在应对小规模问题时的调用过于频繁，显然太浪费空间了，因此可使用插入排序
- 判断数组是否已经有序，如果a[mid] < a[mid+1]就不用进行merge了，可以跳过。这样对于任意有序的子数组，算法的运行时间就变为线性的了。



### 自底向上的归并排序

一般的归并的思想是分而治之，将一个大问题分割成小问题分别解决，再用小问题来回答大问题；但也可以直接从小问题出发，即先归并小规模的数据，然后再成对的归并得到的子数组，直到将整个数组归并到一起。这就是自底向上的归并排序。

再详细点说就是，先将数组元素两两归并（把每个元素当成大小为1的数组），然后四四归并，然后八八归并，一直下去，最终完成整个数组的归并。在最后一次归并中，可能存在两个子数组大小不一致，但不影响归并操作。

#### 时间复杂度

对于长度为N的数组，自底向上的归并排序需要$1/2NlgN$至$NlgN$次比较，最多访问数组$6NlgN$次。

因此归并排序的时间复杂度是O(NlgN)级别的。

当数组的长度为2的幂的时候，自顶向下和自底向上的归并排序的比较次数和访问数组的次数正好相等。

#### 特点

自底向上的归并适用于用链表组织的数据。这中算法只需要重新组织链表链接的顺序而不需要建立新的链表节点。

----



## 快速排序

### 基本算法

快排也是一种分治的思想。将一个数组分为两部分，将两部分独立的排序。与归并不同的是，快排中两个子数组有序了整个数组也就有序了；而归并是先将两个子数组分别排序，再将有序的子数组归并成整个的有序的数组。

在归并中数组是二等分的，而快排中的切分位置是取决于数组的。

快排的核心部分是切分，切分过程使得数组满足下面三个条件：

- 对于位置j，a[j]的值已经确定
- 对于a[l]到a[j-1]的值都小于等于a[j]
- 对于a[l+1] 到a[r]的值都大于等于a[j]

#### 时间复杂度

对于长度为N的数组，快速排序的平均比较次数是约等于$NlnN$次。

在最坏情况下，快速排序最多需要$N^2/2$ 次比较。最坏情况是指第一次从最小的元素切分，第二次从次最小的元素切分，如此循环，每次只会移除一个元素。这就会导致一个大数组切分很多次，即切分不平衡。

### 算法改进

#### 切换到插入排序

就是在小规模数据上使用插入排序。对于小数组，插入排序比快速排序快。

因为递归，快速排序的sort函数在小数组中也会调用自己。

#### 三取样切分

使用一小部分元素的中位数来切分数组。人们发现在取样大小为3时并用居中的元素来切分的效果更好。

#### 熵最优的排序（三路快排）

实际情况中会出现含有大量重复元素的数组。而一个元素全部重复的子数组就不需要继续排序了，但是在之前的快排算法实现还是会继续处理下去，这就有很大的改进潜力。

**三路快排的思想**就是在每次sort结束后将数组切分为三部分，分别是小于、等于和大于切分元素的三个数组。然后再对分别对小于切分元素和大于切分元素的子数组继续使用三路快排，至于等于切分元素的子数组就已经排定位置了，不需要再操作了。

**具体实现**：

- 就是先假定有四个集合（子数组），小于切分元素集合Low、等于切分元素集合Equal、大于切分元素集合Large和未进行处理的集合UP（Unprocessed ）。
- 在排序之处，Low、Large集合分别为空，选定一个切分元素放到Equal中，而UP集合中相当于有N-1个元素。
- 在排序时，主要工作就是维护三个Low、Large以及Equal子数组，对于一个未分组的元素，将其与切分元素进行比较，根据切分结果将该元素加入到相应的集合中，这是UP集合的元素就减少一个
- 直到UP集合中没有元素了，排序也就完成了。
- 这里划分集合并不是建立新的数组来存放这些集合的元素，而是在原数组上进行原地排序。

#### 时间复杂度

对于存在大量重复元素的数组，它将排序时间从线性对数级别降低到线性级别。



----



## 优先队列

优先队列是一种抽象数据类型，表示了一组值和对这组值得操作。

优先队列最重要的操作就是删除最大元素和插入元素，给予这两个操作，优先队列可以应用到很多场合。比如系统根据程序的优先级按序处理事件，先处理优先级最高的程序，当该程序处理完就需要将其从优先队列中删除以便于下次处理次优先的程序；当有一个新的程序需要系统来处理，就要使用插入操作来将其加入到优先队列中。

优先队列可以使用初级方式实现也可以使用堆来实现。

### 初级方式

可以使用有序数组或无序数组，也可使用有序链表和无序链表。

当使用有序的数组时，其删除操作是O(1)级别的，因为是有序的所以一下就可找到最大值在哪；但是插入操作就是O(N)级别的，因为每次插入都要保证有序性。

当使用无序的数组时，其删除操作是O(N)级别的，因为是无序所以不能一下就找到最大值，要需要遍历一遍数组才能找到最大值；但插入操作是O(1)级别的，不用管顺序，直接插入到数组中即可。

当时用堆来实现时，这两个操作都是O(NLogN)级别的。这就体现出了基于堆实现的优势。

### 堆

**堆有序**：当一棵二叉树的每个结点都大于等于它的两个子结点，这棵二叉树就是堆有序的。

**二叉堆**：是一组能够用满足堆有序的完全二叉树排序的元素，并在数组中按层级存储（不使用数组的第一个位置）

根节点是二叉堆中的最大结点（这里默认是最大堆，当然也可以建立最小堆，此时根节点是二叉堆中的最小结点）

在使用数组存放二叉堆时，在不使用第一个位置的时候（即不使用索引为0的位置），根节点就放在索引为1的位置；树中任意结点k（按从上到下，从左到右排序）的父节点就是k/2，k的左孩子就是2\*k，右孩子就是2\*k+1

一棵大小为N的完全二叉树的高度为lgN向下取整。

堆对外的接口主要是删除最大元素（或找到最大元素）、插入元素或者是改变某个元素的值，但是这几个操作都可能打破原来堆的有序性，因此在“底层”需要两个函数在堆中元素有改变时来维持堆的有序性。这两个函数分别是：

- 上浮：由下至上的堆有序化，也就是说当某个节点的优先级提升时，需要由下向上恢复堆的有序性。
- 下沉：由上至下的堆有序化，也就是说当某个节点的优先级降低时，需要由上至下恢复堆的有序性。

#### 上浮

当某个结点因某些操作变得比他父结点大时，就需要将它与它的父结点交换，交换后的新的父结点要比它的两个子结点都大。通过这样不停的比较与交换，直到堆有序为止。

#### 下沉

当某个结点因为某些操作变得比他子结点小时，就需要将它与它的较大的子结点交换来恢复堆有序。

#### 时间复杂度

对于一个含有N个元素的基于堆的优先队列，插入元素的操作只需不超过（lgN+1）此比较，删除最大元素的操作需要不超过2lgN次比较。

因为这两种操作都是在根节点到堆底之间移动元素，所以其路径长度不会超过lgN。

#### 索引堆

普通的堆有个问题就是当堆构建完后就无法通过原来的顺序找到相应的数据，同时当使用堆排序时，如果是对数组原地排序，排序过后就无法通过原来的索引找到原来的数据。

还有个问题就是普通的堆在进行比较或交换时，都是直接对数据进行操作，当数据量很大时，交换操作就会消耗很多资源从而降低性能。

为了解决上述的问题，就出现了索引堆：将数据和索引分开存储，堆（数组）中存放的是数据在原来数组中的索引，而数据存放在另一个数组中，且可以通过堆中存放的索引可以直接在数据数组中直接找到数据。

因此在构建堆的过程中，只是索引在进行交换，这样就客服了上述的第二个问题。同时，这样也维持住数据在原来数组的索引位置，这也就解决了第一个问题。

建立索引堆后就可以增加对堆的操作，不光有插入和删除，还要有修改，以及返回最大值的索引等。

插入需要输入两个参数，一个是数据`d`，另一个是数据`d`在原数组中的索引`i`。修改也同样是这两个参数，但是修改完堆对象中数据数组中的相应数据后，需要对堆进行更新。因此需要找到索引`i`在索引堆中的位置`j`，然后对`j`分别做一次上浮，一次下沉，从而维护堆有序性。这里查找i的位置只需遍历一次索引数组即可，但是这样做使得修改单个数据的时间复杂度达到O(N+lgN) = O(N)级别的，因此当进行N个数据修改时就会达到时间复杂度为O(N^2)级别的，显然需要优化。

 优化方式是再在类中加入一个成员变量，即反向查找数组rev，数组存放着上述索引在堆中的位置，例如`rev[i] == j`这样在修改`i`位置的数据时，`i`在堆中的位置可以直接从rev数组中直接读取出来，这样时间复杂度就降为O(1+lgN) == O(lgN)级别的了。

总得来说就是在构建、插入、删除以及修改时要维护相应的三个数组。分别是数据数组data，索引数组indexes和反向查找数组rev。





### 堆排序

#### 基本堆排序

就是将一个数组传入到一个最大（小）堆中，再依次从堆中取出最大（小）值，就完成了堆排序。

这里将数组传入到堆中由两种方式：

- 遍历数组依次插入到堆中，即使用堆的insert()成员函数，这种方式的时间复杂度是O(NlgN)级别的
- 将整个数组复制到堆对象中的数组（存放堆中元素的那个数组）中然后用下沉函数将对象中的数组构造成最大堆。最开始在构造堆时，只需要扫描数组中一半的元素，即从N/2开始递减至1，这样做是因为不用考虑那些大小为1的堆。具体原理是如果一个节点的两个子结点已经是堆了，那么只需对该结点调用下沉函数，就会使它们成为一个堆。这种做法也叫Heapify，即直接将原始数组**堆化**(**Heapify**)，或者直接在原始数组上建立堆(BuildHeap)，用下沉操作由N个元素构造堆，只需要少于2*N次比较和至少N次交换，因此时间复杂度为O(N)。

#### 原地堆排序

上述的基本堆排序空间复杂度都是O(N)级别的，而原地堆排序可以直接在原待排数组上进行操作，从而降低空间复杂度。

原地堆排序首先也是构造最大（小）堆，只不过不是将数组传入到堆对象中，而直接将原待排数组堆化（Heapify）。然后每次交换数组索引为1和索引为N的元素并再次对索引1使用下沉函数，最后将N减一。如此循环，直到N==1为止。这样做是为了每次将堆中最大值放到最后，从而形成从小到大的排序。

#### 时间复杂度

将N个元素排序，**原地堆排序**只需要少于（2NlgN+2N）次比较（以及一半次数的交换）。2N来自于堆构造（堆化），2NlgN来自每次下沉操作最大可能需要2lgN次比较，一共需要大约N次。

----

## 其他

### 稳定性

如果一个排序算法能够保留数组中重复元素的相对位置则可以被称为时稳定的。

插入排序和归并排序是稳定的

而选择排序、希尔排序、快速排序和堆排序不是稳定的。

但是有很多方法可以将任意排序算法变成稳定的，但一般值在必要的情况下稳定的排序算法才有优势。

### 各种排序算法的总结

![](https://github.com/PantaSun/ReadingNotes/blob/master/%E7%AE%97%E6%B3%954/sort.png)