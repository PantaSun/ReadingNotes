

排序算法可以分成两类：

- 一类是原地排序：指除了函数调用所需的栈和固定变量之外无需额外的内存空间的算法
- 一类是非原地排序：需要额外内存空间来存储另一份数据副本的其他排序算法

----

## 初级排序

### 选择排序

首先找到数组中最小的元素，将它与数组第一个数交换位置（如果第一个数恰好是整个最小的数，那么就将其与自身交换）。然后从数组第二个数开始在剩下的元素中找到最小的元素并替换数组第二个元素，以此类推，直到整个数组有序为止。

这就是选择排序，即不断的从数组中选择相对最小的元素。

#### 时间复杂度

对于长度为N的数组，选择排序需要大约$N^2/2$次比较，N次交换。

证明：第一个数需要比较N-1次，第二个数需要比较N-2次，第N-1个数需要比较1次，最后一个数不用比较。因此有：

$$(N-1) + (N-2) + (N-3) + ...+2+1 = ((N-1) + 1) *(N-1)/2 = N^2/2 - N/2 = O(N^2)$$

至于交换的次数，很明显是N-1次，即O(N)级别的。

#### 特点

- 运行时间和输入无关，与函数的规模有关，即N的大小。即使输入的是一个有序的数组，也要进行这么多次的比较和交换。这也证明了该算法在某些情况下的低效。
- 数据移动是最少的。每次循环只是交换一次，最多交换N-1次

-----



### 插入排序

就是将每个元素插入到已经有序部分中适当在的位置上，当每个元素都在它应该的位置上时，这个数组也就有序了。在进行插入时，要给准备插入的元素腾出空间，因此要将其余元素向右移动。

#### 时间复杂度

与选择排序不同的是，插入排序受输入数组的有序性的影响。若一个数组一开始就是有序的，那么这个算法的时间复杂度是O(N)级别的，即需要N-1次比较和0次交换；若一个数组开始就是逆序的，则需要大约次$N^2/2$比较和$N^2/2$次交换。

插入排序需要的交换操作和数组中的倒置的数量相同。

倒置是指数组中两个顺序颠倒的元素对。当一个数组的倒置的个数少于数组的长度时，这个数组就是部分有序的。对于部分有序的数组，插入排序的效率非常高。

----

### 上述两个排序的比较

对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间都是平方级别的，两者之比是一个较小的常数。

----

### 希尔排序

希尔排序是在插入排序的基础上的一种改进。插入排序总是将相邻的元素进行交换，即间隔为1的元素进行交换，如果一个较小的数离它正确位置比较远，那么就要进行多次交换。而希尔排序首先对数组进行分组，每组元素是由原数组中间隔为h的几个元素组成的，先将这几组数据分别排序，这样元素跨度比较大，位置靠后的较小的数可以很快的交换到数组前部去（默认数组前部是索引小的那一方，也就是值比较小的元素的那一方）。即间隔为h的元素进行交换。然后按照一定规律降低h值，并以这个较小的h为间隔将数组分组并排序。逐渐降低h直到h为1退化成普通插入排序，这时候整个数组也成了局部有序的数组。根据之前的结论，插入排序对局部有序的数组的排序效率很高。

总的来说希尔排序的思想是使数组中任意间隔为h的元素都是有序的。这样的数组被称为h有序数组。

希尔排序在最开始各个子数组都很小，排序之后的子数组都是部分有序的。

一般来说希尔排序的时间复杂度达不到平方级别。已知在最坏情况下，采用序列$1/2(3^k-1)$最为h递增序列时，时间复杂度为 $N^{3/2}$ 级别的。

----

### 几个问题

#### 为什么有这么多排序算法？

原因之一就是很多排序算法的性能都和输入模型有很大关系，因此不同的算法适用于不同的输入模型。

----



## 归并排序

将一个数组先递归的分成两部分并分别排序，再将结果归并起来。

### 归并

一种实现归并的简单方法就是将两个有序的数组通过比较归并到第三个数组中。这种方法在遇到数组元素比较多时，就要进行多次归并，也就是多次创建一个新数组来存放归并结果，这样做的效率不是很高，因此就需要一种原地归并的算法。

#### 原地归并

先将前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要使用额外的内存空间。

书中的实现方法是先将所有元素复制到一个辅助数组中，再把归并结果放回到原数组中。（这里有个疑问，在本章的最开始书中就提到原地排序的概念：指除了函数调用所需的栈和固定变量之外无需额外的内存空间的算法。那么这里使用了辅助数组不也是开辟了额外空间？为什么还叫原地排序？难道是因为归并的结果直接在原数组中体现出来而不是在第三个数组中？）

### 自顶向下的归并排序

应用分而治之的思想。

#### 时间复杂度

对于长度为N的数组，自顶向下的归并排序需要$1/2NlgN$至$NlgN$次比较，最多访问数组$6NlgN$次。

因此归并排序的时间复杂度是O(NlgN)级别的。

#### 特点

优点是时间复杂度为O(NlgN)级别的，缺点是该算法的空间复杂度是O(N)级别的。

#### 一些改进

- 对小规模子数组使用插入排序：递归在应对小规模问题时的调用过于频繁，显然太浪费空间了，因此可使用插入排序
- 判断数组是否已经有序，如果a[mid] < a[mid+1]就不用进行merge了，可以跳过。这样对于任意有序的子数组，算法的运行时间就变为线性的了。



### 自底向上的归并排序

一般的归并的思想是分而治之，将一个大问题分割成小问题分别解决，再用小问题来回答大问题；但也可以直接从小问题出发，即先归并小规模的数据，然后再成对的归并得到的子数组，直到将整个数组归并到一起。这就是自底向上的归并排序。

再详细点说就是，先将数组元素两两归并（把每个元素当成大小为1的数组），然后四四归并，然后八八归并，一直下去，最终完成整个数组的归并。在最后一次归并中，可能存在两个子数组大小不一致，但不影响归并操作。

#### 时间复杂度

对于长度为N的数组，自底向上的归并排序需要$1/2NlgN$至$NlgN$次比较，最多访问数组$6NlgN$次。

因此归并排序的时间复杂度是O(NlgN)级别的。

当数组的长度为2的幂的时候，自顶向下和自底向上的归并排序的比较次数和访问数组的次数正好相等。

#### 特点

自底向上的归并适用于用链表组织的数据。这中算法只需要重新组织链表链接的顺序而不需要建立新的链表节点。

----



## 快速排序

### 基本算法

快排也是一种分治的思想。将一个数组分为两部分，将两部分独立的排序。与归并不同的是，快排中两个子数组有序了整个数组也就有序了；而归并是先将两个子数组分别排序，再将有序的子数组归并成整个的有序的数组。

在归并中数组是二等分的，而快排中的切分位置是取决于数组的。

快排的核心部分是切分，切分过程使得数组满足下面三个条件：

- 对于位置j，a[j]的值已经确定
- 对于a[l]到a[j-1]的值都小于等于a[j]
- 对于a[l+1] 到a[r]的值都大于等于a[j]

#### 时间复杂度

对于长度为N的数组，快速排序的平均比较次数是约等于$NlnN$次。

在最坏情况下，快速排序最多需要$N^2/2$ 次比较。最坏情况是指第一次从最小的元素切分，第二次从次最小的元素切分，如此循环，每次只会移除一个元素。这就会导致一个大数组切分很多次，即切分不平衡。

### 算法改进

#### 切换到插入排序

就是在小规模数据上使用插入排序。对于小数组，插入排序比快速排序快。

因为递归，快速排序的sort函数在小数组中也会调用自己。

#### 三取样切分

使用一小部分元素的中位数来切分数组。人们发现在取样大小为3时并用居中的元素来切分的效果更好。

#### 熵最优的排序（三路快排）

实际情况中会出现含有大量重复元素的数组。而一个元素全部重复的子数组就不需要继续排序了，但是在之前的快排算法实现还是会继续处理下去，这就有很大的改进潜力。

**三路快排的思想**就是在每次sort结束后将数组切分为三部分，分别是小于、等于和大于切分元素的三个数组。然后再对分别对小于切分元素和大于切分元素的子数组继续使用三路快排，至于等于切分元素的子数组就已经排定位置了，不需要再操作了。

**具体实现**：

- 就是先假定有四个集合（子数组），小于切分元素集合Low、等于切分元素集合Equal、大于切分元素集合Large和未进行处理的集合UP（Unprocessed ）。
- 在排序之处，Low、Large集合分别为空，选定一个切分元素放到Equal中，而UP集合中相当于有N-1个元素。
- 在排序时，主要工作就是维护三个Low、Large以及Equal子数组，对于一个未分组的元素，将其与切分元素进行比较，根据切分结果将该元素加入到相应的集合中，这是UP集合的元素就减少一个
- 直到UP集合中没有元素了，排序也就完成了。
- 这里划分集合并不是建立新的数组来存放这些集合的元素，而是在原数组上进行原地排序。