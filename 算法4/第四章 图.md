## 前言

#### 图

图是由一组顶点和一组能够将两个顶点相连的边组成的。

#### 特殊的图

- 自环：即一条连接一个顶点和其自身的边
- 平行边：连接同一对顶点的两条边称为平行边
- 数学家常常将含有平行边的图称为多重图
- 将没有平行边或自环的图称为简单图

## 无向图

#### 无向图

边仅仅是两个顶点之间的连接（无其它含义）的图称为无向图。

### 一些术语

#### 相邻

两个顶点通过一条边相连时，称这两个顶点时相邻的，并称连接依附于这两个顶点

#### 度数

依附于某个顶点的边的总数称为该顶点的度数

#### 子图

由一幅图的所有边的子集（以及它们所依附的顶点）组成的图称为子图

#### 路径

路径是由边顺序连接的一系列顶点。

#### 简单路径

是一条没有重复顶点的路径

#### 环

是一条至少含有一条边其起点和终点相同的路径

#### 简单环

是一条不含重复顶点和边的环

#### 路径/环的长度

路径/环中所包含的边数为路径/环的长度

#### 连通图

如果从任意一个顶点都存在一条路径到达另一个任意顶点，则称这种图为连通图。

一幅非连通图由若干连通的部分组成，它们都是其极大连通子图。

#### 稀疏图与稠密图

如果一幅图中不同的边的数量在顶点总数V的一个小的常数倍以内，那么可以认为这幅图是稀疏的，否则就是稠密的。

### 图的几种表示方法

#### 邻接矩阵

使用一个V * V的布尔矩阵，矩阵中所有值默认false（即任何两个顶点之间没有连接）。当顶点v和顶点w之间有连接时，矩阵中v行w列的值设为true。

这种表示方法在V为上百万的值时，V的平方大小的布尔矩阵所需的空间是一般机器无法给予的。

无法表示带有平行边的图。

#### 边的数组

定义一个Edge类，它包含两个int变量，保存边所依附的两个顶点。

这种方法不能遍历图中所有的边。

#### 邻接表数组

用一个以顶点为索引的列表数组，其中数组中每个元素是一个列表，每个列表中存放与该列表在数组中索引（顶点）相连接的顶点。

### 图的搜索（遍历）

#### 深度优先搜索（DFS）

深度优先搜索就是用一个递归方法来遍历所有顶点。在访问其中一个顶点时：

- 将它标记为已经访问的顶点
- 递归的访问它所有没有被标记的过的邻居顶点

在DFS中使用一个boolean数组来记录和起点连通的所有顶点。递归方法会标记给定的顶点并调用方法本身来访问该点的相邻的没有被标记过的顶点。如果图是连通的，每个邻接链表中的元素都会被检查到。

**深度优先搜索标记与起点连通的所有顶点所需的时间与顶点的度数之和成正比**

#### 寻找路径

**单点路径问题**：给定一幅图和一个起点s，问“起点s到给定目的顶点v之间是否存在一条路径？”，若存在，请找出这条路径。

#### 基于深度优先搜索的路径

给定一个起点s，使用DFS遍历s的相邻顶点，并用一个布尔类型的marked数组来表示顶点是否被访问过，访问过的就标记为true，默认为未标记过则值为false。再用一个int类型的eageTo数组表示每个顶点的来源顶点（就是从哪个顶点遍历过来的），例如索引为1的顶点是由索引为4的顶点便利来的，那么`edgeTo[1]=4;`，起点的来源顶点设为-1。

当想要遍历起点s到某个顶点v的路径时，创建一个栈，先将v顶点入栈，然后根据edgeTo[v]找到v的来源顶点并将其入栈，同理再找到egdeTo[v]的来源顶点并入栈，以此类推直到将s入栈为止。最后依次出栈就可以按顺序遍历出起点s到某个顶点v的路径了。

#### 广度优先搜索（BFS）

**单点最短路径** 给定一幅图和一个起点s，问“起点s到给定目的顶点v之间是否存在一条路径？”，若存在，请找出最短的那条路径。

解决这个问题的经典问题就是广度优先搜索。

**基本思想**：要找到起点s到某个顶点v的最短路径，可以先从所有一条边就可到达的顶点中寻找v，如果找不到就继续在与s距离2条边的所有顶点中寻找，如此一直进行。

在DFS中由于使用递归，所以相当于使用使用了先进后出的栈（不是最后用于打印路径时用来遍历edgeTo的那个栈，而是使用递归时的程序调用栈）。而在BFS中应该按照与顶点的距离顺序来遍历所有顶点，于是就使用队列来（在意思上）替换原来的栈即可（就是现实的使用一个队列而不是用递归，递归算是一个隐式的栈）。

**具体实现** 使用一个队列来保存所有已经被标记但其邻接表还未被检查过的顶点。先将起点加入队列，然后重读下列步骤直到队列为空：

- 取队列中的下一个顶点v进行标记
- 将与v相邻的所有未标记的的顶点加入队列

同样也会使用一个edgeTo数组来记录来源顶点。