## 链接

一个c语言文件从.c文件到可执行文件的转化过程主要有四个过程：

- 预处理
- 编译
- 汇编
- 链接

----



### 预处理
#### 预处理器
预处理使用的是预处理器，在Linux（GUN编译器套件）中的shell环境下使用`gcc -E source.c -o target.i`命令可以将`.c`文件转化成`.i`文件。也可以使用预处理命令`cpp source.c > target.i`

##### 总结预处理命令：

- `gcc -E source.c -o target.i`
- `cpp source.c > target.i`

#### 预处理过程

##### 主要处理.c源文件中的以`#`井号开头的预编译指令语句：

- 先删除所有#define，并展开所有宏定义。展开宏定义就是将宏定义进行文本替换，例如宏定义`#define DATASIZE 20`在进行预处理时，会将程序代码中的所有的`DATASIZE`都替换为`20`，但是字符串中的`DATASIZE`除外(如`char a[] = "DATASIZE is ...";`就不会变成`char a[] = "20 is ...";`)
- 处理所有条件预编译指令：`#if`，`#ifdef`，`ifndef`，`else`，`elif`，`#endif`等。这些指令使用方式和普通的条件语句类似。使用这些条件预编译指令的好处是，可以根据不同的宏定义来处理不同的代码块。
- 处理`#include`头文件包含指令。就是将inlcude指令中指定的文件全部代码插入到该语句的所在位置。并且这些插入的文件也会递归的执行预处理。
- 保留所有`#pragma`编译指令，因为这些指令会在编译时使用。

##### 除了处理带井号的预编译指令外，预处理还进行其他工作：

- 删除所有注释，即删除被`//`或者`/**/`包含的部分以及这些注释符号。
- 添加行号和文件标识，方便编译时编译器产生调试用的行号信息。

#### 预处理结果

预处理后的`.i`文件仍然是可读文件但不包含任何宏定义，机器仍然是无法识别的。 

#### 关于插入头文件：
使用头文件的主要目的是可以使一个文件中的定义被多个其他文件使用。而在引入头文件时的搜索规则如下：
- 所有的头文件的搜索会从`-I`开始。`-I`就是在shell环境下使用gcc时的命令行参数，指定头文件寻找的第一个目录。
- 然后从gcc的环境变量 `C_INCLUDE_PATH`,`CPLUS_INCLUDE_PATH`,`OBJC_INCLUDE_PATH` （这些变量在windows下对应的是include环境变量）。
- 最后再找默认目录（`/usr/include`, `/usr/local/include`, `/usr/lib/gcc-lib/xxxx-linux/x.xx.x/include` 等等）

----



### 编译

#### 编译器

编译使用的是编译器，在Linux（GNU编译器套件）中的shell环境下使用`gcc -S source.i -o target.s`命令可以将预处理后得到的预处理文件（`.i`）转化为汇编代码文件（`.s`）；也可以使用`gcc -S source.c -o target.s`命令将`.c`文件进行预处理并且编译成汇编代码文件，即将预处理和编译两个过程一起来做。当然也可以使用`/user/lib/gcc/i486-linux-gun/x.x/cc1 source.c`命令直接进行预处理及编译，默认生成`source.s`。

##### 总结编译命令：

- `gcc -S source.i -o target.s`
- `gcc -S source.c -o target.s`
- `/user/lib/gcc/i486-linux-gun/x.x/cc1 source.c`

#### 编译过程

所谓编译，就是将预处理后的**预处理文件**进行词法分析、语法分析、语义分析并优化，生成包含汇编指令的**汇编代码文件**。

#### 编译结果

编译后得到的汇编代码文件还是可读的文本文件，CPU仍然无法理解和直接执行它。

----



### 汇编

#### 汇编器（汇编程序）

汇编使用汇编器，在Linux（GNU编译器套件）中的shell环境下使用`gcc -c source.s -o target.o`命令可以将编译后得到的汇编代码文件（`.s`，又叫汇编语言源程序）转化为机器指令序列（`.o`，又叫机器语言程序）；也可以使用`gcc -c source.c -o target.o`命令将`.c`文件进行预处理、编译以及汇编成机器指令序列，即将预处理、编译和汇编三个过程一起来做。当然也可以使用`as source.c -o target.o`命令。

##### 总结汇编指令：

- `gcc -c source.s -o target.o`
- `gcc -c source.c -o target.o`
- `as source.c -o target.o`

#### 汇编过程

汇编指令和机器指令一一对应，汇编指令是机器指令的符号表示，它们都属于机器级指令，所构成的程序称为机器级代码

#### 汇编结果

汇编结果是一个可重定位目标文件，这个文件是不可读的二进制代码。这个文件一般来说还不能马上运行，因为还要和其他的目标文件进行链接。

目标文件由段组成，通常一个目标文件中有两个段：

- 代码段：包含程序的指令。该段一般可读可执行，但一般不可写
- 数据段：存放程序要用到的各种全局变量或静态的数据。一般可读可写可执行。

----



### 链接

#### 链接器

将可重定位目标文件(`.o`)以及所需静态库(`lib.a`)经过链接器的处理(`gcc` 或 `ld`)最终成为计算机可执行的程序。在Linux（GNU编译器套件）中的shell环境下直接使用`gcc`加上需要链接的可重定位目标文件即可，若不是用`-o`选项，则可执行文件默认的文件名为`a.out`。也可以使用`ld`命令。

##### 总结链接命令：

- `gcc -static -o target source1.o source2.o`

- `ld -static -o target source1.o source2.o`

  `-static`表示静态链接，当然也存在动态链接。

#### 链接过程

预处理、编译以及汇编都是针对一个模块（一个.c文件）进行处理，得到的是一个可重定位目标文件；而链接是将多个可重定位目标文件合并生成可执行目标文件。



##### 详细的操作步骤：

- 首先确定符号引用关系，即可重定位



#### 链接结果

链接结果是得到一个可执行目标文件。

#### 链接主要步骤

##### 符号解析（symbol resolution）

连接器先会给要进行链接的所有可重定位目标文件（`.o`）中的每个符号应用一个唯一的符号定义，这个符号定义是用来寻找符号位置的标志。然后将符号的引用和符号的定义关联起来就完成了符号解析。

##### 重定位

将要进行链接的所有可重定位目标文件合并成一个文件（也就是放在同一个地址空间内，这个地址空间是虚拟地址空间，而不是实际的内存上的空间），即代码都放在代码段，数据都放在数据段。然后会把原来在单个可重定位目标文件中的符号相对位置转化为可执行程序（虚拟空间中）的绝对位置，并根据新的地址来更新对应符号的引用。

#### 链接的好处

##### 模块化

- 一个程序可以分成很对源程序
- 可构建共享函数库，如数学、C标准库

##### 效率高

- 时间上，可分开编译
- 空间上，无需包含共享库所有代码
  - 源文件可以直接调用共享库所有代码而不用包含相关代码
  - 可执行文件和运行时的内存中只需要包含用到的函数的代码，而不需要将整个共享库都包含进来

#### 链接的本质

##### 符号定义

每个模块（`.c`文件）都有自己的代码和数据，其中数据包括：初始化全局变量、未初始化全局变量，静态变量、局部变量等。

这里的局部变量是分配在栈中，不会被函数或过程外界所引用，因此局部变量不是符号定义。

gcc命令：就是ccp，cc1，as等命令的包装命令。用户可以通过gcc命令来使用具体的预处理程序ccp、编译程序cc1和汇编程序as等。而且相应的可以加上命令参数。

##### 链接的本质是：合并相同的节（段）

就是将所有要链接的可重定位文件中的数据节放在一起生成可执行目标文件的数据节（`.data`）；将代码节放在一起生成可执行目标文件的代码节（`.text`）。有时候还有`.bss`等其他节也放到一起生成可执行目标文件的相应的节。

可执行目标文件中这些新的节都是已经链接过的，其中的符号都换成了相应的地址。

----



## 目标文件

### 三种目标文件

- 可重定位目标文件 Relocatable object file（`.o`）
  - 其代码和数据可以和其他可重定位目标文件合并为可执行文件
  - 每个`.o`文件由对应的`.c`文件生成
  - 每个`.o`文件的数据和代码地址都是从0开始的
- 可执行目标文件 Executable object file（Linux默认是`a.out`，Windows中是后缀为exe的文件）
  - 是由链接器产生的，包含数据和代码，可以直接复制到内存中被执行
  - 代码和数据的地址是虚拟地址空间中的地址
- 共享目标文件Shared object file（`.so`）
  - 特殊的可重定位目标文件，能在装入或运行时被装入到内存并自动被链接，称为共享文件
  - 在Windows中称为Dynamic Link Libraries（DLLs）

### 目标文件格式

目标代码 Object code：指的是编译器和汇编器处理源代码后生成的机器语言目标代码

目标文件 Object file：指包含目标代码的文件

Linux等类Unix使用的是ELF格式，称为可执行可链接（Executable and Linkable Format）。因此该文件有两种视图：链接视图和执行视图。

Windows中的是PE格式，可移植可执行（Portable Executable）

##### 链接视图

- 链接视图指的就是可重定位目标文件，其可被链接生成可执行目标文件。
- 静态链接库由若干个可重定位目标文件组成
- 链接视图包含代码和数据，数据里已经初始化的全局变量和局部静态变量构成.data；未初始化的全局比那辆和局部静态变量构成.bss
- 链接视图还包含重定位信息（指出哪些符号引用处需要重定位）
- 文件扩展名为.o
- 当然为了进行链接还需要其他的的信息，如符号表、重定位信息等其他的节


##### 节（section）

节是ELF文件中的具有相同特征的最小可处理单位：

- .data：初始化的数据
- .text：代码
- .rodata：只读数据
- .bss：未初始化的数据

链接视图由节和节头表组成，而执行视图由不同的段（segment）组成，段其实就是节的组合。执行视图中还有程序头表，其描述的是节如何映射到存储段中，可多个节映射到同一段中。

在链接时由于不知道要把程序装入内存何处，所以就合并到一个虚拟地址空间中

### ELF可重定位目标文件格式

ELF格式的目标文件具体格式如下：

- ELF 头（ header）
  - 位于ELF文件开始。
  - 包含文件结构说明信息。
  - 分32位版本和64位版本。
  - 包含 16字节表示信息、文件类型（.o，.so）、机器类型、节头表的偏移、节头表的表项大小以及表项个数等
  - 要读取ELF头信息可以使用命令`readelf -h main.o`
- 段头表 Segment header table
  - 包含 page size, virtual addresses memory segments(sections), segment sizes
- .text 节
  - 代码部分
- .rodata 节
  - 只读数据部分，例如跳转表
- .data 节
  - 初始化的全局变量
- .bss 节
  - 未初始化的全局变量，仅是占位符，不占任何实际磁盘空间。
  - 这样区分初始化和非初始化是为了空间效率。
  - 在C语言中规定未初始化的全局变量和局部静态变量的默认初始值为0。
  - .bss中不用存放初始值，只用说明.bss中的每个变量将来在执行时占几个字节即可，因此实际不占磁盘空间，这样就提高了磁盘利用率。
- .symtab 节
  - 包含 symbol table, procudure 和 static variable names 以及 section names 和 location
- .rel.txt 节
  - .text section 的重定位信息
- .rel.data 节
  - .data section 的重定位信息
- .debug 节
  - 包含 symbolic debugging (`gcc -g`) 的信息
- strtab 节
  - 包含symtab和debug节中符号及节名
- 节头表 Section header table
  - 每个 节的名称、大小和偏移量
  - 访问属性、对齐方式等
  - 要读取节头表信息使用命令`readelf -S test.o`



在真正装入运行时有四个节将会分配存储空间：.text，.data，.bss.和rodata