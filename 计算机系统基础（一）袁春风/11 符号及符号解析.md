> 在链接过程中第一步是符号解析，所谓符号解析就是将符号的定义与符号的引用关联起来，那么什么是符号的定义与引用？

###  符号

符号包括函数和变量（局部非静态变量除外，这块不归链接器管，是在运行的时候在运行栈中分配空间）

下面几个例子说明定义的符号和引用的符号

```c
// main.c

// 符号定义 swap
void swap(...){ 
    ....
}

// 若符号定义 test
void test();

// 符号定义 x
int x = 10;

// 符号定义 xp，符号引用 x
int *xp = &x;

// 符号定义 main
int main(){
    // 局部变量，链接器不认，不会被外界引用，因此不是符号定义
    int y = 11;
    // 符号引用 swap
    swap(...);
}
```

上述代码说明，除了局部非静态变量，凡是带类型说明的都是定义，其他的都是引用。

编译器将**定义的符号**存放在符号表中，即在`.symtab`节中，每个表项包含符号名、长度和位置等信息

编译器将**引用的符号**存放在重定位节中（`.rel.text `  和 `.rel.data`）中

链接器的工作就是将每个符号的引用都与一个确定的符号定义相关联。

##### 符号的定义：

是指被分配了存储空间。

函数名即指：其代码所在区

变量名即指：其所占的静态数据区

所有定义符号的值就是其所在的首地址

#### 符号分类

模块：指可重定位模块m

- 全局符号（Global symbols）
  - 模块内部定义的并能被其他模块引用的符号
  - 非static C函数和非static 的C全局变量
- 外部符号（External symbols）
  - 由其他模块定义的并被本模块引用的全局符号
- 局部符号（Local symbols）
  - 仅有本模块定义且只在本模块中引用的本地符号
  - 在模块中定义的statc的C函数和C变量
  - 这里的局部不是指C语言中的局部变量，而是只放在静态区的变量l

##### 全局符号的强弱

- 首先看是否是全局的符号


- 符号的定义才有强弱之分，而符号的引用没有


- 函数的定义和已初始化的全局变量名是强符号
- 未初始化的全局变量名是弱符号
- 函数的原型声明是弱符号

#### 连接器对符号解析的规则

##### 多重定义符号的规则

- 强符号不能定义多次，即强符号只能被定义一次，否则就会发生链接错误
- 若一个符号被定义为一次强符号和多次弱符号，则按强符号定义为准。即对弱符号的引用解析为其强符号的定义
- 若有多个弱符号定义，则任选一个。在链接时，使用`gcc -fno-common`命令时，会告诉链接器在遇到多个弱定义的全局符号时输出一条警告信息。
- 符号解析时最终只能有一个定义，也就是说一个符号只能占一个存储空间

**如果可能，尽量避免使用全局变量**

如果一定要用的话，注意下面几点：

- 使用静态变量
- 定义全局变量的时候初始化
- 注意使用 `extern` 关键字，说明该符号在其他模块中定义的

#### 关于静态库

##### 打包常用程序

基本上每个程序都会用到某些特定的函数，比如：数学计算, 输入输出, 内存管理, 字符串操作等等，我们能用什么方法把它们结合到程序中呢，有以下两个思路：

- 思路 1：把所有的函数放到一个源文件中，程序员每次把这一整个大块头链接到自己的程序中，这种做法从时间和空间上来说都比较低效
- 思路 2：不同的函数放到不同的源文件中，由程序员显式链接所需要的函数，这种做法效率更高，但是相当于是给程序员增加负担了

##### 静态库 Static Library

比较老式的做法就是所谓的静态库(Static Libraries, `.a` 表示 archive files)

静态库是一个外部函数与变量的集合体。静态库的文件内容，通常包含一堆程序员自定的变量与函数，其内容不像动态链接库那么复杂，在编译期间由编译器与连接器将它集成至应用程序内，并制作成目标文件以及可以独立运作的可执行文件。而这个可执行文件与编译可执行文件的程序，都是一种程序的静态创建（static build）

具体过程就是把不同文件的 .o 文件通过 Archiver 打包成为一个 .a 文件。Archiver 支持增量更新，如果有函数变动，只需要重新编译改动的部分。

在 C 语言中最常用的是 C 标准库与 C 数学库。C 标准库一般可以通过 `libc.a` 来进行引用，大小 4.6 MB，包含 1496 个对象文件，主要负责输入输出、内存分配、信号处理、字符串处理、操作数据和实践、生成随机数及整型的数学运算。C 数学库可以通过 `libm.a` 来引用，大小 2 MB，包含 444 个对象文件，主要是提供浮点数运算的支持（比如三角函数、幂次等等）

#### 符号解析过程

假设有一个链接指令：`gcc - static -o myproc main.o ./mylib.a`

其中`mylib.a`是一个自定义静态库，其中有连个函数定义`myfun1`和 `myfun2`，这两个函数都调用了`printf`函数打印一段字符串。`main.o`模块中的`main`函数调用了`myfunc1`函数。

再假设有三个集合

- E：将被合并并组成可执行文件的所有目标文件集合
- U：当前所有未解析的引用符号的集合
- D：当前所有定义符号的集合

一开始单个集合全为空，首先把第一个模块`main.o`加入到E中，同时把模块`myfunc1`加入到U，`main`函数加入到D中（因为`main`函数已经有定义了）。接着扫描到`mylib.a`， 将U中的模块与`mylib.a`中的所有模块进行匹配，匹配到`myfunc1`后就将`myfunc1.o`加入到E，将`myfunc1`从U转入到D。在`myfunc1.o`中发现了`printf`，因此将其加入到U中。然后就这样不断在静态库中匹配U中的符号，直到U和D都不在变化为止。此时U中还有个未找到定义的`printf`，D中是`main`和`myfunc1`，而`myfun2.o`被丢弃。

最后再扫描默认的库文件`lib.c`，发现了`printf.o`的定义，将其加入到E中，并将`printf`从U转移到D，同时迭代的将`printf.o`定义的符号都加入到D，而未解析的符号加入到U。

处理完`lib.c`时，U一定是空的，否则就会报错。

还有一点需要注意，在链接时应按照调用顺序来进行链接，否则会发生链接错误。例如使用如下命令顺序进行链接就会出错：`gcc -static -o myproc ./mylib.a main.o`。这里会出错是因为先扫描到自定义静态库，于是进行静态库和结合U进行匹配，而此时U集合为空，于是`mylib.a`中的那两个函数就会被丢弃从而不会进入到集合E中，而当扫描到`main.o`时，其中调用的`myfunc1`只能去标准静态库`lib.c`中寻找，但又找不到，最终只能报出链接错误。

**综上所述：在进行链接时，静态库最好放在命令的最后面**

