## 重定位

重定位三个步骤：

- 合并相同的节：就是将集合E中的所有模块中所有相同的节合并在一个形成新的节
- 对集合D中的**定义符号**进行重定位，也就是确定合并后的新的节中的符号在虚拟地址空间的地址
  - 函数首地址
  - 变量首地址
- 对**引用符号**进行重定位，将引用符号替换成符号相应的虚拟地址空间地址
  - 修改.text节和.data节中每个符号的地址
- 要读取重定位信息可以用命令：`readelf -r main.o`


### 重定位节的相关条目

- r_offset：节内偏移
- r_symbol：绑定符号是在符号表中的第几个符号
- r_type：重定位类型，有两种：
  - R_386_32：绝对地址
  - R_386_PC32：PC相对地址

### PC相对地址重定位 R_386_PC32

转移目标地址 = PC+偏移地址（重定位后放在call指令后的地址）

其中PC是当前 执行指令的下一条指令的地址

而在机器中计算PC的方法是PC = main + 偏移量 - init，这里main指代一个函数的重定位后的首地址，偏移量是指该条指令在.text节中设定的对于函数首地址的偏移量，init是指在进行重定位之前call指令后面的暂时的值（等待被重定位的值）

重定位值 = 转移目标地址-PC

因此在PC重定位相对地址方式下，重定位的计算公式：

$$重定位值 = ADDR(r\_sym) - ((ADDR(.text) + r\_offset) - init)$$

等号右边第一项表示转移目标地址（引用目标处），第二项表示PC（call指令下条指令地址）。

### 绝对地址重定位

就是在可重定定位目标文件中将引用处设为全零，然后在链接的重定位时直接替换成是实际虚拟空间地址即可。



## 可执行文件加载

可执行目标文件中有程序头表，该表描述了可执行文件中代码和数据的存储映射。

这里所谓的存储器不是物理存储器，而是虚拟地址空间。

可执行文件在加载时，通过调用execve系统调用函数来调用加载器。

加载器根据可执行文件的程序头表，将可执行文件的代码和数据从磁盘拷贝到存储器中。

这里的拷贝不是真正意义上的拷贝，而是建立一种映射。

加载后，将PC设定指向符号_start出，最终执行main函数，已启动程序执行。

## 共享库和动态链接

#### 静态库函数的缺点

- 浪费主存资源：静态库函数被包含在每个进程的代码段中，当系统上运行上百个进程时，就会产生极大的主存资源浪费
- 浪费磁盘空间：静态库函数会在链接时合并到可执行目标文件中，磁盘上存放着上千个可执行目标文件，就会造成磁盘空间的浪费
- 更新困难，使用不便：每当静态库函数更新时们都需要将使用该库函数的程序代码重新编译、链接

### 共享库 Shared Libraries

- 在windows中被称为动态链接库（Dynamic Link libraries，dll文件）
- Linux中成为动态共享对象（Dynamic Shared objects， .so文件）
- 共享库代码包含目标模块的文件，每个模块包含代码和数据
- 从程序中分离出来，磁盘和内存中都只有一个备份
- 可以在装入时或运行时动态的加载并链接



- 动态链接可以在首次载入的时候执行(load-time linking)，这是 Linux 的标准做法，会由动态链接器 `ld-linux.so`完成，比方标准 C 库(libc.so) 通常就是动态链接的，这样所有的程序可以共享同一个库，而不用分别进行封装。

  ​

- ![img](https://wdxtub.com/images/14613373029640.jpg)

- 动态链接也可以在程序开始执行的时候完成(run-time linking)，在 Linux 中使用 `dlopen()` 接口来完成（会使用函数指针），通常用于分布式软件，高性能服务器上。

#### 共享库的优点（对应静态库的缺点）

- 节省内存空间：共享库模块在内存中只有一个备份，被所有进程共享
- 节省磁盘空间：共享库文件在磁盘中只有一个备份，被所有程序共享链接
- 使用方便，更新容易：共享库升级时，被自动加载到内存，并和程序动态链接
- 效率高：共享库可以分模块，并独立的用不同的编程语言进行开发
- 易于扩展：第三方开发的共享库可以作为程序插件，使程序功能更容易扩展

#### 自定义动态共享库

使用命令：`gcc -shared -fPIC -o mylib.so myproc1.o myproc2.o`

PIC：表示位置无关：

- 保证共享库的代码的位置可以不确定
- 即使共享库代码的长度发生变化，也不会影响调用它的程序的执行


