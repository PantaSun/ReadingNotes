## 异常控制流

CPU会因遇到内部异常或外部中断等原因而打断程序的正常控制流，转去执行操作系统提供的针对这些特殊时间的处理程序。

由于某些特殊情况引起用户程序的正常执行被打断所形成的意外控制流称为异常控制流。

异常控制流的形成原因：

- 内部异常（缺页、越权、越级、整除0、溢出等）
- 外部中断（ctrl+c、打印机缺纸、DMA结束的等）
- 进程的上下文切换
- 一个进程直接发送信号给另一个进程

## 程序和进程

程序：指按某种方式组合形成的代码和数据集合，代码即是机器指令序列，因而是一种静态的概念

进程：指程序的一次运行过程，更确切的说，进程是具有独立功能的一个关于某个数据集合的几次运行活动，因而进程具有动态含义。同一个程序处理不同数据就是不同的进程。进程是有自己的生命周期的。

补充：程序需要被启动执行后才能成为进程，机器代码和数据被映射到同一的虚拟空间这件事时链接程序完成的，链接后只能生成一个可执行文件或共享库文件，不能形成一个进程。

### 引入进程的好处

进程可以为应用程序提供两方面的抽象：

- 一个独立的逻辑控制流：每个进程拥有一个独立的逻辑控制流，使得程序员以为自己的程序在执行过程中独占使用处理器。

- 一个私有的虚拟地址空间：每个进程拥有一个私有的虚拟地址空间，使得程序员以为自己的程序在执行过程中独占使用存储器

- 总的来说，进程的引入简化了编程、编译、链接、共享和加载等整个过程。


## 进程的逻辑控制流

对于某个确定的数据集，某进程指令执行地址序列是确定的。称为进程的逻辑控制流。

补充：

- 进程的逻辑控制流指其运行过程中指令的虚拟地址序列，而每个进程的虚拟地址空间都是一样的，因此不同进程的逻辑控制流中可能存在相同的指令地址序列。

- 链接时可以确定每条指令和每个数据在虚拟地址空间的地址，但是不能确定条件转移指令是否满足，因而不能确定具体执行的是哪些指令，因而链接时不能确定将来执行时的逻辑控制流。



## 上下文切换

实现不同进程中指令交替执行的机制成为进程的上下文切换。

处理器调度事件会引起用户程序正常执行被打断，因而形成异常控制流。进程的上下文切换机制很好的解决了这类异常控制流，实现了从一个进程安全切换到另一个进程的过程，

#### 进程的上下文

进程的物理实体（代码和数据）和支持进程的运行环境合称为进程的上下文。

由进程的程序块、数据块、运行时的堆和用户栈等组成的用户控件信息称为用户级上下文。

由进程标识信息、进程现场信息、进程控制信息和系统内核栈等组成的内核信息被称为系统级上下文。



补充：进程的上下文切换仅是把正在处理器上执行的进程换下，让另一个进程占用处理器执行指令。要将换下进程的上下文信息保存到栈中，不需要将换下进程的代码和数据从主存保存到磁盘中。



### 进程的虚拟地址空间

IA-32/Linux进程虚拟地址空间分为内核空间和用户空间，分别占高地址1GB和低地址3GB空间

#### 内核空间

内核空间存放：

- 与进程相关的数据结构（如页表、task和mm等结构、系统没核栈等）这部分对于每个进程都不同
- 物理存储区 ，这部分对每个进程都相同
- 内行代码和数据，对每个进程都相同

#### 用户空间

用户区存放：

- 用户栈
- 共享库映射区域
- 运行时堆（用malloc创建）
- 可读写数据区域（.data、 .bss）
- 只读区域(.init 、.text、.rodata)

用户空间的静态区由只读代码段和可读可写数据段组成，只读代码段由代码区和只读数据区组成，可读可写数据段由已经初始化的数据区和没有进行初始化的数据区组成。



## 程序的加载和运行

在Unix/Linux系统中，可通过调用execve()函数来启动加载器。该函数功能是在当前进程上下文中加载并运行一个新程序。

加载器根据可执行文件的程序（段）头表中的信息，将可执行文件的代码和数据从磁盘“拷贝”到存储器中（实际上不算是真正意义上的拷贝，仅建立一种映像）。加载后将PC设定指向Entry point（即符号_start处）最终执行main函数，已启动程序执行。也就是说加载器只会根据可执行文件的程序头表等信息建立新加载程序的一些初始数据结构，如对页表信息进行初始化等，而不会从磁盘中把可执行文件中的代码和数据读到内存。只有发生缺页异常时才会把代码和数据从磁盘读到内存。

Shell命令解释程序本身运行在用户态，他通过调用fork()、execve()等系统调用封装函数实现程序的加载和执行，在执行这些系统调用函数时，会通过int  0x80指令陷入内核，从而在内核态由内核代码实现相应的子进程创建、程序加载等工作。