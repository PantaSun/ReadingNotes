## Linux中对IDT的初始化

- Linux利用陷阱门来处理异常，利用中断门来处理中断
- 异常和中断对应的处理程序都属于内核代码段，所以，所有中断门和陷阱门的段选择符都指向GDT中的“内核代码段”描述符
- 通过中断门进入一个中断服务程序后，CPU会清楚EFLAGS及承诺其中的IF标志，即关中断
- 通过陷阱门进入一个异常处理程序时，CPU不会修改IF标志。也就是说外部中断不支持嵌套处理，而内部异常则支持嵌套处理。因为处理异常时是执行内核代码指令，也可能发生异常，如缺页等，如果把异常关掉了，就无法响应新出现的异常了。

### 初始化IDT

Linux运用硬件提供的三种门描述符格式，构造了5种类型的门描述符：

- 中断门：DPL=0，TYPE=1110B。激活所有中断
- 系统门：DPL=3，TYPE=1111B。激活4（溢出）、5（边界检查）和128（系统调用）三个陷阱异常。因为DPL=3，CPL小于等于DPL，所以用户态下可以使用这三条指令。
- 系统中断门：DPL=3，TYPE=1110B。激活3号中断（断点调试）对应指令int 3。因为DPL=3，CPL小于等于DPL，所以用户态下可以使用int 3指令。
- 陷阱门：DPL=0，TYPE=1111B。激活所有内部异常，并阻止用户程序使用INT n（n不等于3或128）指令来模拟非法异常来陷入内核态。
- 任务门：DPL=0，TYPE=0101B。激活8号中断（双重故障）。

Linux内核在启用中断机制之前，先设置好IDT，并把IDT首地址放入IDTR。系统初始化时，Linux完成对GDT、GDTR、TDT和IDTR等的设置，以后一旦发生异常或中断，CPU就可以通过异常和中断响应机制调出中断或异常处理程序执行。

## Linux对异常的处理

异常处理程序发送相应的信号给发生异常的当前进程，或者进行故障恢复，然后返回到断点处执行。

异常处理程序为什么只是发送一个信号做为处理方式。因为这样可以尽快完成在内核态的异常处理过程，在内核的处理过程越长，就越容易发生嵌套异常，这样系统的花销就越大。

并不是所有异常处理都只是发送一个信号到发生异常的进程。对于可恢复的异常，异常处理程序直接对其进行恢复，然后会返回断点处继续执行。

### Linux中对异常的处理程序结构

1. 准备阶段：在内核保存通用寄存器内容（称为现场信息），这部分大多用汇编语言来实现
2. 处理阶段：采用C函数进行具体处理。函数名采用由do_前缀和处理程序名组成。这些函数不部分的操作是：保存硬件出错码（如果有的话）和异常类型号，然后向当前进程发送一个信号。当前进程接收到信号后，如果有相应的信号处理程序，则转信号处理程序执行；若没有，则调用内核abort例程执行，以终止当前进程。
3. 恢复阶段：恢复保存在内核栈中的各个寄存器的内容，切换到用户态并返回当前进程的断点处继续执行。

异常处理程序实在内核态执行的，这些程序的主要工作是发信号（如果需要发送的话）。

信号处理程序在用户态执行。



## Linux对中断的处理

对于中断，因为中断事件的发生于正在执行的当前进程很可能没有关系，所以使用像异常那样的发送信号给当前进程是没有意义的。

Linux有三种中断：

1. IO中断
2. 始终中断
3. 处理器中断

###  IO中断

每个能发送中断请求的外设控制器都要一条IRQ线，所有IRQ线路连接到一个可编程中断控制器PIC中对应的IRQ引脚上，PIC中每个IRQ引脚都有一个编号，与编号相关联的中断类型号设定为32+i。

CPU每执行完一条指令都会查询INTR，若发现中断请求，则进入中断响应过程（关中断、保护断点和现场、发中断查询信号），调出中断服务程序执行。



## IA-32Linux的系统调用

系统调用（陷阱）是特殊异常事件，是操作系统为用户提供服务的手段。

Linux为用户提供了几百种系统调用。

系统调用号是系统调用跳转表索引值，跳转表给出系统调用服务例程首地址。

通常，系统调用被封装成用户程序能直接调用，如exit()、read()等。这些都是标准C库中系统调用对应的封装函数。

Linux中系统调用所用参数通过寄存器传递，传递参数的寄存器顺序依次为：EAX（调用号）、EBX、ECX、EDX、ESI、EDI和EBP，除了调用号以为，最多6个参数。

封装函数对应的机器级代码有一个统一的结构：

- 总是若干条传送指令后跟一条陷阱指令。传送指令用来传送系统调用的参数，陷阱指令用来陷入内核进行处理。

举例：某函数调用了printf()函数，执行到调用printf()语句时，变回转到C语言I/O标砖库函数printf()去执行；

- printf()函数通过一系列函数调用，最终调用函数write()
- 调用write()时，便会通过一系列步骤在内核空间中找到write对应的系统调用服务例程sys_write来执行。