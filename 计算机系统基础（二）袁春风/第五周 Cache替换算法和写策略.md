### 问题提出

在组相联时，假设Cache有8组，每组两行。当第0组被第0块和第8块占满时，此时若需要调入主存第16块，根据映射关系，它也只能放在第0组中，但这时候第0组已经满了，因此第0组中必须有一行被替换掉，那么到底应该替换哪一行呢？

### 常用的替换算法

先进先出FIFO

最近最少用LRU

最近不经常用LFU

随机替换算法Random



### 写策略（Cache一致性问题）

#### 如何保持在Cache中的副本与主存中数据的一致

因为Cache中的内容是主存中的副本，所以当对Cache中数据进行更新时，就存在上述一致性问题。

#### 写操作的两种情况

- 写命中：要写的单元在Cache中
- 写不命中：要写的单元不在Cacahe中



#### 对于写命中的两种策略

- Write Through（通过式写、写直达、直写）：同时写Cache和主存单元，这种方式比较慢，因此可以添加Write Buffer进行缓冲。CPU写数据到Cache的同时也写到Write Buffer中，然后Memory controller（存控）将缓冲内容写到主存。这个方式也有一定的局限性，因为Write Buffer一般只有4项是一个先进先出队列，在存数频率高的时候易发生缓存饱和，发生阻塞。
- Write Back（一次性写、写会、回写）：只写Cache不写主存，缺失时一次写回。当要对某个单元进行写操作室，要对其在主存相应的位置加锁，禁止其他设备访问。可以加个标志位（“dirty  bit - 脏位”），对于“未弄脏”的数据就不需要写回主存，只对“脏数据”进行写回，这样就大大降低主存带宽需求。

#### 对于写不命中的两种策略

- Write Allocate（写分配）：
  - 将主存装入到Cache中，然后更新相应单元
  - 试图利用空间局部性，按每次都要从主存读一个块
- Not Write Allocate（非写分配）：
  - 直接写主存单元，不把主存块装入到Cache

