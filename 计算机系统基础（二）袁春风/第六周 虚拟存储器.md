## 分页存储的基本概念

### 早期分页

基本思想：把地址空间和主存容量的概念区分开来。程序员在地址空间里编写程序，而程序则在真正的内存中运行。由一个专门的机制实现地址空间和主存之间的映射。

例如：一个计算机的指令中给出的主存地址为16位，而实际主存容量只有4K字，则指令可寻址范围是多少2？

地址空间为0到2的16次方，而实际主存大小只有4096个地址，因此地址空间远大于实际主存。这时可以将地址空间划分成一个个大小为主存大小的区间。

在执行到某个区间，把该区间的地址自动映射到0-4095之间。而对程序员来说，可以在0-65535范围内写程序，完全不用管在多大的主存空间上执行。

这个区间后来被称为页（page），主存中存放页的区域被称为页框（page frame），早期只有一个页框。

### 分页（Paging）

#### 基本思想

- 内存被分为固定长且比较小的存储块（页框、实页、物理页）
- 每个进程也被划分成固定长的程序块（页、虚页、逻辑页）
- 程序块可以装到存储器中可用的存储块中
- 无需用连续页框来存放一个进程
- 操作系统为每个进程生成一个页表
- 通过页表（page table）实现了逻辑地址向物理地址转换（Address Mapping）



根据程序访问的局部性：可把当前活跃的页面调入主存，其余的留在磁盘上

**采用“按需调页Demand Paging”方式分配主存！**这就是虚拟存储管理概念



## 虚拟存储器及虚拟地址空间

### 虚拟存储技术的实质

- 程序员可以在比实际主存空间大得多的逻辑地址空间中编写程序
- 程序执行时，把当前需要的程序段和相应的数据块调入主存，其他暂时不用的部分存放在磁盘上。
  - 通过页表建立虚拟空间和物理空间之间的映射！
  - 每一个进程都有一页表，每一个页表都对进程的虚拟空间中的每一页都要进行说明，或者说该页在磁盘上，或者说该页在主存上的具体位置，或者说是一个空页。
  - 指令执行时，通过**硬件**将逻辑地址（也称虚拟地址或虚地址）转换为物理地址（也称主存地址或实地址）
  - 在发生程序或数据失效（缺页）时，由操作系统实现主存可磁盘之间的信息交换。

 

### 存储器的实现

三种实现方式：分页式、分段式、段页式

#### 先来看主存和磁盘层次与Cache和主存层次的一些比较：

- 页大小比Cache中的Block大小大得多，因为访问磁盘是一个很慢的过程，好不容易访问一次就要一次多取些数据。

- 主存和磁盘采用全相联映射，因为缺页的开销比Cache缺失的开销大得多。缺页时要访问磁盘（约几百万个时钟周期），而Cache缺失时，访问主存仅需几十到几百时钟周期。因此页命中率比Cache命中率更重要！大页面和全相联可以提高命中率
- 通过软件来处理缺页，因为缺页时访问磁盘太慢，不能用硬件实现
- 采用Write Back写策略，因为要避免频繁的慢速磁盘访问操作。

#### 页表结构

每个进程都有一个页表，其中每一表项都有装入位、修改位、替换控制位、访问权限位、禁止缓存位、实页号。

一个页表的项数理论上由虚拟地址空间大小决定

每个进程具有相同的虚拟地址空间，所以理论上每个页表的大小一样。实际大小要看具体实现情况。

页表分类：

- 未分配页：进程的虚拟地址空间中“空洞部分”，表中的存放位置这一栏的值为null，装入位为0
- 已分配的缓存页：有内容对应的已装入主存的页，存放位置这一栏的值为主存中的位置，装入位为1
- 已分配的未缓存页：有内容对应但未装入主存的页，存放位置这一栏的值是磁盘中的位置，装入位为0

#### 快表--Making Address Translation Fast

把经常要查的页表项放到Cache中，这种在Cache中的页表项组成的页表称为Translation Lookaside Buffer or TLB（快表）

在主存中的页表叫慢表。

TLB中的页表项：tag+主存页表项

这里的tag表示哪一页的表项，即虚拟页号。

引入TLB的目的是减少到主存中访问页表的次数。



到目前为止CPU要访问主存会存在三种缺失：

- TLB缺失
- 缺页
- Cache缺失



### 存储器层次结构及访问过程

CPU拿到一个虚拟地址后先去TLB中查找，如果hit，那就根据TLB中相应的实页号并与页内偏移地址相组合得到实际主存地址，然后根据这个主存地址去Cache中寻找，如果也hit，那就直接取相应数据送给CPU。这是最好的情况。不需要访问主存。

如果第一次TLB中miss，那就要去主存中访问页表，如果hit，再去Cache中寻找

​											，如果miss，就去磁盘中寻找

Cache的miss处理方式就是按上一周中的策略进行操作。

这就是整个存储器的处理的访问过程。

### 分段式虚拟存储器

分页的方式有一定的缺陷，例如“关系密切”（具有空间局部性）的数据变量可能被划分到两个页中了甚至是一个变量的数据跨在两个不同的页中，又或者在不对齐的情况下一个页内既有数据又有代码，这样对于访问权限位就很难描述。

这时就出现了分段方式，分段方式不定长，便于操作系统管理，便于编译链接优化。

分段系统将主存空间按实际程序中的段来划分，每个段在主存的位置记录在段表中，并附有“段长”项。

物理地址 = 段起始地址 + 段内偏移

异常情况：

- 缺段（段不存在）
- 地址出界：偏移量超出最大段长
- 保护违例：访问操作与访问方式不匹配

缺点是可能在主存中产生很多小空闲片段，这些片段无法存放一个完整的段，就只能浪费空间。



### 段页式存储器

#### 基本思想

- 程序的虚拟地址空间按模块分段、段内再分页，进入主存仍以页为基本单位。

- 逻辑地址由段地址、页地址、和偏移量三个字段构成。
- 用段表和页表进行两级定位管理。

x86用的就是段页式。



### 存储保护

为避免多道程序互相干扰，防止某程序出错而破坏其他程序的正确性或不合法地访问其他程序或数据区，应对每个程序进行存储保护。

操作系统程序和用户程序都需要保护。

存储保护错误的几种情况：

- 地址越界：转换得到的物理地址不属于可访问范围
- 访问越界：访问操作与所拥有的访问权限不符（页表中会设定访问存取权限）

访问属性的设定：

- 数据段可指定R/W或RO
- 程序段可指定R/E或RO

最基本的保护措施：

规定各道程序只能访问属于自己的存储区和共享区

#### 硬件对于存储保护的支持

为了实现存储保护，硬件必须要有以下三种功能：

- 支持至少两种运行模式：
  - 管理模式（Supervisor Mode）：执行系统程序时CPU所处的模式称为管理模式，或称管理程序状态，简称管态、核心态、内核态等
  - 用户模式（User Mode）：CPU执行非操作系统的用户程序是，处理器所处的模式就是用户模式，或称用户状态、目标程序状态，或简称目态或用户态
- 使一部分CPU状态只能由内核读写而不能由用户程序读写：这部分包括：User/Supervisor模式为、页表首地址、TLB等。OS内核可以用特殊的指令来读写这些状态，而用户程序不能使用这些指令。
- 提供让CPU在管理规模是和用户模式相互切换的机制：“异常”和“陷阱”使CPU从用户态转到内核态；异常处理中的“返回”指令使CPU从内核态转到用户态。

总结起来就是：支持两种运行模式，对内核模式提供独有的指令，提供可以让两种模式相互转换的机制。



